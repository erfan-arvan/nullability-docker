Daikon version 5.8.20, released May 14, 2024; http://plse.cs.washington.edu/daikon.
Reading declaration files Processing trace data; reading 1 dtrace file:

===========================================================================
fri.patterns.interpreter.parsergenerator.Parser:::OBJECT
this has only one value
this.lexer.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
this.tables has only one value
this.tables != null
this.tables.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
this.semantic == null
this.stateStack has only one value
this.stateStack != null
this.valueStack has only one value
this.valueStack != null
this.rangeStack has only one value
this.rangeStack != null
this.result == null
this.inputTokens[] == []
this.inputTokens[].getClass().getName() == []
this.inputTokens.getClass().getName() == java.util.ArrayList.class
this.rangeList[] == []
this.rangeList[].getClass().getName() == []
this.rangeList.getClass().getName() == java.util.ArrayList.class
this.range != null
this.range.start != null
this.range.start.line == 1
this.range.start.column == 0
this.range.start.offset == 0
this.range.end != null
this.range.end.line == 1
this.range.end.column == 0
this.range.end.offset == 0
this.out == null
this.passExpectedToLexer == true
this.DEBUG == false
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.Parser(fri.patterns.interpreter.parsergenerator.ParserTables):::ENTER
arg0 has only one value
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.Parser(fri.patterns.interpreter.parsergenerator.ParserTables):::EXIT
this.lexer == null
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.clear():::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.clear():::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.rangeList == orig(this.rangeList)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.detectError(fri.patterns.interpreter.parsergenerator.Token, java.lang.Integer, java.lang.Integer):::ENTER
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg0.symbol has only one value
arg0.symbol.toString == "\"EoI\""
arg0.text == null
arg0.range has only one value
arg0.range.start has only one value
arg0.range.end has only one value
arg1 has only one value
arg2 has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.detectError(fri.patterns.interpreter.parsergenerator.Token, java.lang.Integer, java.lang.Integer):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg0.symbol == orig(arg0.symbol)
arg0.symbol.toString == orig(arg0.symbol.toString)
arg0.text == orig(arg0.text)
arg0.range == orig(arg0.range)
arg0.range.start == orig(arg0.range.start)
arg0.range.end == orig(arg0.range.end)
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg0.symbol has only one value
arg0.symbol.toString == "\"EoI\""
arg0.text == null
arg0.range has only one value
arg0.range.start has only one value
arg0.range.end has only one value
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.detectError(fri.patterns.interpreter.parsergenerator.Token, java.lang.Integer, java.lang.Integer):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.dumpStack():::ENTER
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.dumpStack():::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.getNextToken():::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.getNextToken():::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.rangeList == orig(this.rangeList)
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
return.symbol.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
return.text.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.getParserTables():::ENTER
this.lexer has only one value
this.lexer != null
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.getParserTables():::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.lexer != null
return has only one value
return != null
return.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.parse():::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.parse():::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.parse():::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.parse(java.lang.Object):::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 has only one value
arg0.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.parse(java.lang.Object):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.parse(java.lang.Object):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.pop(int):::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.pop(int):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.push(java.lang.Integer, java.lang.Object, fri.patterns.interpreter.parsergenerator.Token$Range):::ENTER
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg1.getClass().getName() == java.lang.String.class
arg2.start.line == 1
arg2.start.column one of { 0, 6 }
arg2.start.offset one of { 0, 6 }
arg2.end.line == 1
arg2.end.column one of { 0, 5, 11 }
arg2.end.offset one of { 0, 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.push(java.lang.Integer, java.lang.Object, fri.patterns.interpreter.parsergenerator.Token$Range):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
arg2.start == orig(arg2.start)
arg2.start.line == orig(arg2.start.line)
arg2.start.column == orig(arg2.start.column)
arg2.start.offset == orig(arg2.start.offset)
arg2.end == orig(arg2.end)
arg2.end.line == orig(arg2.end.line)
arg2.end.column == orig(arg2.end.column)
arg2.end.offset == orig(arg2.end.offset)
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg2.start.line == 1
arg2.start.column one of { 0, 6 }
arg2.start.offset one of { 0, 6 }
arg2.end.line == 1
arg2.end.column one of { 0, 5, 11 }
arg2.end.offset one of { 0, 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.recover(java.lang.Integer, fri.patterns.interpreter.parsergenerator.Token):::ENTER
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg1.symbol.toString one of { "\"EoI\"", "\"World\"" }
arg1.text.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.recover(java.lang.Integer, fri.patterns.interpreter.parsergenerator.Token):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg1.symbol == orig(arg1.symbol)
arg1.symbol.toString == orig(arg1.symbol.toString)
arg1.text == orig(arg1.text)
arg1.text.getClass().getName() == orig(arg1.text.getClass().getName())
arg1.range == orig(arg1.range)
arg1.range.start == orig(arg1.range.start)
arg1.range.end == orig(arg1.range.end)
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg1.symbol.toString one of { "\"EoI\"", "\"World\"" }
arg1.text.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.reduce(java.lang.Integer):::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.reduce(java.lang.Integer):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.semanticPop(int, int):::ENTER
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 one of { 0, 1 }
arg1 == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.semanticPop(int, int):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.semanticPush(java.lang.Object, fri.patterns.interpreter.parsergenerator.Token$Range):::ENTER
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0.getClass().getName() == java.lang.String.class
arg1.start.line == 1
arg1.start.column one of { 0, 6 }
arg1.start.offset one of { 0, 6 }
arg1.end.line == 1
arg1.end.column one of { 0, 5, 11 }
arg1.end.offset one of { 0, 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.semanticPush(java.lang.Object, fri.patterns.interpreter.parsergenerator.Token$Range):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
arg1.start == orig(arg1.start)
arg1.start.line == orig(arg1.start.line)
arg1.start.column == orig(arg1.start.column)
arg1.start.offset == orig(arg1.start.offset)
arg1.end == orig(arg1.end)
arg1.end.line == orig(arg1.end.line)
arg1.end.column == orig(arg1.end.column)
arg1.end.offset == orig(arg1.end.offset)
this.lexer has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg1.start.line == 1
arg1.start.column one of { 0, 6 }
arg1.start.offset one of { 0, 6 }
arg1.end.line == 1
arg1.end.column one of { 0, 5, 11 }
arg1.end.offset one of { 0, 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.semanticReduce(fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 has only one value
arg0.symbols has only one value
arg0.symbols[] contains no nulls and has only one value, of length 3
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols.getClass().getName() == java.util.ArrayList.class
size(arg0.symbols[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.semanticReduce(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
arg0.symbols == orig(arg0.symbols)
arg0.symbols[] == orig(arg0.symbols[])
arg0.symbols.getClass().getName() == orig(arg0.symbols.getClass().getName())
this.lexer has only one value
this.inputTokens has only one value
this.rangeList has only one value
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0.symbols has only one value
arg0.symbols[] contains no nulls and has only one value, of length 3
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols.getClass().getName() == java.util.ArrayList.class
size(arg0.symbols[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.setInput(java.lang.Object):::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 has only one value
arg0.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.setInput(java.lang.Object):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.rangeList == orig(this.rangeList)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.setLexer(fri.patterns.interpreter.parsergenerator.Lexer):::ENTER
this.lexer == null
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
arg0 has only one value
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.setLexer(fri.patterns.interpreter.parsergenerator.Lexer):::EXIT
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.rangeList == orig(this.rangeList)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.shift(fri.patterns.interpreter.parsergenerator.Token):::ENTER
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg0.symbol.toString one of { "\"Hello\"", "\"World\"" }
arg0.text.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.shift(fri.patterns.interpreter.parsergenerator.Token):::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.rangeList == orig(this.rangeList)
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg0.symbol == orig(arg0.symbol)
arg0.symbol.toString == orig(arg0.symbol.toString)
arg0.text == orig(arg0.text)
arg0.text.getClass().getName() == orig(arg0.text.getClass().getName())
arg0.range == orig(arg0.range)
arg0.range.start == orig(arg0.range.start)
arg0.range.end == orig(arg0.range.end)
this.lexer has only one value
this.inputTokens == null
this.rangeList == null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg0.symbol.toString one of { "\"Hello\"", "\"World\"" }
arg0.text.getClass().getName() == java.lang.String.class
return.symbol.toString one of { "\"EoI\"", "\"World\"" }
return.text.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.top():::ENTER
this.lexer has only one value
this.lexer != null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Parser.top():::EXIT
this.lexer == orig(this.lexer)
this.lexer.getClass().getName() == orig(this.lexer.getClass().getName())
this.tables == orig(this.tables)
this.tables.getClass().getName() == orig(this.tables.getClass().getName())
this.semantic == orig(this.semantic)
this.stateStack == orig(this.stateStack)
this.valueStack == orig(this.valueStack)
this.rangeStack == orig(this.rangeStack)
this.result == orig(this.result)
this.inputTokens == orig(this.inputTokens)
this.inputTokens[] == orig(this.inputTokens[])
this.inputTokens.getClass().getName() == orig(this.inputTokens.getClass().getName())
this.rangeList == orig(this.rangeList)
this.rangeList[] == orig(this.rangeList[])
this.rangeList.getClass().getName() == orig(this.rangeList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.out == orig(this.out)
this.passExpectedToLexer == orig(this.passExpectedToLexer)
this.DEBUG == orig(this.DEBUG)
this.lexer has only one value
this.lexer != null
this.range has only one value
this.range.start has only one value
this.range.end has only one value
return != null
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Address:::OBJECT
this.line == 1
this.column >= 0
this.offset >= 0
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Address.Address():::EXIT
this.column == 0
this.offset == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Address.Address(int, int, int):::ENTER
arg0 == 1
arg1 >= 0
arg2 >= 0
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Address.Address(int, int, int):::EXIT
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Range:::OBJECT
this.start != null
this.start.line == 1
this.start.column >= 0
this.start.offset >= 0
this.end != null
this.end.line == 1
this.end.column >= 0
this.end.offset >= 0
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Range.Range(fri.patterns.interpreter.parsergenerator.Token$Address, fri.patterns.interpreter.parsergenerator.Token$Address):::ENTER
arg0.line == 1
arg1.line == 1
arg1.column one of { 5, 6, 11 }
arg1.offset one of { 5, 6, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token$Range.Range(fri.patterns.interpreter.parsergenerator.Token$Address, fri.patterns.interpreter.parsergenerator.Token$Address):::EXIT
arg0.line == orig(arg0.line)
arg0.column == orig(arg0.column)
arg0.offset == orig(arg0.offset)
arg1.line == orig(arg1.line)
arg1.column == orig(arg1.column)
arg1.offset == orig(arg1.offset)
arg0.line == 1
arg1.line == 1
arg1.column one of { 5, 6, 11 }
arg1.offset one of { 5, 6, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token:::CLASS
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON != null
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO != null
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT != null
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN != null
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED != null
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER != null
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
===========================================================================
fri.patterns.interpreter.parsergenerator.Token:::OBJECT
this.range.start.line == this.range.end.line
this.range.start.column == this.range.start.offset
this.range.end.column == this.range.end.offset
this.symbol.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
this.text.getClass().getName() == java.lang.String.class
this.range.start.line == 1
this.range.start.column one of { 0, 6, 11 }
this.range.end.column one of { 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.Token(java.lang.String, java.lang.Object, fri.patterns.interpreter.parsergenerator.Token$Range):::ENTER
arg2.start.line == arg2.end.line
arg2.start.column == arg2.start.offset
arg2.end.column == arg2.end.offset
arg0.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
arg1.getClass().getName() == java.lang.String.class
arg2.start.line == 1
arg2.start.column one of { 0, 6, 11 }
arg2.end.column one of { 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.Token(java.lang.String, java.lang.Object, fri.patterns.interpreter.parsergenerator.Token$Range):::EXIT
this.symbol == orig(arg0)
this.text == orig(arg1)
this.text.getClass().getName() == orig(arg1.getClass().getName())
this.range == orig(arg2)
this.range.start == arg2.start
this.range.start.line == arg2.start.line
this.range.start.column == arg2.start.column
this.range.start.offset == arg2.start.column
this.range.end == arg2.end
this.range.end.line == arg2.start.line
this.range.end.column == arg2.end.column
this.range.end.offset == arg2.end.column
arg0.toString == orig(arg0.toString)
arg2.start == orig(arg2.start)
arg2.start.line == arg2.end.line
arg2.start.line == orig(arg2.start.line)
arg2.start.line == orig(arg2.end.line)
arg2.start.column == arg2.start.offset
arg2.start.column == orig(arg2.start.column)
arg2.start.column == orig(arg2.start.offset)
arg2.end == orig(arg2.end)
arg2.end.column == arg2.end.offset
arg2.end.column == orig(arg2.end.column)
arg2.end.column == orig(arg2.end.offset)
arg0.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
arg2.start.line == 1
arg2.start.column one of { 0, 6, 11 }
arg2.end.column one of { 5, 11 }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(fri.patterns.interpreter.parsergenerator.Token):::ENTER
fri.patterns.interpreter.parsergenerator.Token.EPSILON == arg0.symbol
arg0.range.start == arg0.range.end
arg0 has only one value
arg0.symbol.toString == "\"EoI\""
arg0.text == null
arg0.range has only one value
arg0.range.start has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(fri.patterns.interpreter.parsergenerator.Token):::EXIT
fri.patterns.interpreter.parsergenerator.Token.EPSILON == arg0.symbol
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(arg0.symbol)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg0.symbol.toString == orig(arg0.symbol.toString)
arg0.text == orig(arg0.text)
arg0.range == orig(arg0.range)
arg0.range.start == arg0.range.end
arg0.range.start == orig(arg0.range.start)
arg0.range.start == orig(arg0.range.end)
arg0.symbol.toString == "\"EoI\""
arg0.text == null
arg0.range has only one value
arg0.range.start has only one value
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(fri.patterns.interpreter.parsergenerator.Token):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(java.lang.String):::ENTER
arg0.toString one of { "\"EoI\"", "Start" }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg0.toString == orig(arg0.toString)
(arg0.toString == "Start")  <==>  (return == false)
(arg0.toString == "\"EoI\"")  <==>  (return == true)
(arg0.toString == "\"EoI\"")  ==>  (fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(arg0))
arg0.toString one of { "\"EoI\"", "Start" }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(java.lang.String):::EXIT;condition="return == true"
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(arg0)
arg0.toString == "\"EoI\""
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isEpsilon(java.lang.String):::EXIT;condition="not(return == true)"
arg0.toString == "Start"
return == false
orig(arg0) has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isTerminal(java.lang.String):::ENTER
arg0 != null
arg0.toString one of { "\"Hello\"", "\"World\"", "Start" }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isTerminal(java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg0.toString == orig(arg0.toString)
(arg0.toString == "Start")  <==>  (return == false)
(arg0.toString == "Start")  ==>  (orig(arg0) has only one value)
(arg0.toString one of { "\"Hello\"", "\"World\"" })  <==>  (return == true)
arg0.toString one of { "\"Hello\"", "\"World\"", "Start" }
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isTerminal(java.lang.String):::EXIT;condition="return == true"
arg0.toString one of { "\"Hello\"", "\"World\"" }
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.Token.isTerminal(java.lang.String):::EXIT;condition="not(return == true)"
arg0.toString == "Start"
return == false
orig(arg0) has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer:::OBJECT
this.separation.tokenSymbols.getClass().getName() == this.separation.ignoredSymbols.getClass().getName()
this.separation.tokenSymbols.getClass().getName() == this.separation.parserSyntax.rules.getClass().getName()
this.separation.tokenSymbols.getClass().getName() == this.separation.lexerSyntax.rules.getClass().getName()
this has only one value
this.separation.tokenSymbols has only one value
this.separation.tokenSymbols[] == []
this.separation.tokenSymbols[].getClass().getName() == []
this.separation.tokenSymbols.getClass().getName() == java.util.ArrayList.class
this.separation.ignoredSymbols has only one value
this.separation.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.separation.ignoredSymbols[] elements has only one value
this.separation.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.separation.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.separation.parserSyntax has only one value
this.separation.parserSyntax.rules has only one value
this.separation.parserSyntax.rules[] contains no nulls and has only one value, of length 1
this.separation.parserSyntax.rules[] elements has only one value
this.separation.parserSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.separation.parserSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.separation.parserSyntax.ruleHash has only one value
this.separation.lexerSyntax has only one value
this.separation.lexerSyntax.rules has only one value
this.separation.lexerSyntax.rules[] == []
this.separation.lexerSyntax.rules[].getClass().getName() == []
this.separation.lexerSyntax.ruleHash has only one value
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == true
size(this.separation.ignoredSymbols[]) == 1
size(this.separation.parserSyntax.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.SerializedLexer():::EXIT
this.separation == null
this.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.SerializedLexer(boolean):::ENTER
arg0 == true
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.SerializedLexer(boolean):::EXIT
this.PRODUCTION == orig(arg0)
this.separation == null
this.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.buildAndStoreLexer(java.lang.Object, java.lang.String, java.util.List, java.util.List):::ENTER
this.separation == null
this.PRODUCTION == false
arg0 has only one value
arg0.getClass().getName() == java.lang.String[][].class
arg1 == null
arg2 == null
arg3 == null
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.buildAndStoreLexer(java.lang.Object, java.lang.String, java.util.List, java.util.List):::EXIT
this.PRODUCTION == orig(this.PRODUCTION)
this.separation has only one value
this.PRODUCTION == false
return has only one value
return.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.getSyntaxSeparation():::ENTER
this.separation has only one value
this.PRODUCTION == false
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.getSyntaxSeparation():::EXIT
this.separation == return
this.separation.tokenSymbols == return.tokenSymbols
this.separation.tokenSymbols[] == orig(this.separation.tokenSymbols[])
this.separation.tokenSymbols.getClass().getName() == return.tokenSymbols.getClass().getName()
this.separation.ignoredSymbols == return.ignoredSymbols
this.separation.ignoredSymbols[] == orig(this.separation.ignoredSymbols[])
this.separation.ignoredSymbols.getClass().getName() == return.tokenSymbols.getClass().getName()
this.separation.parserSyntax == return.parserSyntax
this.separation.parserSyntax.rules == return.parserSyntax.rules
this.separation.parserSyntax.rules[] == orig(this.separation.parserSyntax.rules[])
this.separation.parserSyntax.rules.getClass().getName() == return.tokenSymbols.getClass().getName()
this.separation.parserSyntax.ruleHash == return.parserSyntax.ruleHash
this.separation.lexerSyntax == return.lexerSyntax
this.separation.lexerSyntax.rules == return.lexerSyntax.rules
this.separation.lexerSyntax.rules[] == orig(this.separation.lexerSyntax.rules[])
this.separation.lexerSyntax.rules.getClass().getName() == return.tokenSymbols.getClass().getName()
this.separation.lexerSyntax.ruleHash == return.lexerSyntax.ruleHash
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
this.PRODUCTION == orig(this.PRODUCTION)
return == orig(this.separation)
return.tokenSymbols == orig(this.separation.tokenSymbols)
return.tokenSymbols.getClass().getName() == return.ignoredSymbols.getClass().getName()
return.tokenSymbols.getClass().getName() == return.parserSyntax.rules.getClass().getName()
return.tokenSymbols.getClass().getName() == return.lexerSyntax.rules.getClass().getName()
return.tokenSymbols.getClass().getName() == orig(this.separation.tokenSymbols.getClass().getName())
return.tokenSymbols.getClass().getName() == orig(this.separation.ignoredSymbols.getClass().getName())
return.tokenSymbols.getClass().getName() == orig(this.separation.parserSyntax.rules.getClass().getName())
return.tokenSymbols.getClass().getName() == orig(this.separation.lexerSyntax.rules.getClass().getName())
return.ignoredSymbols == orig(this.separation.ignoredSymbols)
return.parserSyntax == orig(this.separation.parserSyntax)
return.parserSyntax.rules == orig(this.separation.parserSyntax.rules)
return.parserSyntax.ruleHash == orig(this.separation.parserSyntax.ruleHash)
return.lexerSyntax == orig(this.separation.lexerSyntax)
return.lexerSyntax.rules == orig(this.separation.lexerSyntax.rules)
return.lexerSyntax.ruleHash == orig(this.separation.lexerSyntax.ruleHash)
this.PRODUCTION == false
return has only one value
return.tokenSymbols has only one value
return.tokenSymbols[] == []
return.tokenSymbols[].getClass().getName() == []
return.tokenSymbols.getClass().getName() == java.util.ArrayList.class
return.ignoredSymbols has only one value
return.ignoredSymbols[] contains no nulls and has only one value, of length 1
return.ignoredSymbols[] elements has only one value
return.ignoredSymbols[].getClass().getName() == [java.lang.String]
return.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
return.parserSyntax has only one value
return.parserSyntax.rules has only one value
return.parserSyntax.rules[] contains no nulls and has only one value, of length 1
return.parserSyntax.rules[] elements has only one value
return.parserSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.parserSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.parserSyntax.ruleHash has only one value
return.lexerSyntax has only one value
return.lexerSyntax.rules has only one value
return.lexerSyntax.rules[] == []
return.lexerSyntax.rules[].getClass().getName() == []
return.lexerSyntax.ruleHash has only one value
size(return.ignoredSymbols[]) == 1
size(return.parserSyntax.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.newSyntaxSeparation(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
this.separation == null
this.PRODUCTION == false
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedLexer.newSyntaxSeparation(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
this.separation == orig(this.separation)
this.PRODUCTION == orig(this.PRODUCTION)
arg0.rules == return.parserSyntax.rules
arg0.rules == orig(arg0.rules)
arg0.ruleHash == return.parserSyntax.ruleHash
arg0.ruleHash == orig(arg0.ruleHash)
return.parserSyntax == orig(arg0)
size(arg0.rules[]) == orig(size(arg0.rules[]))-1
this.separation == null
this.PRODUCTION == false
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
return has only one value
return.tokenSymbols has only one value
return.tokenSymbols[] == []
return.tokenSymbols[].getClass().getName() == []
return.ignoredSymbols has only one value
return.ignoredSymbols[] contains no nulls and has only one value, of length 1
return.ignoredSymbols[] elements has only one value
return.ignoredSymbols[].getClass().getName() == [java.lang.String]
return.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
return.parserSyntax has only one value
return.parserSyntax.rules[] contains no nulls and has only one value, of length 1
return.parserSyntax.rules[] elements has only one value
return.parserSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.parserSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.lexerSyntax has only one value
return.lexerSyntax.rules has only one value
return.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
return.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.lexerSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.lexerSyntax.ruleHash has only one value
size(return.ignoredSymbols[]) == 1
size(return.parserSyntax.rules[]) == 1
size(return.lexerSyntax.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject:::OBJECT
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.SerializedObject():::EXIT
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.baseNameFromSyntax(java.lang.Object):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String[][].class
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.baseNameFromSyntax(java.lang.Object):::EXIT
return has only one value
return.toString == "Unknown"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.ensureDirectory(java.lang.String):::ENTER
this has only one value
arg0 has only one value
arg0.toString == "/home/nima/.friware/parsers/UnknownParser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.ensureDirectory(java.lang.String):::EXIT
arg0.toString == orig(arg0.toString)
arg0.toString == "/home/nima/.friware/parsers/UnknownParser.ser"
return has only one value
return.toString == "/home/nima/.friware/parsers"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.makeFilePath(java.lang.String):::ENTER
this has only one value
arg0.toString == "UnknownParser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.makeFilePath(java.lang.String):::EXIT
arg0.toString == orig(arg0.toString)
arg0.toString == "UnknownParser.ser"
return.toString == "/home/nima/.friware/parsers/UnknownParser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.read(java.lang.String):::ENTER
this has only one value
arg0 has only one value
arg0.toString == "UnknownParser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.read(java.lang.String):::EXIT36
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.read(java.lang.String):::EXIT
return == null
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.toSyntax(java.lang.Object):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String[][].class
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.toSyntax(java.lang.Object):::EXIT
return has only one value
return.rules has only one value
return.rules[] contains no nulls and has only one value, of length 2
return.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.rules.getClass().getName() == java.util.ArrayList.class
return.ruleHash has only one value
size(return.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.write(java.lang.String, java.lang.Object):::ENTER
this has only one value
arg0 has only one value
arg0.toString == "UnknownParser.ser"
arg1 has only one value
arg1.getClass().getName() == fri.patterns.interpreter.parsergenerator.Parser.class
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.write(java.lang.String, java.lang.Object):::EXIT56
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.write(java.lang.String, java.lang.Object):::EXIT56;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.write(java.lang.String, java.lang.Object):::EXIT
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedObject.write(java.lang.String, java.lang.Object):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser:::CLASS
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX != null
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == "Parser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser:::OBJECT
this has only one value
this.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.SerializedParser():::EXIT
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.SerializedParser(boolean):::ENTER
arg0 == true
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.SerializedParser(boolean):::EXIT
this.PRODUCTION == orig(arg0)
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.ensureFileName(java.lang.Object, java.lang.String):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String[][].class
arg1 == null
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.ensureFileName(java.lang.Object, java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
this.PRODUCTION == orig(this.PRODUCTION)
return.toString == "UnknownParser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.get(java.lang.Class, java.lang.Object):::ENTER
arg0 == null
arg1 has only one value
arg1.getClass().getName() == java.lang.String[][].class
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.get(java.lang.Class, java.lang.Object):::EXIT
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
this.PRODUCTION == orig(this.PRODUCTION)
return has only one value
return.lexer has only one value
return.lexer.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
return.tables has only one value
return.tables.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
return.semantic == null
return.stateStack has only one value
return.valueStack has only one value
return.rangeStack has only one value
return.result == null
return.inputTokens == null
return.rangeList == null
return.range has only one value
return.range.start has only one value
return.range.end has only one value
return.out == null
return.passExpectedToLexer == true
return.DEBUG == false
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.get(java.lang.Class, java.lang.Object, java.lang.String):::ENTER
arg0 == null
arg1 has only one value
arg1.getClass().getName() == java.lang.String[][].class
arg2 == null
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.get(java.lang.Class, java.lang.Object, java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
this.PRODUCTION == orig(this.PRODUCTION)
return has only one value
return.lexer has only one value
return.lexer.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
return.tables has only one value
return.tables.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
return.semantic == null
return.stateStack has only one value
return.valueStack has only one value
return.rangeStack has only one value
return.result == null
return.inputTokens == null
return.rangeList == null
return.range has only one value
return.range.start has only one value
return.range.end has only one value
return.out == null
return.passExpectedToLexer == true
return.DEBUG == false
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.get(java.lang.Object):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String[][].class
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.get(java.lang.Object):::EXIT
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
this.PRODUCTION == orig(this.PRODUCTION)
return has only one value
return.lexer has only one value
return.lexer.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
return.tables has only one value
return.tables.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
return.semantic == null
return.stateStack has only one value
return.valueStack has only one value
return.rangeStack has only one value
return.result == null
return.inputTokens == null
return.rangeList == null
return.range has only one value
return.range.start has only one value
return.range.end has only one value
return.out == null
return.passExpectedToLexer == true
return.DEBUG == false
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedTables:::OBJECT
this has only one value
this.PRODUCTION == false
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedTables.SerializedTables(boolean):::ENTER
arg0 == false
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedTables.SerializedTables(boolean):::EXIT
this.PRODUCTION == orig(arg0)
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedTables.buildAndStoreParserTables(java.lang.Class, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.Object, java.lang.String):::ENTER
arg0 == null
arg1 has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 1
arg1.rules[] elements has only one value
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
arg2 has only one value
arg2.getClass().getName() == java.lang.String[][].class
arg3 == null
size(arg1.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.builder.SerializedTables.buildAndStoreParserTables(java.lang.Class, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.Object, java.lang.String):::EXIT
this.PRODUCTION == orig(this.PRODUCTION)
arg1.rules == return.syntax.rules
arg1.rules == orig(arg1.rules)
arg1.rules.getClass().getName() == return.syntax.rules.getClass().getName()
arg1.rules.getClass().getName() == return.gotoTable.getClass().getName()
arg1.rules.getClass().getName() == return.parseTable.getClass().getName()
arg1.rules.getClass().getName() == return.symbols.getClass().getName()
arg1.rules.getClass().getName() == return.terminals.getClass().getName()
arg1.rules.getClass().getName() == return.terminalsWithoutEpsilon.getClass().getName()
arg1.rules.getClass().getName() == return.nonterminals.getClass().getName()
arg1.rules.getClass().getName() == orig(arg1.rules.getClass().getName())
arg1.ruleHash == return.syntax.ruleHash
arg1.ruleHash == orig(arg1.ruleHash)
return.syntax == orig(arg1)
size(arg1.rules[])-1 == orig(size(arg1.rules[]))
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 2
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
return has only one value
return.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
return.syntax has only one value
return.syntax.rules[] contains no nulls and has only one value, of length 2
return.syntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.syntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.gotoTable has only one value
return.gotoTable[] has only one value, of length 4
return.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
return.parseTable has only one value
return.parseTable[] contains no nulls and has only one value, of length 4
return.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
return.parseTable[].getClass().getName() elements == java.util.Hashtable.class
return.symbols has only one value
return.symbols[] contains no nulls and has only one value, of length 4
return.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
return.symbols[].getClass().getName() elements == java.lang.String.class
return.terminals has only one value
return.terminals[] contains no nulls and has only one value, of length 3
return.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
return.terminals[].getClass().getName() elements == java.lang.String.class
return.terminalsWithoutEpsilon has only one value
return.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
return.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
return.terminalsWithoutEpsilon[].getClass().getName() elements == java.lang.String.class
return.nonterminals has only one value
return.nonterminals[] contains no nulls and has only one value, of length 2
return.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
return.nonterminals[].getClass().getName() elements == java.lang.String.class
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == 0
return.f == null
size(arg1.rules[]) == 2
size(return.syntax.rules[]) == 2
size(return.gotoTable[]) == 4
size(return.parseTable[]) == 4
size(return.symbols[]) == 4
size(return.terminals[]) == 3
size(return.terminalsWithoutEpsilon[]) == 2
size(return.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1$1:::CLASS
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == false
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1$1:::OBJECT
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols.getClass().getName() == this.ignoredSymbols.getClass().getName()
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols == this.ignoredSymbols
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols.getClass().getName() == this.ignoredSymbols.getClass().getName()
this has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == "Parser.ser"
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == true
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[] == []
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[].getClass().getName() == []
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[] contains no nulls and has only one value, of length 1
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[] elements has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[].getClass().getName() == [java.lang.String]
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.parserSyntax has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.lexerSyntax has only one value
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == true
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.PRODUCTION == false
this.charConsumers has only one value
this.charConsumers.getClass().getName() == java.util.Hashtable.class
this.ignoredSymbols has only one value
this.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.ignoredSymbols[] elements has only one value
this.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.ignoredSymbols.getClass().getName() == java.util.ArrayList.class
size(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[]) == 1
size(this.ignoredSymbols[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1$1.(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::ENTER
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols.getClass().getName() == arg2.getClass().getName()
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols == arg2
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols.getClass().getName() == arg2.getClass().getName()
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.lexerSyntax == arg1
arg1.rules.getClass().getName() == arg2.getClass().getName()
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == "Parser.ser"
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == true
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[] == []
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[].getClass().getName() == []
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[] contains no nulls and has only one value, of length 1
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[] elements has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[].getClass().getName() == [java.lang.String]
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.parserSyntax has only one value
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == true
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.PRODUCTION == false
arg1 has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 16
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.ruleHash has only one value
arg2 has only one value
arg2[] contains no nulls and has only one value, of length 1
arg2[] elements has only one value
arg2[].getClass().getName() == [java.lang.String]
arg2[].getClass().getName() elements == java.lang.String.class
arg2.getClass().getName() == java.util.ArrayList.class
size(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[]) == 1
size(arg1.rules[]) == 16
size(arg2[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1$1.(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::EXIT
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[] == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[])
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[] == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[])
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.parserSyntax == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.parserSyntax)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.lexerSyntax == orig(arg1)
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.PRODUCTION == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.PRODUCTION)
this.ignoredSymbols == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols)
this.ignoredSymbols == orig(arg2)
this.ignoredSymbols.getClass().getName() == arg1.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.rules.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg2.getClass().getName())
arg1.rules == orig(arg1.rules)
arg1.ruleHash == orig(arg1.ruleHash)
arg2[] == orig(arg2[])
arg1.rules has only one value
arg1.rules[] == []
arg1.rules[].getClass().getName() == []
arg1.ruleHash has only one value
arg2[] contains no nulls and has only one value, of length 1
arg2[] elements has only one value
arg2[].getClass().getName() == [java.lang.String]
arg2[].getClass().getName() elements == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1$1.getLexer():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1$1.getLexer():::EXIT
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[] == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols[])
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[] == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols[])
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.parserSyntax == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.parserSyntax)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.lexerSyntax)
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.PRODUCTION == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.PRODUCTION)
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.ignoredSymbols == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.tokenSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.this.separation.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
return has only one value
return.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1:::OBJECT
this.separation.tokenSymbols.getClass().getName() == this.separation.ignoredSymbols.getClass().getName()
this.separation.tokenSymbols.getClass().getName() == this.separation.parserSyntax.rules.getClass().getName()
this.separation.tokenSymbols.getClass().getName() == this.separation.lexerSyntax.rules.getClass().getName()
this has only one value
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == "Parser.ser"
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == true
this.separation.tokenSymbols has only one value
this.separation.tokenSymbols[] == []
this.separation.tokenSymbols[].getClass().getName() == []
this.separation.tokenSymbols.getClass().getName() == java.util.ArrayList.class
this.separation.ignoredSymbols has only one value
this.separation.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.separation.ignoredSymbols[] elements has only one value
this.separation.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.separation.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.separation.parserSyntax has only one value
this.separation.parserSyntax.rules has only one value
this.separation.parserSyntax.rules[] contains no nulls and has only one value, of length 1
this.separation.parserSyntax.rules[] elements has only one value
this.separation.parserSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.separation.parserSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.separation.parserSyntax.ruleHash has only one value
this.separation.lexerSyntax has only one value
this.separation.lexerSyntax.rules has only one value
this.separation.lexerSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.separation.lexerSyntax.rules[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule] }
this.separation.lexerSyntax.ruleHash has only one value
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == true
size(this.separation.ignoredSymbols[]) == 1
size(this.separation.parserSyntax.rules[]) == 1
size(this.separation.lexerSyntax.rules[]) one of { 0, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1):::ENTER
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == "Parser.ser"
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1):::EXIT
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION)
this.separation == null
this.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.newLexerBuilder(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::ENTER
this.separation.tokenSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.separation.tokenSymbols.getClass().getName() == arg1.getClass().getName()
this.separation.ignoredSymbols == arg1
this.separation.lexerSyntax == arg0
this.separation.lexerSyntax.rules == arg0.rules
this.separation.lexerSyntax.ruleHash == arg0.ruleHash
this.separation has only one value
this.separation.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.separation.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.PRODUCTION == false
arg0.rules[] contains no nulls and has only one value, of length 16
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1[] contains no nulls and has only one value, of length 1
arg1[] elements has only one value
arg1[].getClass().getName() == [java.lang.String]
arg1[].getClass().getName() elements == java.lang.String.class
size(this.separation.lexerSyntax.rules[]) == 16
size(arg0.rules[]) == 16
size(arg1[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1$1.newLexerBuilder(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::EXIT
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION == orig(fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.this.PRODUCTION)
this.separation == orig(this.separation)
this.separation.tokenSymbols == orig(this.separation.tokenSymbols)
this.separation.tokenSymbols[] == orig(this.separation.tokenSymbols[])
this.separation.tokenSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.separation.ignoredSymbols == return.ignoredSymbols
this.separation.ignoredSymbols[] == orig(this.separation.ignoredSymbols[])
this.separation.ignoredSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.separation.parserSyntax == orig(this.separation.parserSyntax)
this.separation.parserSyntax.rules == orig(this.separation.parserSyntax.rules)
this.separation.parserSyntax.rules[] == orig(this.separation.parserSyntax.rules[])
this.separation.parserSyntax.rules.getClass().getName() == arg0.rules.getClass().getName()
this.separation.parserSyntax.ruleHash == orig(this.separation.parserSyntax.ruleHash)
this.separation.lexerSyntax == orig(arg0)
this.separation.lexerSyntax.rules == arg0.rules
this.separation.lexerSyntax.rules.getClass().getName() == arg0.rules.getClass().getName()
this.separation.lexerSyntax.ruleHash == arg0.ruleHash
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
this.PRODUCTION == orig(this.PRODUCTION)
arg0.rules == orig(this.separation.lexerSyntax.rules)
arg0.rules == orig(arg0.rules)
arg0.rules.getClass().getName() == return.ignoredSymbols.getClass().getName()
arg0.rules.getClass().getName() == orig(this.separation.tokenSymbols.getClass().getName())
arg0.rules.getClass().getName() == orig(this.separation.ignoredSymbols.getClass().getName())
arg0.rules.getClass().getName() == orig(this.separation.parserSyntax.rules.getClass().getName())
arg0.rules.getClass().getName() == orig(this.separation.lexerSyntax.rules.getClass().getName())
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.rules.getClass().getName() == orig(arg1.getClass().getName())
arg0.ruleHash == orig(this.separation.lexerSyntax.ruleHash)
arg0.ruleHash == orig(arg0.ruleHash)
arg1[] == orig(arg1[])
return.ignoredSymbols == orig(this.separation.ignoredSymbols)
return.ignoredSymbols == orig(arg1)
this.separation has only one value
this.separation.lexerSyntax.rules[] == []
this.separation.lexerSyntax.rules[].getClass().getName() == []
this.PRODUCTION == false
arg0.rules has only one value
arg0.rules[] == []
arg0.rules[].getClass().getName() == []
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1[] contains no nulls and has only one value, of length 1
arg1[] elements has only one value
arg1[].getClass().getName() == [java.lang.String]
arg1[].getClass().getName() elements == java.lang.String.class
return has only one value
return.charConsumers has only one value
return.charConsumers.getClass().getName() == java.util.Hashtable.class
return.ignoredSymbols has only one value
return.ignoredSymbols[] contains no nulls and has only one value, of length 1
return.ignoredSymbols[] elements has only one value
return.ignoredSymbols[].getClass().getName() == [java.lang.String]
return.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == false
orig(arg0) has only one value
size(return.ignoredSymbols[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1:::CLASS
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX has only one value
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == "Parser.ser"
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1:::OBJECT
this has only one value
this.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.():::EXIT
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.newSerializedLexer():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1.newSerializedLexer():::EXIT
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX)
fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString == orig(fri.patterns.interpreter.parsergenerator.builder.SerializedParser.PARSERFILE_SUFFIX.toString)
this.PRODUCTION == orig(this.PRODUCTION)
return has only one value
return.separation == null
return.PRODUCTION == true
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer:::OBJECT
this.strategy.itemsWithoutStartChar.getClass().getName() == this.ignoredSymbols.getClass().getName()
this.strategy.itemsWithoutStartChar.getClass().getName() == this.input.lineLengths.getClass().getName()
this.ignoredSymbols.getClass().getName() == this.input.lineLengths.getClass().getName()
this.input.column == this.input.readOffset
this.input.line[this.input.column] == this.input.buffer[this.input.column]
this.input.line[this.input.column] == this.input.buffer[this.input.column-1]
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset]
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset-1]
this.input.line[this.input.column-1] == this.input.buffer[this.input.readPos]
this.input.line[this.input.readPos] == this.input.line[this.input.readLen-1]
this.input.line[this.input.readLen] == this.input.buffer[this.input.readLen]
this.input.line[this.input.readOffset-1] == this.input.buffer[this.input.readPos]
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen-1]
this has only one value
this.strategy.itemsWithStartChar has only one value
this.strategy.itemsWithoutStartChar has only one value
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[] elements has only one value
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.strategy.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
this.strategy.itemsWithoutStartChar.getClass().getName() == java.util.ArrayList.class
this.strategy.competitiveGroups has only one value
this.strategy.competeForLongestInput == true
this.ignoredSymbols has only one value
this.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.ignoredSymbols[] elements has only one value
this.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.ignoredSymbols.getClass().getName() == java.util.ArrayList.class
this.charConsumers has only one value
this.charConsumers.getClass().getName() == java.util.Hashtable.class
this.input.line has only one value
this.input.line[] == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.line[] elements >= 0
this.input.prevLine == null
this.input.prevLength == 0
this.input.wasCr == false
this.input.column == 6
this.input.lineLengths has only one value
this.input.lineLengths[] == []
this.input.lineLengths[].getClass().getName() == []
this.input.lineLengths.getClass().getName() == java.util.ArrayList.class
this.input.scanPoint[] == [1, 5]
this.input.scanPoint[] elements one of { 1, 5 }
this.input.inputStream == null
this.input.reader has only one value
this.input.reader.getClass().getName() == java.io.StringReader.class
this.input.buffer has only one value
this.input.buffer[] == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.buffer[] elements >= 0
this.input.readPos == 0
this.input.readLen == 1
this.input.eof == false
this.input.buffering == true
this.listeners == null
this.debug == false
size(this.strategy.itemsWithoutStartChar[]) == 1
size(this.ignoredSymbols[]) == 1
size(this.input.line[]) == 64
size(this.input.scanPoint[]) == 2
size(this.input.buffer[]) == 128
this.input.line[this.input.column] == 0
this.input.line[this.input.readPos] == 72
this.input.line[this.input.readLen] == 101
this.input.buffer[this.input.readPos] == 32
this.strategy.itemsWithoutStartChar.getClass().getName() != this.charConsumers.getClass().getName()
this.ignoredSymbols.getClass().getName() != this.charConsumers.getClass().getName()
this.input.readLen in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.OverrideLexer(java.util.List, java.util.Map):::ENTER
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg1.getClass().getName() == java.util.Hashtable.class
size(arg0[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.OverrideLexer(java.util.List, java.util.Map):::EXIT
this.ignoredSymbols == orig(arg0)
this.ignoredSymbols.getClass().getName() == orig(arg0.getClass().getName())
this.charConsumers == orig(arg1)
this.charConsumers.getClass().getName() == orig(arg1.getClass().getName())
arg0[] == orig(arg0[])
this.strategy has only one value
this.strategy.inited == false
this.input == null
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.newStrategy():::ENTER
this.strategy.inited == true
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.newStrategy():::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.itemsWithoutStartChar.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.strategy.itemsWithoutStartChar.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == return.itemsWithoutStartChar.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.input.line == orig(this.input.line)
this.input.line[] == orig(this.input.line[])
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.column == orig(this.input.column)
this.input.column == orig(this.input.readOffset)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.scanPoint == orig(this.input.scanPoint)
this.input.scanPoint[] == orig(this.input.scanPoint[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.buffer == orig(this.input.buffer)
this.input.buffer[] == orig(this.input.buffer[])
this.input.readPos == orig(this.input.readPos)
this.input.readLen == orig(this.input.readLen)
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)-1])
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)-1]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)-1]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column-1])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset-1])
this.input.line[this.input.readPos] == this.input.line[orig(this.input.readLen)-1]
this.input.line[this.input.readPos] == orig(this.input.line[post(this.input.readLen)-1])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readLen-1])
this.input.line[this.input.readLen] == this.input.buffer[orig(this.input.readLen)]
this.input.line[this.input.readLen] == orig(this.input.buffer[post(this.input.readLen)])
this.input.line[this.input.readLen] == orig(this.input.buffer[this.input.readLen])
this.input.line[orig(this.input.column)-1] == this.input.buffer[this.input.readPos]
this.input.line[orig(this.input.readOffset)-1] == this.input.buffer[this.input.readPos]
orig(this.input.line[post(this.input.column)-1]) == this.input.buffer[this.input.readPos]
this.input.buffer[this.input.readPos] == this.input.buffer[orig(this.input.readLen)-1]
this.input.buffer[this.input.readPos] == orig(this.input.buffer[post(this.input.readLen)-1])
this.input.buffer[this.input.readPos] == orig(this.input.line[post(this.input.readOffset)-1])
this.input.buffer[this.input.readPos] == orig(this.input.line[this.input.column-1])
this.input.buffer[this.input.readPos] == orig(this.input.line[this.input.readOffset-1])
this.input.buffer[this.input.readPos] == orig(this.input.buffer[this.input.readLen-1])
this.strategy.inited == true
return.inited == false
return.itemsWithoutStartChar[] == []
return.itemsWithoutStartChar[].getClass().getName() == []
return.competeForLongestInput == true
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl.main(java.lang.String[]):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String[].class
arg0[] == []
arg0[].toString == []
===========================================================================
fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl.main(java.lang.String[]):::EXIT
arg0[] == orig(arg0[])
arg0[] == []
arg0[].toString == []
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer$Reference:::OBJECT
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer$Reference.Reference(java.lang.String):::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer$Reference.Reference(java.lang.String):::EXIT
this.nonterminal == orig(arg0)
arg0.toString == orig(arg0.toString)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer:::OBJECT
this.sequence.getClass().getName() == this.rule.symbols.getClass().getName()
this.sequence != null
this.sequence[] elements != null
this.sequence.getClass().getName() == java.util.ArrayList.class
this.constraints == null
this.nullable == false
this.rule.symbols != null
this.rule.symbols[] elements != null
this.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.fixedLength == -1
this.startLength one of { -1, 1, 2 }
this.startLength != 0
this.variance one of { -1, 1, 3 }
this.variance != 0
size(this.sequence[]) one of { 0, 1, 2 }
size(this.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.Consumer():::EXIT
this.sequence[] == []
this.sequence[].getClass().getName() == []
this.repeatable == false
this.rule == null
this.startLength == -1
this.variance == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.Consumer(fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
arg0 != null
arg0.symbols != null
arg0.symbols[] elements != null
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.symbols.getClass().getName() == java.util.ArrayList.class
size(arg0.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.Consumer(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.sequence.getClass().getName() == arg0.symbols.getClass().getName()
this.sequence.getClass().getName() == orig(arg0.symbols.getClass().getName())
this.rule == orig(arg0)
this.rule.symbols == arg0.symbols
arg0.symbols == orig(arg0.symbols)
arg0.symbols[] == orig(arg0.symbols[])
this.sequence[] == []
this.sequence[].getClass().getName() == []
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
arg0.symbols != null
arg0.symbols[] elements != null
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(arg0.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.Consumer(java.lang.String):::ENTER
arg0.toString one of { "Hello", "World" }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.Consumer(java.lang.String):::EXIT
arg0.toString == orig(arg0.toString)
this.sequence[].getClass().getName() == [java.lang.String]
this.sequence[].getClass().getName() elements == java.lang.String.class
this.repeatable == false
this.rule == null
this.startLength == -1
this.variance == -1
arg0.toString one of { "Hello", "World" }
size(this.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.append(fri.patterns.interpreter.parsergenerator.lexer.Consumer$Reference):::ENTER
this.sequence[] elements has only one value
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference.class
this.sequence[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference] }
this.repeatable == false
this.rule == null
this.startLength == -1
this.variance == -1
size(this.sequence[]) one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.append(fri.patterns.interpreter.parsergenerator.lexer.Consumer$Reference):::EXIT
this.sequence == orig(this.sequence)
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.nonterminal == orig(arg0.nonterminal)
arg0.nonterminal.toString == orig(arg0.nonterminal.toString)
size(this.sequence[])-1 == orig(size(this.sequence[]))
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference.class
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference], [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference, fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference] }
this.repeatable == false
this.rule == null
this.startLength == -1
this.variance == -1
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.append(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.sequence.getClass().getName() == arg0.sequence.getClass().getName()
this.sequence[] == []
this.sequence[].getClass().getName() == []
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
arg0 != null
arg0.sequence != null
arg0.sequence[] == []
arg0.sequence[].getClass().getName() == []
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule == null
arg0.fixedLength == -1
arg0.startLength == -1
arg0.variance == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.append(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.sequence == orig(this.sequence)
this.sequence.getClass().getName() == arg0.sequence.getClass().getName()
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequence.getClass().getName() == orig(arg0.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.sequence == orig(arg0.sequence)
arg0.sequence[] == orig(arg0.sequence[])
arg0.constraints == orig(arg0.constraints)
arg0.nullable == orig(arg0.nullable)
arg0.repeatable == orig(arg0.repeatable)
arg0.rule == orig(arg0.rule)
arg0.fixedLength == orig(arg0.fixedLength)
arg0.startLength == orig(arg0.startLength)
arg0.variance == orig(arg0.variance)
size(this.sequence[])-1 == orig(size(this.sequence[]))
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
arg0.sequence != null
arg0.sequence[] == []
arg0.sequence[].getClass().getName() == []
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule == null
arg0.fixedLength == -1
arg0.startLength == -1
arg0.variance == -1
size(this.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.append(java.lang.String):::ENTER
this.sequence[] == []
this.sequence[].getClass().getName() == []
this.repeatable == false
this.rule == null
this.startLength == -1
this.variance == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.append(java.lang.String):::EXIT
this.sequence == orig(this.sequence)
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.toString == orig(arg0.toString)
size(this.sequence[])-1 == orig(size(this.sequence[]))
this.sequence[].getClass().getName() == [java.lang.String]
this.sequence[].getClass().getName() elements == java.lang.String.class
this.repeatable == false
this.rule == null
this.startLength == -1
this.variance == -1
size(this.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.compareTo(java.lang.Object):::ENTER
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives] }
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance one of { -1, 1 }
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.compareTo(java.lang.Object):::EXIT170
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.compareTo(java.lang.Object):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == return
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives] }
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.variance one of { 1, 3 }
return == 1
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText):::ENTER
this.sequence.getClass().getName() == arg0.lineLengths.getClass().getName()
arg0.column == arg0.readOffset
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0 has only one value
arg0 != null
arg0.line has only one value
arg0.line != null
arg0.line[] one of { [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.column one of { 1, 6, 7 }
arg0.lineLengths has only one value
arg0.lineLengths != null
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] elements one of { 1, 5, 6 }
arg0.scanPoint[] one of { [1, 5], [1, 6] }
arg0.inputStream == null
arg0.reader has only one value
arg0.reader != null
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer != null
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
arg0.eof == false
arg0.buffering == true
size(this.sequence[]) one of { 0, 1 }
size(this.rule.symbols[]) == 2
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
arg0.line[arg0.column] == 0
arg0.line[arg0.column-1] one of { 32, 72, 87 }
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 0, 101, 108 }
arg0.line[arg0.readLen-1] one of { 72, 101 }
arg0.buffer[arg0.column-1] one of { 0, 72 }
this.sequence.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.column > arg0.readPos
arg0.column >= arg0.readLen
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.readPos <= arg0.readLen
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
arg0.line[arg0.column] < arg0.line[arg0.column-1]
arg0.line[arg0.column] < arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] < arg0.line[arg0.readLen-1]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] < arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.column-1] != arg0.line[arg0.readLen]
arg0.buffer[arg0.column-1] % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.column-1] <= arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] >= arg0.line[arg0.readLen-1]
arg0.line[arg0.readPos] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] != arg0.line[arg0.readLen-1]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readLen]
arg0.buffer[arg0.column-1] % arg0.buffer[arg0.readPos] == 0
arg0.buffer[arg0.column-1] <= arg0.buffer[arg0.readPos]
arg0.buffer[arg0.column-1] != arg0.buffer[arg0.readLen]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == arg0.lineLengths.getClass().getName()
this.sequence.getClass().getName() == return.rule.symbols.getClass().getName()
this.sequence.getClass().getName() == return.sequenceList.getClass().getName()
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(arg0.lineLengths.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == return.rule.symbols
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.line == orig(arg0.line)
arg0.prevLine == orig(arg0.prevLine)
arg0.prevLength == orig(arg0.prevLength)
arg0.wasCr == orig(arg0.wasCr)
arg0.column == arg0.readOffset
arg0.lineLengths == orig(arg0.lineLengths)
arg0.lineLengths[] == orig(arg0.lineLengths[])
arg0.inputStream == orig(arg0.inputStream)
arg0.reader == orig(arg0.reader)
arg0.reader.getClass().getName() == orig(arg0.reader.getClass().getName())
arg0.buffer == orig(arg0.buffer)
arg0.eof == orig(arg0.eof)
arg0.buffering == orig(arg0.buffering)
return.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
size(arg0.line[]) == orig(size(arg0.line[]))
size(arg0.scanPoint[]) == orig(size(arg0.scanPoint[]))
size(arg0.buffer[]) == orig(size(arg0.buffer[]))
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)-1])
arg0.line[arg0.column] == orig(arg0.line[arg0.column])
arg0.line[arg0.column] == orig(arg0.line[arg0.readOffset])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readPos)])
arg0.line[arg0.readLen] == orig(arg0.line[post(arg0.readLen)])
arg0.line[orig(arg0.column)-1] == arg0.buffer[orig(arg0.readLen)-1]
arg0.line[orig(arg0.column)-1] == orig(arg0.line[arg0.column-1])
arg0.line[orig(arg0.column)-1] == orig(arg0.line[arg0.readOffset-1])
arg0.line[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readLen-1])
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readPos])
arg0.line[orig(arg0.readLen)-1] == orig(arg0.line[arg0.readLen-1])
arg0.buffer[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.column-1])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readOffset-1])
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.line has only one value
arg0.line != null
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.lineLengths has only one value
arg0.lineLengths != null
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] one of { [1, 5], [1, 6], [1, 11] }
arg0.scanPoint[] elements >= 1
arg0.scanPoint[] sorted by <
arg0.inputStream == null
arg0.reader has only one value
arg0.reader != null
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer != null
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1, 5 }
arg0.readLen one of { 1, 2, 5 }
arg0.eof == false
arg0.buffering == true
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.sequenceList.getClass().getName() == java.util.ArrayList.class
return.stringResult == null
size(this.sequence[]) one of { 0, 1 }
size(this.rule.symbols[]) == 2
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
arg0.line[arg0.column] == 0
arg0.line[arg0.readLen-1] one of { 72, 101, 111 }
arg0.line[orig(arg0.column)-1] one of { 32, 72, 87 }
arg0.line[orig(arg0.readPos)] one of { 72, 101 }
arg0.line[orig(arg0.readLen)] one of { 101, 108 }
arg0.line[orig(arg0.readLen)-1] one of { 72, 101 }
arg0.buffer[arg0.column-1] one of { 0, 111 }
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 }
arg0.buffer[arg0.readLen] one of { 0, 101, 108 }
arg0.buffer[orig(arg0.column)] one of { 0, 101 }
arg0.buffer[orig(arg0.column)-1] one of { 0, 72 }
arg0.buffer[orig(arg0.readPos)] one of { 32, 72, 87 }
this.sequence.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] >= orig(arg0.line[]) (elementwise)
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
orig(arg0.line[post(arg0.column)-1]) in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.buffer[orig(arg0.column)] in arg0.line[]
arg0.buffer[orig(arg0.column)-1] in arg0.line[]
arg0.buffer[orig(arg0.readPos)] in arg0.line[]
arg0.buffer[orig(arg0.readLen)] in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)]) in arg0.line[]
orig(arg0.line[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.line[arg0.readLen]) in arg0.line[]
orig(arg0.buffer[arg0.readPos]) in arg0.line[]
orig(arg0.buffer[arg0.readLen]) in arg0.line[]
arg0.scanPoint[] elements <= arg0.column
arg0.column >= arg0.readPos
arg0.column >= arg0.readLen
arg0.column >= orig(arg0.column)
arg0.column > orig(arg0.readPos)
arg0.column > orig(arg0.readLen)
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
arg0.scanPoint[] elements > orig(arg0.readPos)
arg0.scanPoint[] elements >= orig(arg0.readLen)
orig(arg0.readLen) in arg0.scanPoint[]
arg0.scanPoint[] elements < size(arg0.line[])-1
arg0.scanPoint[] elements < size(arg0.buffer[])-1
arg0.reader.getClass().getName() != return.sequenceList.getClass().getName()
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.line[orig(arg0.column)] in arg0.buffer[]
orig(arg0.line[post(arg0.column)-1]) in arg0.buffer[]
arg0.readPos <= arg0.readLen
arg0.readPos != orig(arg0.column)
arg0.readPos >= orig(arg0.readPos)
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen != orig(arg0.column)
arg0.readLen > orig(arg0.readPos)
arg0.readLen % orig(arg0.readLen) == 0
arg0.readLen >= orig(arg0.readLen)
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
orig(arg0.line[]) elements >= arg0.line[arg0.column]
arg0.buffer[arg0.readLen] in orig(arg0.line[])
arg0.buffer[orig(arg0.column)-1] in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readPos)]) in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readLen)-1]) in orig(arg0.line[])
orig(arg0.column) < size(arg0.line[])-1
orig(arg0.column) < size(arg0.buffer[])-1
orig(arg0.buffer[]) elements >= arg0.line[arg0.column]
orig(arg0.line[post(arg0.column)-1]) in orig(arg0.buffer[])
orig(arg0.readPos) < size(arg0.line[])-1
orig(arg0.readPos) < size(arg0.buffer[])-1
orig(arg0.readLen) < size(arg0.line[])-1
orig(arg0.readLen) < size(arg0.buffer[])-1
arg0.line[arg0.column] < arg0.line[arg0.column-1]
arg0.line[arg0.column] <= arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] < arg0.line[arg0.readLen-1]
arg0.line[arg0.column] < arg0.line[orig(arg0.column)-1]
arg0.line[arg0.column] < arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.line[orig(arg0.readLen)]
arg0.line[arg0.column] < arg0.line[orig(arg0.readLen)-1]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.column] <= arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readLen)]
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.column] < orig(arg0.buffer[arg0.readPos])
arg0.line[arg0.column] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.column-1] != arg0.line[arg0.readPos]
arg0.line[arg0.column-1] != arg0.line[arg0.readLen]
arg0.line[arg0.column-1] <= arg0.line[arg0.readLen-1]
arg0.line[arg0.column-1] >= arg0.line[orig(arg0.column)-1]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readLen)]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readLen)-1]
arg0.buffer[arg0.column-1] % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] >= arg0.buffer[arg0.column-1]
orig(arg0.line[post(arg0.column)-1]) % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column-1] >= arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.line[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readPos] <= arg0.line[arg0.readLen]
arg0.line[arg0.readPos] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readPos] != arg0.line[orig(arg0.column)-1]
arg0.line[arg0.readPos] <= arg0.line[orig(arg0.readLen)]
arg0.line[arg0.readPos] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readPos] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readPos] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readPos] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readLen] != arg0.line[arg0.readLen-1]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.column)-1]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.readLen)-1]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readLen] != orig(arg0.buffer[arg0.readPos])
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen-1] > arg0.line[orig(arg0.column)-1]
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.readLen)-1]
arg0.buffer[arg0.column-1] % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen-1] > orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.readPos)]
orig(arg0.line[post(arg0.readLen)-1]) % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.readLen-1] >= orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.column)-1]
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.readPos)]
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.column)] != orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.column)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.column)] != orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.column)-1] < arg0.line[orig(arg0.readLen)]
arg0.line[orig(arg0.column)-1] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.column)-1] >= orig(arg0.line[post(arg0.column)-1])
orig(arg0.line[post(arg0.column)-1]) % arg0.line[orig(arg0.column)-1] == 0
arg0.line[orig(arg0.column)-1] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.column)-1] != arg0.buffer[orig(arg0.column)]
arg0.buffer[orig(arg0.column)-1] % arg0.line[orig(arg0.column)-1] == 0
arg0.line[orig(arg0.column)-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.column)-1] <= arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.column)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.column)-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[orig(arg0.column)-1] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.column)-1] <= orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.readPos)] <= arg0.line[orig(arg0.readLen)]
arg0.line[orig(arg0.readPos)] >= arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readPos)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.readPos)] != arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readPos)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readPos)] != arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.readLen)] > arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readLen)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readLen)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readLen)] >= arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[arg0.readLen]) % arg0.line[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readLen)-1] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readLen)-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readLen)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.readLen)-1] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.readLen)-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[orig(arg0.readLen)-1] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.readLen)-1] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)]
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[arg0.readPos])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readPos]
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readLen]
orig(arg0.line[post(arg0.column)-1]) % arg0.buffer[orig(arg0.readPos)] == 0
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[orig(arg0.readPos)]
orig(arg0.line[post(arg0.column)-1]) < arg0.buffer[orig(arg0.readLen)]
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) % orig(arg0.buffer[arg0.readPos]) == 0
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[arg0.readPos])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readPos] <= arg0.buffer[arg0.readLen]
arg0.buffer[arg0.readPos] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readLen] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readLen] != orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[orig(arg0.column)] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.buffer[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] % arg0.buffer[orig(arg0.readPos)] == 0
arg0.buffer[orig(arg0.column)-1] <= arg0.buffer[orig(arg0.readPos)]
arg0.buffer[orig(arg0.column)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] % orig(arg0.buffer[arg0.readPos]) == 0
arg0.buffer[orig(arg0.column)-1] <= orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.readPos)] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.readPos)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.readPos)] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.readPos)] <= orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.readLen)] != orig(arg0.buffer[arg0.readPos])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.line[arg0.readLen])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.readLen)-1]) >= orig(arg0.buffer[post(arg0.readLen)-1])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::ENTER
this.sequence.getClass().getName() == arg0.lineLengths.getClass().getName()
arg0.column == arg0.readOffset
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0 has only one value
arg0.line has only one value
arg0.line[] one of { [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.column one of { 1, 6, 7 }
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] one of { [1, 0], [1, 5], [1, 6] }
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
arg0.eof == false
arg0.buffering == true
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
arg0.line[arg0.column] == 0
arg0.line[arg0.column-1] one of { 32, 72, 87 }
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 0, 101, 108 }
arg0.line[arg0.readLen-1] one of { 72, 101 }
arg0.buffer[arg0.column-1] one of { 0, 72 }
this.sequence.getClass().getName() != arg0.reader.getClass().getName()
this.rule.symbols.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.scanPoint[] elements <= arg0.column
arg0.column > arg0.readPos
arg0.column >= arg0.readLen
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
arg0.scanPoint[] elements >= arg0.readPos
arg0.scanPoint[] elements < size(arg0.line[])-1
arg0.scanPoint[] elements < size(arg0.buffer[])-1
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.readPos <= arg0.readLen
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
arg0.line[arg0.column] < arg0.line[arg0.column-1]
arg0.line[arg0.column] < arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] < arg0.line[arg0.readLen-1]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] < arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.column-1] != arg0.line[arg0.readLen]
arg0.buffer[arg0.column-1] % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.column-1] <= arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] >= arg0.line[arg0.readLen-1]
arg0.line[arg0.readPos] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] != arg0.line[arg0.readLen-1]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readLen]
arg0.buffer[arg0.column-1] % arg0.buffer[arg0.readPos] == 0
arg0.buffer[arg0.column-1] <= arg0.buffer[arg0.readPos]
arg0.buffer[arg0.column-1] != arg0.buffer[arg0.readLen]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT421
arg0.readPos == arg0.readLen
arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readLen)])
arg0.line[orig(arg0.column)-1] == arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.readPos)] == arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readLen-1])
arg0.line[orig(arg0.readOffset)-1] == arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.readPos] == orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readPos] == orig(arg0.buffer[post(arg0.readLen)])
arg0.buffer[orig(arg0.readPos)] == arg0.buffer[orig(arg0.readLen)-1]
arg0.buffer[orig(arg0.readPos)] == orig(arg0.line[arg0.column-1])
arg0.buffer[orig(arg0.readPos)] == orig(arg0.line[arg0.readOffset-1])
arg0.buffer[orig(arg0.readPos)] == orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.readPos)] == orig(arg0.buffer[arg0.readLen-1])
this.startLength one of { -1, 1 }
arg0.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.column one of { 5, 6, 11 }
arg0.buffer[] one of { [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.readPos one of { 1, 5 }
orig(arg0.buffer[]) one of { [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
orig(arg0.readPos) == 0
orig(arg0.readLen) == 1
arg0.line[arg0.column-1] one of { 32, 100, 111 }
arg0.line[arg0.readPos] one of { 0, 32, 101 }
arg0.line[arg0.readPos-1] one of { 72, 111 }
arg0.line[orig(arg0.column)] one of { 0, 101, 111 }
arg0.line[orig(arg0.readPos)] == 72
arg0.line[orig(arg0.readLen)] == 101
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32 }
arg0.buffer[arg0.readPos] one of { 0, 101 }
arg0.buffer[orig(arg0.readLen)] one of { 101, 111 }
orig(arg0.line[post(arg0.readPos)-1]) one of { 0, 72, 111 }
orig(arg0.buffer[post(arg0.readPos)-1]) one of { 0, 32, 111 }
orig(arg0.line[arg0.readLen]) one of { 0, 101 }
orig(arg0.buffer[arg0.readLen]) one of { 0, 87, 101 }
orig(arg0.line[post(arg0.readPos)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)-1]) in arg0.buffer[]
orig(arg0.buffer[arg0.readLen]) in arg0.buffer[]
arg0.buffer[arg0.readPos] in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readPos)-1]) in orig(arg0.line[])
orig(arg0.readLen) in orig(arg0.scanPoint[])
orig(arg0.line[post(arg0.readPos)-1]) % arg0.line[arg0.readPos-1] == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT427
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
arg0.readPos == orig(arg0.readPos)
arg0.line[arg0.column] == arg0.buffer[arg0.column-1]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)-1]
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column-1])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset-1])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.readPos] == orig(arg0.line[arg0.readPos])
arg0.line[arg0.readLen] == arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.line[arg0.readOffset-1] == arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)] == orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.readLen)] == orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readPos] == arg0.buffer[arg0.readLen-1]
orig(arg0.buffer[post(arg0.readLen)-1]) == orig(arg0.buffer[arg0.readPos])
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
this.variance one of { -1, 3 }
arg0.line[] one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.column one of { 6, 7 }
arg0.scanPoint == null
arg0.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
return == null
orig(arg0.line[]) one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
orig(arg0.column) one of { 6, 7 }
orig(arg0.scanPoint[]) elements one of { 1, 5, 6 }
orig(arg0.scanPoint[]) one of { [1, 5], [1, 6] }
orig(arg0.buffer[]) one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 101, 108 }
arg0.line[orig(arg0.column)] one of { 0, 87 }
arg0.line[orig(arg0.column)-1] one of { 32, 87 }
arg0.buffer[arg0.readPos] one of { 32, 87 }
arg0.buffer[orig(arg0.readLen)] one of { 87, 101, 108 }
orig(arg0.buffer[arg0.readPos]) one of { 32, 87, 101 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == arg0.lineLengths.getClass().getName()
this.sequence.getClass().getName() == return.rule.symbols.getClass().getName()
this.sequence.getClass().getName() == return.sequenceList.getClass().getName()
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(arg0.lineLengths.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == return.rule
this.rule == orig(this.rule)
this.rule.symbols == return.rule.symbols
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.line == orig(arg0.line)
arg0.prevLine == orig(arg0.prevLine)
arg0.prevLength == orig(arg0.prevLength)
arg0.wasCr == orig(arg0.wasCr)
arg0.column == arg0.readOffset
arg0.lineLengths == orig(arg0.lineLengths)
arg0.lineLengths[] == orig(arg0.lineLengths[])
arg0.inputStream == orig(arg0.inputStream)
arg0.reader == orig(arg0.reader)
arg0.reader.getClass().getName() == orig(arg0.reader.getClass().getName())
arg0.buffer == orig(arg0.buffer)
arg0.eof == orig(arg0.eof)
arg0.buffering == orig(arg0.buffering)
return.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
size(arg0.line[]) == orig(size(arg0.line[]))
size(arg0.scanPoint[]) == orig(size(arg0.scanPoint[]))
size(arg0.buffer[]) == orig(size(arg0.buffer[]))
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)-1])
arg0.line[arg0.column] == orig(arg0.line[arg0.column])
arg0.line[arg0.column] == orig(arg0.line[arg0.readOffset])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readPos)])
arg0.line[arg0.readLen] == orig(arg0.line[post(arg0.readLen)])
arg0.line[orig(arg0.column)-1] == arg0.buffer[orig(arg0.readLen)-1]
arg0.line[orig(arg0.column)-1] == orig(arg0.line[arg0.column-1])
arg0.line[orig(arg0.column)-1] == orig(arg0.line[arg0.readOffset-1])
arg0.line[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readLen-1])
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readPos])
arg0.line[orig(arg0.readLen)-1] == orig(arg0.line[arg0.readLen-1])
arg0.buffer[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.column-1])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readOffset-1])
(arg0.scanPoint == null)  <==>  (arg0.buffer[arg0.readPos] one of { 32, 87 })
(arg0.scanPoint == null)  <==>  (arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos])
(arg0.scanPoint == null)  <==>  (arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1])
(arg0.scanPoint == null)  <==>  (arg0.readPos == orig(arg0.readPos))
(arg0.scanPoint == null)  <==>  (return == null)
(arg0.scanPoint == null)  ==>  (arg0.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (arg0.buffer[arg0.column-1] == 0)
(arg0.scanPoint == null)  ==>  (arg0.buffer[arg0.readLen] one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.buffer[orig(arg0.column)-1] == 0)
(arg0.scanPoint == null)  ==>  (arg0.buffer[orig(arg0.column)] == 0)
(arg0.scanPoint == null)  ==>  (arg0.buffer[orig(arg0.readLen)] one of { 87, 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.buffer[orig(arg0.readPos)] one of { 32, 87 })
(arg0.scanPoint == null)  ==>  (arg0.column one of { 6, 7 })
(arg0.scanPoint == null)  ==>  (arg0.line[] one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.column-1] one of { 32, 87 })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.column] == arg0.buffer[arg0.column-1])
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)-1])
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)])
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readLen-1] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readLen] == arg0.buffer[arg0.readLen])
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readLen] one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readLen)-1]))
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readPos] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.column)-1] one of { 32, 87 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.column)] one of { 0, 87 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readLen)-1] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readLen)] == orig(arg0.buffer[arg0.readLen]))
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readLen)] == orig(arg0.line[arg0.readLen]))
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readLen)] one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readPos)] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.readLen one of { 1, 2 })
(arg0.scanPoint == null)  ==>  (arg0.readPos one of { 0, 1 })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[]) one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[arg0.readLen]) one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[arg0.readPos]) one of { 32, 87, 101 })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[post(arg0.readLen)-1]) == orig(arg0.buffer[arg0.readPos]))
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[post(arg0.readLen)-1]) one of { 32, 87, 101 })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[post(arg0.readPos)]) one of { 32, 87, 101 })
(arg0.scanPoint == null)  ==>  (orig(arg0.column) one of { 6, 7 })
(arg0.scanPoint == null)  ==>  (orig(arg0.line[]) one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (orig(arg0.line[arg0.readLen]) one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 })
(arg0.scanPoint == null)  ==>  (orig(arg0.line[post(arg0.readLen)-1]) one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (orig(arg0.readLen) one of { 1, 2 })
(arg0.scanPoint == null)  ==>  (orig(arg0.readPos) one of { 0, 1 })
(arg0.scanPoint == null)  ==>  (orig(arg0.scanPoint[]) elements one of { 1, 5, 6 })
(arg0.scanPoint == null)  ==>  (orig(arg0.scanPoint[]) one of { [1, 5], [1, 6] })
(arg0.scanPoint == null)  ==>  (this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives])
(arg0.scanPoint == null)  ==>  (this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class)
(arg0.scanPoint == null)  ==>  (this.startLength one of { -1, 1, 2 })
(arg0.scanPoint == null)  ==>  (this.variance one of { -1, 3 })
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.line has only one value
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] one of { [1, 5], [1, 6], [1, 11] }
arg0.scanPoint[] elements >= 1
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1, 5 }
arg0.readLen one of { 1, 2, 5 }
arg0.eof == false
arg0.buffering == true
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.sequenceList.getClass().getName() == java.util.ArrayList.class
return.stringResult == null
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
arg0.line[arg0.column] == 0
arg0.line[arg0.readLen-1] one of { 72, 101, 111 }
arg0.line[orig(arg0.column)-1] one of { 32, 72, 87 }
arg0.line[orig(arg0.readPos)] one of { 72, 101 }
arg0.line[orig(arg0.readLen)] one of { 101, 108 }
arg0.line[orig(arg0.readLen)-1] one of { 72, 101 }
arg0.buffer[arg0.column-1] one of { 0, 111 }
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 }
arg0.buffer[arg0.readLen] one of { 0, 101, 108 }
arg0.buffer[orig(arg0.column)] one of { 0, 101 }
arg0.buffer[orig(arg0.column)-1] one of { 0, 72 }
arg0.buffer[orig(arg0.readPos)] one of { 32, 72, 87 }
this.sequence.getClass().getName() != arg0.reader.getClass().getName()
this.rule.symbols.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] >= orig(arg0.line[]) (elementwise)
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
orig(arg0.line[post(arg0.column)-1]) in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.buffer[orig(arg0.column)] in arg0.line[]
arg0.buffer[orig(arg0.column)-1] in arg0.line[]
arg0.buffer[orig(arg0.readPos)] in arg0.line[]
arg0.buffer[orig(arg0.readLen)] in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)]) in arg0.line[]
orig(arg0.line[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.line[arg0.readLen]) in arg0.line[]
orig(arg0.buffer[arg0.readPos]) in arg0.line[]
orig(arg0.buffer[arg0.readLen]) in arg0.line[]
arg0.column in arg0.scanPoint[]
arg0.column >= arg0.readPos
arg0.column >= arg0.readLen
arg0.column >= orig(arg0.column)
orig(arg0.scanPoint[]) elements < arg0.column
arg0.column > orig(arg0.readPos)
arg0.column > orig(arg0.readLen)
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
orig(arg0.readLen) in arg0.scanPoint[]
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.line[orig(arg0.column)] in arg0.buffer[]
orig(arg0.line[post(arg0.column)-1]) in arg0.buffer[]
arg0.readPos <= arg0.readLen
arg0.readPos != orig(arg0.column)
arg0.readPos >= orig(arg0.readPos)
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen != orig(arg0.column)
arg0.readLen > orig(arg0.readPos)
arg0.readLen % orig(arg0.readLen) == 0
arg0.readLen >= orig(arg0.readLen)
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
orig(arg0.line[]) elements >= arg0.line[arg0.column]
arg0.buffer[arg0.readLen] in orig(arg0.line[])
arg0.buffer[orig(arg0.column)-1] in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readPos)]) in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readLen)-1]) in orig(arg0.line[])
orig(arg0.column) < size(arg0.line[])-1
orig(arg0.column) < size(arg0.buffer[])-1
orig(arg0.scanPoint[]) elements < size(arg0.line[])-1
orig(arg0.scanPoint[]) elements < size(arg0.buffer[])-1
orig(arg0.buffer[]) elements >= arg0.line[arg0.column]
orig(arg0.line[post(arg0.column)-1]) in orig(arg0.buffer[])
orig(arg0.readPos) < size(arg0.line[])-1
orig(arg0.readPos) < size(arg0.buffer[])-1
orig(arg0.readLen) < size(arg0.line[])-1
orig(arg0.readLen) < size(arg0.buffer[])-1
arg0.line[arg0.column] < arg0.line[arg0.column-1]
arg0.line[arg0.column] <= arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] < arg0.line[arg0.readLen-1]
arg0.line[arg0.column] < arg0.line[orig(arg0.column)-1]
arg0.line[arg0.column] < arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.line[orig(arg0.readLen)]
arg0.line[arg0.column] < arg0.line[orig(arg0.readLen)-1]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.column] <= arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readLen)]
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.column] < orig(arg0.buffer[arg0.readPos])
arg0.line[arg0.column] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.column-1] != arg0.line[arg0.readPos]
arg0.line[arg0.column-1] != arg0.line[arg0.readLen]
arg0.line[arg0.column-1] <= arg0.line[arg0.readLen-1]
arg0.line[arg0.column-1] >= arg0.line[orig(arg0.column)-1]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readLen)]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readLen)-1]
arg0.buffer[arg0.column-1] % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] >= arg0.buffer[arg0.column-1]
orig(arg0.line[post(arg0.column)-1]) % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column-1] >= arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.line[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readPos] <= arg0.line[arg0.readLen]
arg0.line[arg0.readPos] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readPos] != arg0.line[orig(arg0.column)-1]
arg0.line[arg0.readPos] <= arg0.line[orig(arg0.readLen)]
arg0.line[arg0.readPos] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readPos] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readPos] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readPos] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readLen] != arg0.line[arg0.readLen-1]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.column)-1]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.readLen)-1]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readLen] != orig(arg0.buffer[arg0.readPos])
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen-1] > arg0.line[orig(arg0.column)-1]
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.readLen)-1]
arg0.buffer[arg0.column-1] % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen-1] > orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.readPos)]
orig(arg0.line[post(arg0.readLen)-1]) % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.readLen-1] >= orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.column)-1]
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.readPos)]
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.column)] != orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.column)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.column)] != orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.column)-1] < arg0.line[orig(arg0.readLen)]
arg0.line[orig(arg0.column)-1] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.column)-1] >= orig(arg0.line[post(arg0.column)-1])
orig(arg0.line[post(arg0.column)-1]) % arg0.line[orig(arg0.column)-1] == 0
arg0.line[orig(arg0.column)-1] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.column)-1] != arg0.buffer[orig(arg0.column)]
arg0.buffer[orig(arg0.column)-1] % arg0.line[orig(arg0.column)-1] == 0
arg0.line[orig(arg0.column)-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.column)-1] <= arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.column)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.column)-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[orig(arg0.column)-1] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.column)-1] <= orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.readPos)] <= arg0.line[orig(arg0.readLen)]
arg0.line[orig(arg0.readPos)] >= arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readPos)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.readPos)] != arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readPos)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readPos)] != arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.readLen)] > arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readLen)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readLen)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readLen)] >= arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[arg0.readLen]) % arg0.line[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[arg0.readPos])
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readLen)-1] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.readLen)-1] != arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readLen)-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readLen)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.readLen)-1] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.readLen)-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[orig(arg0.readLen)-1] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.readLen)-1] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)]
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[arg0.readPos])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readPos]
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readLen]
orig(arg0.line[post(arg0.column)-1]) % arg0.buffer[orig(arg0.readPos)] == 0
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[orig(arg0.readPos)]
orig(arg0.line[post(arg0.column)-1]) < arg0.buffer[orig(arg0.readLen)]
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) % orig(arg0.buffer[arg0.readPos]) == 0
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[arg0.readPos])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readPos] <= arg0.buffer[arg0.readLen]
arg0.buffer[arg0.readPos] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readLen] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readLen] != orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[orig(arg0.column)] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.buffer[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] % arg0.buffer[orig(arg0.readPos)] == 0
arg0.buffer[orig(arg0.column)-1] <= arg0.buffer[orig(arg0.readPos)]
arg0.buffer[orig(arg0.column)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] % orig(arg0.buffer[arg0.readPos]) == 0
arg0.buffer[orig(arg0.column)-1] <= orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.readPos)] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.readPos)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.readPos)] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.readPos)] <= orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.readLen)] != orig(arg0.buffer[arg0.readPos])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.line[arg0.readLen])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.readLen)-1]) >= orig(arg0.buffer[post(arg0.readLen)-1])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.ensureResultTree(fri.patterns.interpreter.parsergenerator.lexer.ResultTree):::ENTER
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength one of { -1, 1 }
arg0 == null
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.ensureResultTree(fri.patterns.interpreter.parsergenerator.lexer.ResultTree):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == return.rule
this.rule == orig(this.rule)
this.rule.symbols == return.rule.symbols
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength one of { -1, 1 }
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.sequenceList == null
return.range == null
return.buffer == null
return.stringResult == null
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
size(return.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getAlternatives():::ENTER
this.rule != null
this.startLength == -1
this.variance == -1
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getAlternatives():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.rule != null
this.startLength == -1
this.variance == -1
return == null
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getSomeLength(boolean, java.util.List):::ENTER
this.sequence.getClass().getName() == arg1.getClass().getName()
this.repeatable == false
this.rule != null
this.startLength == -1
arg0 == true
arg1 != null
arg1[] == []
arg1[].getClass().getName() == []
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getSomeLength(boolean, java.util.List):::EXIT269
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getSomeLength(boolean, java.util.List):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequence.getClass().getName() == orig(arg1.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg1[] == orig(arg1[])
this.repeatable == false
this.rule != null
this.startLength == -1
arg1[] == []
arg1[].getClass().getName() == []
return one of { 1, 2 }
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartCharacter():::ENTER
this.startLength == -1
this.variance one of { -1, 1 }
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartCharacter():::EXIT182
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.rule != null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartCharacter():::EXIT187
this.sequence[].getClass().getName() == [java.lang.String]
this.sequence[].getClass().getName() elements == java.lang.String.class
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return != null
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartCharacter():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.startLength == -1
this.variance one of { -1, 1 }
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartLength():::ENTER
this.repeatable == false
this.startLength == -1
this.variance one of { 1, 3 }
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartLength():::EXIT230
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartLength():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == return
this.variance == orig(this.variance)
this.repeatable == false
this.variance one of { 1, 3 }
return one of { 1, 2 }
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartVariance():::ENTER
this.repeatable == false
this.startLength == -1
this.variance one of { -1, 1 }
size(this.sequence[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartVariance():::EXIT194
return == orig(this.variance)
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
this.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
return == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartVariance():::EXIT197
return == 1
orig(this.variance) == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartVariance():::EXIT212
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return == 3
orig(this.variance) == -1
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.getStartVariance():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == return
this.repeatable == false
this.startLength == -1
return one of { 1, 3 }
size(this.sequence[]) one of { 1, 2 }
return >= orig(this.variance)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isNullable():::ENTER
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.variance one of { -1, 3 }
size(this.sequence[]) one of { 0, 1 }
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isNullable():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == return
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
return == orig(this.nullable)
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.variance one of { -1, 3 }
return == false
size(this.sequence[]) one of { 0, 1 }
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isNullable():::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isRepeatable():::ENTER
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
size(this.sequence[]) one of { 0, 1 }
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isRepeatable():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == return
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
return == orig(this.repeatable)
(return == false)  ==>  (size(this.sequence[]) one of { 0, 1 })
(return == false)  ==>  (this.startLength one of { -1, 1, 2 })
(return == false)  ==>  (this.variance one of { -1, 1, 3 })
(return == true)  ==>  (orig(this) has only one value)
(return == true)  ==>  (size(this.sequence[]) == 1)
(return == true)  ==>  (this.rule has only one value)
(return == true)  ==>  (this.rule.symbols has only one value)
(return == true)  ==>  (this.rule.symbols[] contains no nulls and has only one value, of length 2)
(return == true)  ==>  (this.sequence has only one value)
(return == true)  ==>  (this.sequence[] contains no nulls and has only one value, of length 1)
(return == true)  ==>  (this.sequence[] elements has only one value)
(return == true)  ==>  (this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives])
(return == true)  ==>  (this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class)
(return == true)  ==>  (this.startLength == -1)
(return == true)  ==>  (this.variance == -1)
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
size(this.sequence[]) one of { 0, 1 }
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isRepeatable():::EXIT;condition="return == true"
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequence has only one value
this.sequence[] contains no nulls and has only one value, of length 1
this.sequence[] elements has only one value
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.startLength == -1
this.variance == -1
return == true
orig(this) has only one value
size(this.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.isRepeatable():::EXIT;condition="not(return == true)"
return == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.matchesRepeatableRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
this.sequence.getClass().getName() == arg0.symbols.getClass().getName()
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference.class
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance == -1
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg0.symbols[].getClass().getName() elements == java.lang.String.class
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
size(arg0.symbols[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.matchesRepeatableRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT295
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.matchesRepeatableRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT295;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.matchesRepeatableRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == arg0.symbols.getClass().getName()
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequence.getClass().getName() == orig(arg0.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.symbols == orig(arg0.symbols)
arg0.symbols[] == orig(arg0.symbols[])
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference.class
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance == -1
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg0.symbols[].getClass().getName() elements == java.lang.String.class
return == true
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
size(arg0.symbols[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.matchesRepeatableRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.optimize():::ENTER
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
size(this.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.optimize():::EXIT280
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.optimize():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == return.sequence.getClass().getName()
this.sequence.getClass().getName() == return.rule.symbols.getClass().getName()
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == return.rule
this.rule == orig(this.rule)
this.rule.symbols == return.rule.symbols
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
return != null
return.sequence != null
return.sequence[] elements != null
return.constraints == null
return.nullable == false
return.repeatable == false
return.rule.symbols[] elements != null
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return.fixedLength == -1
return.startLength == -1
return.variance == -1
size(this.sequence[]) == 1
size(return.sequence[]) one of { 1, 2 }
size(return.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.sequence.getClass().getName() == arg0.sequence.getClass().getName()
this.sequence.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == arg0.rule.symbols.getClass().getName()
arg0 != null
arg0.sequence != null
arg0.sequence[] elements != null
arg0.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
arg0.constraints == null
arg0.nullable == false
arg0.rule.symbols != null
arg0.rule.symbols[] elements != null
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.fixedLength == -1
arg0.startLength one of { -1, 1 }
arg0.startLength != 0
arg0.variance one of { -1, 1, 3 }
arg0.variance != 0
size(this.sequence[]) one of { 1, 2 }
size(arg0.sequence[]) == 1
size(arg0.rule.symbols[]) == 2
this.startLength % arg0.startLength == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT480
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.rule != null
arg0.repeatable == false
arg0.rule.symbols has only one value
arg0.rule.symbols[] contains no nulls and has only one value, of length 2
arg0.variance one of { -1, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT480;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT489
this.sequence.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
this.sequence[].getClass().getName() == [java.lang.String]
this.sequence[].getClass().getName() elements == java.lang.String.class
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance == -1
arg0.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
arg0.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
arg0.variance one of { -1, 3 }
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT489;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT507
this.startLength == arg0.startLength
this.startLength == orig(arg0.startLength)
this.sequence[].getClass().getName() == [java.lang.String]
this.sequence[].getClass().getName() elements == java.lang.String.class
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance one of { -1, 1 }
arg0.sequence[].getClass().getName() == [java.lang.String]
arg0.sequence[].getClass().getName() elements == java.lang.String.class
arg0.repeatable == false
arg0.variance one of { -1, 1 }
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
this.variance >= arg0.variance
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT507;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == arg0.sequence.getClass().getName()
this.sequence.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(arg0.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.sequence == orig(arg0.sequence)
arg0.sequence[] == orig(arg0.sequence[])
arg0.constraints == orig(arg0.constraints)
arg0.nullable == orig(arg0.nullable)
arg0.repeatable == orig(arg0.repeatable)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.fixedLength == orig(arg0.fixedLength)
arg0.startLength == orig(arg0.startLength)
arg0.variance == orig(arg0.variance)
arg0.sequence != null
arg0.sequence[] elements != null
arg0.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
arg0.constraints == null
arg0.nullable == false
arg0.rule.symbols != null
arg0.rule.symbols[] elements != null
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.fixedLength == -1
arg0.startLength one of { -1, 1 }
arg0.startLength != 0
arg0.variance one of { -1, 1, 3 }
arg0.variance != 0
return == false
size(this.sequence[]) one of { 1, 2 }
size(arg0.sequence[]) == 1
size(arg0.rule.symbols[]) == 2
this.startLength % arg0.startLength == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.resolveConsumerReferences(java.util.Map, java.util.Map):::ENTER
arg0.getClass().getName() == arg1.getClass().getName()
this.startLength == -1
this.variance == -1
arg0 has only one value
arg0 != null
arg0.getClass().getName() == java.util.Hashtable.class
arg1 has only one value
arg1 != null
this.sequence.getClass().getName() != arg0.getClass().getName()
this.rule.symbols.getClass().getName() != arg0.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.resolveConsumerReferences(java.util.Map, java.util.Map):::EXIT136
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.resolveConsumerReferences(java.util.Map, java.util.Map):::EXIT
this.sequence == orig(this.sequence)
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
size(this.sequence[]) == orig(size(this.sequence[]))
this.startLength == -1
this.variance == -1
this.sequence.getClass().getName() != orig(arg0.getClass().getName())
this.rule.symbols.getClass().getName() != orig(arg0.getClass().getName())
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.setRepeatable():::ENTER
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference.class
this.repeatable == false
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance == -1
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.setRepeatable():::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference]
this.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.Reference.class
this.repeatable == true
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.startLength == -1
this.variance == -1
size(this.sequence[]) == 1
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.setStrategyFactoryMethod(fri.patterns.interpreter.parsergenerator.lexer.StrategyFactoryMethod):::ENTER
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
arg0 has only one value
arg0 != null
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
size(this.sequence[]) one of { 1, 2 }
this.sequence.getClass().getName() != arg0.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Consumer.setStrategyFactoryMethod(fri.patterns.interpreter.parsergenerator.lexer.StrategyFactoryMethod):::EXIT
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == orig(this.sequence.getClass().getName())
this.sequence.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.repeatable == false
this.rule != null
this.startLength == -1
this.variance == -1
size(this.sequence[]) one of { 1, 2 }
this.sequence.getClass().getName() != orig(arg0.getClass().getName())
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives:::OBJECT
this.alternates.getClass().getName() == this.strategy.itemsWithoutStartChar.getClass().getName()
this.alternates.getClass().getName() == this.sequence.getClass().getName()
this.alternates != null
this.alternates[] elements != null
this.alternates[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
this.alternates.getClass().getName() == java.util.ArrayList.class
this.strategyFactoryMethod.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
this.strategy.inited == true
this.strategy.itemsWithStartChar != null
this.strategy.itemsWithoutStartChar != null
this.strategy.itemsWithoutStartChar[] elements != null
this.strategy.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
this.strategy.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item, fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
this.strategy.itemsWithoutStartChar.getClass().getName() == java.util.ArrayList.class
this.strategy.competitiveGroups != null
this.strategy.competeForLongestInput == true
this.sequence != null
this.sequence[] == []
this.sequence[].getClass().getName() == []
this.constraints == null
this.nullable == false
this.repeatable == false
this.rule == null
this.fixedLength == -1
this.startLength == -1
this.variance == -1
size(this.strategy.itemsWithoutStartChar[]) one of { 0, 2 }
size(this.strategy.itemsWithoutStartChar[])-1 != 0
this.alternates.getClass().getName() != this.strategyFactoryMethod.getClass().getName()
this.strategyFactoryMethod.getClass().getName() != this.strategy.itemsWithoutStartChar.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.ConsumerAlternatives(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
arg0.sequence.getClass().getName() == arg0.rule.symbols.getClass().getName()
arg0.sequence.getClass().getName() == java.util.ArrayList.class
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.fixedLength == -1
arg0.startLength == -1
arg0.variance == -1
size(arg0.sequence[]) one of { 1, 2 }
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.ConsumerAlternatives(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.alternates.getClass().getName() == arg0.sequence.getClass().getName()
this.alternates.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.alternates.getClass().getName() == orig(arg0.sequence.getClass().getName())
this.alternates.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.sequence == orig(arg0.sequence)
arg0.sequence[] == orig(arg0.sequence[])
arg0.constraints == orig(arg0.constraints)
arg0.nullable == orig(arg0.nullable)
arg0.repeatable == orig(arg0.repeatable)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.fixedLength == orig(arg0.fixedLength)
arg0.startLength == orig(arg0.startLength)
arg0.variance == orig(arg0.variance)
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.strategyFactoryMethod == null
this.strategy == null
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.fixedLength == -1
arg0.startLength == -1
arg0.variance == -1
size(this.alternates[]) == 1
size(arg0.sequence[]) one of { 1, 2 }
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.addAlternate(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.alternates.getClass().getName() == arg0.sequence.getClass().getName()
this.alternates.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.strategyFactoryMethod == null
this.strategy == null
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.fixedLength == -1
arg0.startLength == -1
arg0.variance == -1
size(this.alternates[]) one of { 0, 1, 2 }
size(arg0.sequence[]) one of { 1, 2 }
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.addAlternate(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.alternates == orig(this.alternates)
this.alternates.getClass().getName() == arg0.sequence.getClass().getName()
this.alternates.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.alternates.getClass().getName() == orig(arg0.sequence.getClass().getName())
this.alternates.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategy == orig(this.strategy)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.sequence == orig(arg0.sequence)
arg0.sequence[] == orig(arg0.sequence[])
arg0.constraints == orig(arg0.constraints)
arg0.nullable == orig(arg0.nullable)
arg0.repeatable == orig(arg0.repeatable)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.fixedLength == orig(arg0.fixedLength)
arg0.startLength == orig(arg0.startLength)
arg0.variance == orig(arg0.variance)
size(this.alternates[])-1 == orig(size(this.alternates[]))
this.strategyFactoryMethod == null
this.strategy == null
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.fixedLength == -1
arg0.startLength == -1
arg0.variance == -1
size(this.alternates[]) one of { 1, 2, 3 }
size(arg0.sequence[]) one of { 1, 2 }
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::ENTER
this.alternates.getClass().getName() == arg0.lineLengths.getClass().getName()
arg0.column == arg0.readOffset
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == arg0.buffer[arg0.column-1]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset-1]
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.readLen] == arg0.buffer[arg0.readLen]
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod has only one value
arg0 has only one value
arg0.line has only one value
arg0.line[] one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.column one of { 6, 7 }
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] elements one of { 1, 5, 6 }
arg0.scanPoint[] one of { [1, 5], [1, 6] }
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
arg0.eof == false
arg0.buffering == true
size(this.alternates[]) one of { 2, 3 }
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
arg0.line[arg0.column] == 0
arg0.line[arg0.column-1] one of { 32, 87 }
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 101, 108 }
arg0.line[arg0.readLen-1] one of { 72, 101 }
arg0.buffer[arg0.readPos] one of { 32, 87, 101 }
arg0.buffer[arg0.readPos] in arg0.line[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT124
this.alternates.getClass().getName() == return.rule.symbols.getClass().getName()
arg0.line[] == orig(arg0.line[])
arg0.column == orig(arg0.column)
arg0.column == orig(arg0.readOffset)
arg0.buffer[] == orig(arg0.buffer[])
arg0.readPos == arg0.readLen
arg0.readPos == orig(arg0.readLen)
arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos-1]
arg0.line[arg0.column-1] == arg0.buffer[orig(arg0.readLen)-1]
arg0.line[arg0.column-1] == orig(arg0.buffer[post(arg0.readPos)-1])
arg0.line[arg0.column-1] == orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.column-1] == orig(arg0.buffer[arg0.readPos])
arg0.line[arg0.column-1] == orig(arg0.buffer[arg0.readLen-1])
arg0.line[arg0.readPos] == arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] == arg0.buffer[arg0.readLen]
arg0.line[arg0.readPos] == arg0.buffer[orig(arg0.readLen)]
arg0.line[arg0.readPos] == orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readPos] == orig(arg0.buffer[post(arg0.readLen)])
arg0.line[arg0.readPos] == orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readPos-1] == arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readPos-1] == orig(arg0.line[arg0.readPos])
arg0.line[] == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
arg0.column == 6
arg0.scanPoint has only one value
arg0.buffer[] == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
arg0.readPos == 1
orig(this.strategy) == null
orig(arg0.scanPoint[]) == [1, 5]
orig(arg0.scanPoint[]) elements one of { 1, 5 }
orig(arg0.readPos) == 0
arg0.line[arg0.column-1] == 32
arg0.line[arg0.readPos] == 101
arg0.line[arg0.readPos-1] == 72
arg0.readPos in orig(arg0.scanPoint[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT126
arg0.readPos == orig(arg0.readPos)
arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.readPos] == orig(arg0.line[arg0.readPos])
arg0.line[arg0.readOffset-1] == arg0.buffer[arg0.readPos]
arg0.buffer[arg0.readPos] == arg0.buffer[arg0.readLen-1]
arg0.scanPoint == null
return == null
arg0.buffer[arg0.readPos] one of { 32, 87 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.consumeInternal(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT
this.alternates == orig(this.alternates)
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == arg0.lineLengths.getClass().getName()
this.alternates.getClass().getName() == return.sequenceList.getClass().getName()
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.alternates.getClass().getName() == orig(arg0.lineLengths.getClass().getName())
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategyFactoryMethod.getClass().getName() == orig(this.strategyFactoryMethod.getClass().getName())
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.itemsWithoutStartChar[].getClass().getName() == orig(this.strategy.itemsWithoutStartChar[].getClass().getName())
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.line == orig(arg0.line)
arg0.prevLine == orig(arg0.prevLine)
arg0.prevLength == orig(arg0.prevLength)
arg0.wasCr == orig(arg0.wasCr)
arg0.column == arg0.readOffset
arg0.lineLengths == orig(arg0.lineLengths)
arg0.lineLengths[] == orig(arg0.lineLengths[])
arg0.inputStream == orig(arg0.inputStream)
arg0.reader == orig(arg0.reader)
arg0.reader.getClass().getName() == orig(arg0.reader.getClass().getName())
arg0.buffer == orig(arg0.buffer)
arg0.eof == orig(arg0.eof)
arg0.buffering == orig(arg0.buffering)
return.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
size(arg0.line[]) == orig(size(arg0.line[]))
size(arg0.scanPoint[]) == orig(size(arg0.scanPoint[]))
size(arg0.buffer[]) == orig(size(arg0.buffer[]))
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == arg0.buffer[arg0.column-1]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)-1]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)-1])
arg0.line[arg0.column] == orig(arg0.line[arg0.column])
arg0.line[arg0.column] == orig(arg0.line[arg0.readOffset])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column-1])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset-1])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.column-1] == arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readPos)])
arg0.line[arg0.readLen] == arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] == orig(arg0.line[post(arg0.readLen)])
arg0.line[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.line[arg0.readLen-1] == arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen-1] == orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.readLen-1] == orig(arg0.line[arg0.readPos])
arg0.line[orig(arg0.column)-1] == arg0.buffer[orig(arg0.readLen)-1]
arg0.line[orig(arg0.column)-1] == orig(arg0.line[arg0.column-1])
arg0.line[orig(arg0.column)-1] == orig(arg0.line[arg0.readOffset-1])
arg0.line[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readLen-1])
arg0.line[orig(arg0.readLen)] == orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.readLen)] == orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readLen)-1] == orig(arg0.line[arg0.readLen-1])
orig(arg0.buffer[post(arg0.readLen)-1]) == orig(arg0.buffer[arg0.readPos])
(arg0.scanPoint == null)  <==>  (arg0.buffer[arg0.readPos] one of { 32, 87 })
(arg0.scanPoint == null)  <==>  (arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos])
(arg0.scanPoint == null)  <==>  (arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1])
(arg0.scanPoint == null)  <==>  (arg0.readPos == orig(arg0.readPos))
(arg0.scanPoint == null)  <==>  (return == null)
(arg0.scanPoint == null)  ==>  (arg0.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (arg0.buffer[orig(arg0.readLen)] one of { 87, 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.column one of { 6, 7 })
(arg0.scanPoint == null)  ==>  (arg0.line[] one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.column-1] one of { 32, 87 })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readLen-1] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readLen] one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.line[arg0.readPos] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.column)-1] one of { 32, 87 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.column)] one of { 0, 87 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readLen)-1] one of { 72, 101 })
(arg0.scanPoint == null)  ==>  (arg0.line[orig(arg0.readLen)] one of { 101, 108 })
(arg0.scanPoint == null)  ==>  (arg0.readLen one of { 1, 2 })
(arg0.scanPoint == null)  ==>  (arg0.readPos one of { 0, 1 })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[]) one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[arg0.readPos]) one of { 32, 87, 101 })
(arg0.scanPoint == null)  ==>  (orig(arg0.buffer[post(arg0.readPos)]) one of { 32, 87, 101 })
(arg0.scanPoint == null)  ==>  (orig(arg0.column) one of { 6, 7 })
(arg0.scanPoint == null)  ==>  (orig(arg0.line[]) one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] })
(arg0.scanPoint == null)  ==>  (orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 })
(arg0.scanPoint == null)  ==>  (orig(arg0.readLen) one of { 1, 2 })
(arg0.scanPoint == null)  ==>  (orig(arg0.readPos) one of { 0, 1 })
(arg0.scanPoint == null)  ==>  (orig(arg0.scanPoint[]) elements one of { 1, 5, 6 })
(arg0.scanPoint == null)  ==>  (orig(arg0.scanPoint[]) one of { [1, 5], [1, 6] })
(arg0.scanPoint == null)  ==>  (orig(size(this.strategy.itemsWithoutStartChar[])) one of { 0, 2 })
(arg0.scanPoint == null)  ==>  (orig(this.strategy.itemsWithoutStartChar.getClass().getName()) == java.util.ArrayList.class)
(arg0.scanPoint == null)  ==>  (orig(this.strategy.itemsWithoutStartChar[].getClass().getName()) elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class)
(arg0.scanPoint == null)  ==>  (orig(this.strategy.itemsWithoutStartChar[].getClass().getName()) one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item, fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] })
(arg0.scanPoint == null)  ==>  (this.alternates.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName()))
(arg0.scanPoint == null)  ==>  (this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups))
(arg0.scanPoint == null)  ==>  (this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar))
(arg0.scanPoint == null)  ==>  (this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar))
(arg0.scanPoint == null)  ==>  (this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[]))
(arg0.scanPoint == null)  ==>  (this.strategy.itemsWithoutStartChar[].getClass().getName() == orig(this.strategy.itemsWithoutStartChar[].getClass().getName()))
(arg0.scanPoint has only one value)  <==>  (arg0.buffer[arg0.readPos] == 101)
(arg0.scanPoint has only one value)  <==>  (arg0.line[arg0.readPos] == arg0.buffer[arg0.readPos])
(arg0.scanPoint has only one value)  <==>  (arg0.line[arg0.readPos] == arg0.buffer[orig(arg0.readLen)])
(arg0.scanPoint has only one value)  <==>  (arg0.readPos == arg0.readLen)
(arg0.scanPoint has only one value)  ==>  (arg0.buffer[] == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
(arg0.scanPoint has only one value)  ==>  (arg0.buffer[arg0.readPos-1] == 32)
(arg0.scanPoint has only one value)  ==>  (arg0.buffer[orig(arg0.readLen)] == 101)
(arg0.scanPoint has only one value)  ==>  (arg0.column == 6)
(arg0.scanPoint has only one value)  ==>  (arg0.column == orig(arg0.column))
(arg0.scanPoint has only one value)  ==>  (arg0.column in arg0.scanPoint[])
(arg0.scanPoint has only one value)  ==>  (arg0.line[] == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.column-1] == 32)
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos-1])
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.column-1] == orig(arg0.buffer[arg0.readPos]))
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.column-1] == orig(arg0.buffer[post(arg0.readPos)-1]))
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.readLen-1] == 72)
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.readLen] == 101)
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.readPos-1] == 72)
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.readPos] == 101)
(arg0.scanPoint has only one value)  ==>  (arg0.line[arg0.readPos] == orig(arg0.buffer[post(arg0.readPos)]))
(arg0.scanPoint has only one value)  ==>  (arg0.line[orig(arg0.column)-1] == 32)
(arg0.scanPoint has only one value)  ==>  (arg0.line[orig(arg0.column)] == 0)
(arg0.scanPoint has only one value)  ==>  (arg0.line[orig(arg0.readLen)-1] == 72)
(arg0.scanPoint has only one value)  ==>  (arg0.line[orig(arg0.readLen)] == 101)
(arg0.scanPoint has only one value)  ==>  (arg0.readLen == 1)
(arg0.scanPoint has only one value)  ==>  (arg0.readLen in arg0.scanPoint[])
(arg0.scanPoint has only one value)  ==>  (arg0.readLen in orig(arg0.scanPoint[]))
(arg0.scanPoint has only one value)  ==>  (arg0.readPos == 1)
(arg0.scanPoint has only one value)  ==>  (arg0.readPos == orig(arg0.readLen))
(arg0.scanPoint has only one value)  ==>  (arg0.readPos in arg0.scanPoint[])
(arg0.scanPoint has only one value)  ==>  (arg0.readPos in orig(arg0.scanPoint[]))
(arg0.scanPoint has only one value)  ==>  (arg0.scanPoint[] == [1, 6])
(arg0.scanPoint has only one value)  ==>  (arg0.scanPoint[] elements one of { 1, 6 })
(arg0.scanPoint has only one value)  ==>  (orig(arg0.buffer[]) == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
(arg0.scanPoint has only one value)  ==>  (orig(arg0.buffer[arg0.readPos]) == 32)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.buffer[post(arg0.readPos)-1]) == 32)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.buffer[post(arg0.readPos)]) == 101)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.column) == 6)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.column) in arg0.scanPoint[])
(arg0.scanPoint has only one value)  ==>  (orig(arg0.line[]) == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
(arg0.scanPoint has only one value)  ==>  (orig(arg0.line[post(arg0.column)-1]) == 32)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.line[post(arg0.readPos)-1]) == 72)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.readLen) == 1)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.readLen) in arg0.scanPoint[])
(arg0.scanPoint has only one value)  ==>  (orig(arg0.readLen) in orig(arg0.scanPoint[]))
(arg0.scanPoint has only one value)  ==>  (orig(arg0.readPos) == 0)
(arg0.scanPoint has only one value)  ==>  (orig(arg0.scanPoint[]) == [1, 5])
(arg0.scanPoint has only one value)  ==>  (orig(arg0.scanPoint[]) elements one of { 1, 5 })
(arg0.scanPoint has only one value)  ==>  (orig(this.strategy) == null)
(arg0.scanPoint has only one value)  ==>  (return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String])
(arg0.scanPoint has only one value)  ==>  (return.rule.symbols[].getClass().getName() elements == java.lang.String.class)
(arg0.scanPoint has only one value)  ==>  (return.sequenceList.getClass().getName() == java.util.ArrayList.class)
(arg0.scanPoint has only one value)  ==>  (return.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] })
(arg0.scanPoint has only one value)  ==>  (return.stringResult == null)
(arg0.scanPoint has only one value)  ==>  (this.alternates.getClass().getName() == return.sequenceList.getClass().getName())
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod has only one value
arg0.line has only one value
arg0.line[] one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.column one of { 6, 7 }
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] == [1, 6]
arg0.scanPoint[] elements one of { 1, 6 }
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
arg0.eof == false
arg0.buffering == true
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.sequenceList.getClass().getName() == java.util.ArrayList.class
return.stringResult == null
size(this.alternates[]) one of { 2, 3 }
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
arg0.line[arg0.column] == 0
arg0.line[arg0.column-1] one of { 32, 87 }
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 101, 108 }
arg0.line[arg0.readLen-1] one of { 72, 101 }
arg0.line[orig(arg0.column)] one of { 0, 87 }
arg0.line[orig(arg0.column)-1] one of { 32, 87 }
arg0.line[orig(arg0.readLen)] one of { 101, 108 }
arg0.line[orig(arg0.readLen)-1] one of { 72, 101 }
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 }
arg0.buffer[arg0.readPos] one of { 32, 87, 101 }
arg0.buffer[orig(arg0.readLen)] one of { 87, 101, 108 }
orig(arg0.buffer[post(arg0.readPos)]) one of { 32, 87, 101 }
orig(arg0.line[post(arg0.column)-1]) in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[orig(arg0.readLen)] in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)]) in arg0.line[]
orig(arg0.buffer[arg0.readPos]) in arg0.line[]
arg0.column in arg0.scanPoint[]
arg0.readPos in arg0.scanPoint[]
arg0.readLen in arg0.scanPoint[]
orig(arg0.column) in arg0.scanPoint[]
orig(arg0.readLen) in arg0.scanPoint[]
arg0.line[orig(arg0.column)] in arg0.buffer[]
orig(arg0.line[post(arg0.column)-1]) in arg0.buffer[]
orig(arg0.buffer[post(arg0.readPos)]) in orig(arg0.line[])
orig(arg0.line[post(arg0.column)-1]) in orig(arg0.buffer[])
orig(arg0.line[post(arg0.column)-1]) % arg0.line[arg0.column-1] == 0
arg0.line[orig(arg0.column)] % arg0.buffer[arg0.readPos] == 0
arg0.line[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
orig(arg0.line[post(arg0.column)-1]) % arg0.line[orig(arg0.column)-1] == 0
orig(arg0.line[post(arg0.column)-1]) % orig(arg0.buffer[arg0.readPos]) == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getAlternatives():::ENTER
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod == null
this.strategy == null
size(this.alternates[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getAlternatives():::EXIT
this.alternates == return
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == return.getClass().getName()
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategy == orig(this.strategy)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.sequence.getClass().getName() == return.getClass().getName()
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
return == orig(this.alternates)
return.getClass().getName() == orig(this.alternates.getClass().getName())
return.getClass().getName() == orig(this.sequence.getClass().getName())
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod == null
this.strategy == null
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Consumer.class
return[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
return.getClass().getName() == java.util.ArrayList.class
size(this.alternates[]) one of { 2, 3 }
size(return[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getSomeLength(boolean, java.util.List):::ENTER
this.alternates.getClass().getName() == arg1.getClass().getName()
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.strategyFactoryMethod has only one value
this.strategy == null
arg0 == true
arg1[] == []
arg1[].getClass().getName() == []
size(this.alternates[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getSomeLength(boolean, java.util.List):::EXIT
this.alternates == orig(this.alternates)
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.alternates.getClass().getName() == orig(arg1.getClass().getName())
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategyFactoryMethod.getClass().getName() == orig(this.strategyFactoryMethod.getClass().getName())
this.strategy == orig(this.strategy)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg1[] == orig(arg1[])
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.strategyFactoryMethod has only one value
this.strategy == null
arg1[] == []
arg1[].getClass().getName() == []
return one of { 1, 2 }
size(this.alternates[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartCharacter():::ENTER
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategy == null
size(this.alternates[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartCharacter():::EXIT65
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer]
size(this.alternates[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartCharacter():::EXIT68
this.alternates has only one value
this.alternates[] contains no nulls and has only one value, of length 2
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.strategyFactoryMethod == null
this.sequence has only one value
orig(this) has only one value
size(this.alternates[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartCharacter():::EXIT
this.alternates == orig(this.alternates)
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategyFactoryMethod.getClass().getName() == orig(this.strategyFactoryMethod.getClass().getName())
this.strategy == orig(this.strategy)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  <==>  (size(this.alternates[]) == 3)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  ==>  (this.strategyFactoryMethod.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  <==>  (size(this.alternates[]) == 2)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  ==>  (orig(this) has only one value)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  ==>  (this.alternates has only one value)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  ==>  (this.alternates[] contains no nulls and has only one value, of length 2)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  ==>  (this.sequence has only one value)
(this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer])  ==>  (this.strategyFactoryMethod == null)
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategy == null
return == null
size(this.alternates[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartVariance():::ENTER
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.strategyFactoryMethod has only one value
this.strategy == null
size(this.alternates[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartVariance():::EXIT83
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.getStartVariance():::EXIT
this.alternates == orig(this.alternates)
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategyFactoryMethod.getClass().getName() == orig(this.strategyFactoryMethod.getClass().getName())
this.strategy == orig(this.strategy)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.alternates[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer]
this.strategyFactoryMethod has only one value
this.strategy == null
return == 3
size(this.alternates[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.alternates.getClass().getName() == arg0.sequence.getClass().getName()
this.alternates.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.strategy.itemsWithoutStartChar.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod has only one value
this.strategyFactoryMethod != null
arg0 != null
arg0.sequence != null
arg0.sequence[] elements != null
arg0.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.fixedLength == -1
arg0.startLength one of { -1, 1 }
arg0.startLength != 0
arg0.variance one of { -1, 3 }
size(this.alternates[]) one of { 2, 3 }
size(arg0.sequence[]) == 1
size(arg0.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT137
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT137;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.alternates == orig(this.alternates)
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == arg0.sequence.getClass().getName()
this.alternates.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.alternates.getClass().getName() == orig(arg0.sequence.getClass().getName())
this.strategyFactoryMethod == orig(this.strategyFactoryMethod)
this.strategyFactoryMethod.getClass().getName() == orig(this.strategyFactoryMethod.getClass().getName())
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.itemsWithoutStartChar.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.strategy.itemsWithoutStartChar.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
arg0.sequence == orig(arg0.sequence)
arg0.sequence[] == orig(arg0.sequence[])
arg0.constraints == orig(arg0.constraints)
arg0.nullable == orig(arg0.nullable)
arg0.repeatable == orig(arg0.repeatable)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.fixedLength == orig(arg0.fixedLength)
arg0.startLength == orig(arg0.startLength)
arg0.variance == orig(arg0.variance)
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod has only one value
this.strategyFactoryMethod != null
arg0.sequence != null
arg0.sequence[] elements != null
arg0.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
arg0.constraints == null
arg0.nullable == false
arg0.repeatable == false
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.fixedLength == -1
arg0.startLength one of { -1, 1 }
arg0.startLength != 0
arg0.variance one of { -1, 3 }
return == false
size(this.alternates[]) one of { 2, 3 }
size(arg0.sequence[]) == 1
size(arg0.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.overlaps(fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.setStrategyFactoryMethod(fri.patterns.interpreter.parsergenerator.lexer.StrategyFactoryMethod):::ENTER
this.strategyFactoryMethod.getClass().getName() == arg0.getClass().getName()
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategy == null
arg0 has only one value
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.examples.HowToOverrideLexerImpl$1OverrideLexer.class
size(this.alternates[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.setStrategyFactoryMethod(fri.patterns.interpreter.parsergenerator.lexer.StrategyFactoryMethod):::EXIT
this.alternates == orig(this.alternates)
this.alternates[] == orig(this.alternates[])
this.alternates.getClass().getName() == orig(this.alternates.getClass().getName())
this.alternates.getClass().getName() == orig(this.sequence.getClass().getName())
this.strategyFactoryMethod == orig(arg0)
this.strategyFactoryMethod.getClass().getName() == orig(this.strategyFactoryMethod.getClass().getName())
this.strategyFactoryMethod.getClass().getName() == orig(arg0.getClass().getName())
this.strategy == orig(this.strategy)
this.sequence == orig(this.sequence)
this.sequence[] == orig(this.sequence[])
this.constraints == orig(this.constraints)
this.nullable == orig(this.nullable)
this.repeatable == orig(this.repeatable)
this.rule == orig(this.rule)
this.fixedLength == orig(this.fixedLength)
this.startLength == orig(this.startLength)
this.variance == orig(this.variance)
this.alternates[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer, fri.patterns.interpreter.parsergenerator.lexer.Consumer] }
this.strategyFactoryMethod has only one value
this.strategy == null
size(this.alternates[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input:::CLASS
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input:::OBJECT
this has only one value
this.inputStream == null
this.reader has only one value
this.reader != null
this.reader.getClass().getName() == java.io.StringReader.class
this.buffer[] elements >= 0
this.readPos >= 0
this.readLen >= 0
this.readOffset >= 0
size(this.buffer[]) == 128
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.Input(java.lang.Object):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.Input(java.lang.Object):::EXIT
this.buffer == null
this.readPos == 0
this.readLen == 0
this.readOffset == 0
this.eof == false
this.buffering == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getMark():::ENTER
this.readPos one of { 0, 1 }
this.readLen one of { 0, 1, 2 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getMark():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.readPos one of { 0, 1 }
this.readLen one of { 0, 1, 2 }
this.eof == false
this.buffering == true
return one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getReadOffset():::ENTER
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getReadOffset():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getScanOffset():::ENTER
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getScanOffset():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getUnreadLength():::ENTER
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.getUnreadLength():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.readPos one of { 0, 1, 5 }
this.eof == false
return one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.peek():::ENTER
this.readPos one of { 0, 1 }
this.readLen one of { 0, 1, 2 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.peek():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.readPos == orig(this.readPos)
size(this.buffer[]) == orig(size(this.buffer[]))
this.buffer has only one value
this.readPos one of { 0, 1 }
this.readLen one of { 0, 1, 2 }
this.buffering == true
this.buffer[] <= orig(this.buffer[]) (elementwise)
this.readLen >= orig(this.readLen)
this.readOffset >= orig(this.readOffset)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.read():::ENTER
this.eof == false
this.buffering == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.read():::EXIT55
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.readPos one of { 1, 2 }
this.readLen one of { 1, 2 }
this.readOffset one of { 1, 6, 7 }
this.eof == false
return one of { 32, 72, 87 }
orig(this.readPos) one of { 0, 1 }
this.readPos > orig(this.readPos)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.read():::EXIT87
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.read():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffering == orig(this.buffering)
size(this.buffer[]) == orig(size(this.buffer[]))
this.buffer has only one value
this.buffer != null
this.buffering == true
this.readPos >= orig(this.readPos)
this.readLen >= orig(this.readLen)
this.readOffset >= orig(this.readOffset)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.resolveBuffer():::ENTER
this.buffer has only one value
this.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.readPos one of { 1, 5 }
this.readLen one of { 2, 5 }
this.readOffset one of { 5, 7, 11 }
this.eof == false
this.buffering == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.resolveBuffer():::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
size(this.buffer[]) == orig(size(this.buffer[]))
this.buffer has only one value
this.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.readPos == 0
this.readLen one of { 0, 1 }
this.readOffset one of { 5, 7, 11 }
this.eof == false
this.buffering == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.setMark(int):::ENTER
this.buffer has only one value
this.buffer != null
this.readPos one of { 0, 1, 2 }
this.readLen one of { 0, 1, 2 }
this.buffering == true
arg0 one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.setMark(int):::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.buffer has only one value
this.buffer != null
this.readPos one of { 0, 1 }
this.readLen one of { 0, 1, 2 }
this.buffering == true
this.readPos <= orig(this.readPos)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.storeRead(int):::ENTER
this.eof == false
this.buffering == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Input.storeRead(int):::EXIT
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
size(this.buffer[]) == orig(size(this.buffer[]))
this.buffer has only one value
this.eof == false
this.buffering == true
this.readPos - orig(this.readPos) - 1 == 0
this.readLen - orig(this.readLen) - 1 == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText:::CLASS
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText:::OBJECT
this has only one value
this.line[] elements >= 0
this.prevLine == null
this.prevLength == 0
this.wasCr == false
this.column >= 0
this.lineLengths has only one value
this.lineLengths != null
this.lineLengths[] == []
this.lineLengths[].getClass().getName() == []
this.lineLengths.getClass().getName() == java.util.ArrayList.class
this.inputStream == null
this.reader has only one value
this.reader != null
this.reader.getClass().getName() == java.io.StringReader.class
this.buffer[] elements >= 0
this.readPos >= 0
this.readLen >= 0
this.readOffset >= 0
size(this.line[]) == 64
size(this.scanPoint[]) == 2
size(this.buffer[]) == 128
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.InputText(java.lang.Object):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.InputText(java.lang.Object):::EXIT
this.line == null
this.column == 0
this.scanPoint == null
this.buffer == null
this.readPos == 0
this.readLen == 0
this.readOffset == 0
this.eof == false
this.buffering == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.calculateScanPoint():::ENTER
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.calculateScanPoint():::EXIT109
this.scanPoint == orig(this.scanPoint)
this.scanPoint[] == orig(this.scanPoint[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.calculateScanPoint():::EXIT113
orig(this.scanPoint) == null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.calculateScanPoint():::EXIT
this.line == orig(this.line)
this.line[] == orig(this.line[])
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.column == orig(this.column)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.scanPoint != null
this.readPos one of { 0, 1, 5 }
this.eof == false
return != null
size(return[]) == 2
this.scanPoint[] == orig(this.scanPoint[]) (elementwise)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.convertInput(int):::ENTER
this.scanPoint == null
this.eof == false
this.buffering == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.convertInput(int):::EXIT
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.scanPoint == orig(this.scanPoint)
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
size(this.line[]) == orig(size(this.line[]))
this.line has only one value
this.scanPoint == null
this.eof == false
this.buffering == true
this.line[] > orig(this.line[]) (lexically)
this.line[] >= orig(this.line[]) (elementwise)
this.column - orig(this.column) - 1 == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getReadColumn():::ENTER
this.scanPoint == null
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getReadColumn():::EXIT
this.line == orig(this.line)
this.line[] == orig(this.line[])
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.column == orig(this.column)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.scanPoint == orig(this.scanPoint)
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.scanPoint == null
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getReadLine():::ENTER
this.scanPoint == null
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getReadLine():::EXIT
this.line == orig(this.line)
this.line[] == orig(this.line[])
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.column == orig(this.column)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.scanPoint == orig(this.scanPoint)
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.scanPoint == null
this.readPos one of { 0, 1, 5 }
this.eof == false
return == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getScanColumn():::ENTER
this.scanPoint != null
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getScanColumn():::EXIT
this.line == orig(this.line)
this.line[] == orig(this.line[])
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.column == orig(this.column)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.scanPoint == orig(this.scanPoint)
this.scanPoint[] == orig(this.scanPoint[])
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.scanPoint != null
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getScanLine():::ENTER
this.readPos one of { 0, 1, 5 }
this.eof == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.getScanLine():::EXIT
this.line == orig(this.line)
this.line[] == orig(this.line[])
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.column == orig(this.column)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.scanPoint != null
this.readPos one of { 0, 1, 5 }
this.eof == false
return == 1
this.scanPoint[] == orig(this.scanPoint[]) (elementwise)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.read():::ENTER
this.eof == false
this.buffering == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.read():::EXIT
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffering == orig(this.buffering)
size(this.line[]) == orig(size(this.line[]))
size(this.buffer[]) == orig(size(this.buffer[]))
this.line has only one value
this.line != null
this.scanPoint == null
this.buffer has only one value
this.buffer != null
this.buffering == true
this.line[] >= orig(this.line[]) (elementwise)
this.column >= orig(this.column)
this.readPos >= orig(this.readPos)
this.readLen >= orig(this.readLen)
this.readOffset >= orig(this.readOffset)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.setMark(int):::ENTER
this.line has only one value
this.line != null
this.scanPoint == null
this.buffer has only one value
this.buffer != null
this.readPos one of { 0, 1, 2 }
this.readLen one of { 0, 1, 2 }
this.buffering == true
arg0 one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.setMark(int):::EXIT
this.line == orig(this.line)
this.line[] == orig(this.line[])
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.column == orig(this.column)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.scanPoint == orig(this.scanPoint)
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
this.line has only one value
this.line != null
this.scanPoint == null
this.buffer has only one value
this.buffer != null
this.readPos one of { 0, 1 }
this.readLen one of { 0, 1, 2 }
this.buffering == true
this.readPos <= orig(this.readPos)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.storeRead(int):::ENTER
this.scanPoint == null
this.eof == false
this.buffering == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.InputText.storeRead(int):::EXIT
this.prevLine == orig(this.prevLine)
this.prevLength == orig(this.prevLength)
this.wasCr == orig(this.wasCr)
this.lineLengths == orig(this.lineLengths)
this.lineLengths[] == orig(this.lineLengths[])
this.lineLengths.getClass().getName() == orig(this.lineLengths.getClass().getName())
this.scanPoint == orig(this.scanPoint)
this.inputStream == orig(this.inputStream)
this.reader == orig(this.reader)
this.reader.getClass().getName() == orig(this.reader.getClass().getName())
this.buffer == orig(this.buffer)
this.buffer[] == orig(this.buffer[])
this.readPos == orig(this.readPos)
this.readLen == orig(this.readLen)
this.readOffset == orig(this.readOffset)
this.eof == orig(this.eof)
this.buffering == orig(this.buffering)
size(this.line[]) == orig(size(this.line[]))
this.line has only one value
this.scanPoint == null
this.eof == false
this.buffering == true
this.line[] > orig(this.line[]) (lexically)
this.line[] >= orig(this.line[]) (elementwise)
this.column - orig(this.column) - 1 == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder:::CLASS
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder:::OBJECT
this has only one value
this.charConsumers.getClass().getName() == java.util.Hashtable.class
this.ignoredSymbols has only one value
this.ignoredSymbols != null
this.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.ignoredSymbols[] elements has only one value
this.ignoredSymbols[] elements != null
this.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.ignoredSymbols.getClass().getName() == java.util.ArrayList.class
size(this.ignoredSymbols[]) == 1
this.charConsumers.getClass().getName() != this.ignoredSymbols.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.LexerBuilder(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::ENTER
arg0.rules.getClass().getName() == arg1.getClass().getName()
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 16
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.ruleHash has only one value
arg1 has only one value
arg1[] contains no nulls and has only one value, of length 1
arg1[] elements has only one value
arg1[].getClass().getName() == [java.lang.String]
arg1[].getClass().getName() elements == java.lang.String.class
arg1.getClass().getName() == java.util.ArrayList.class
size(arg0.rules[]) == 16
size(arg1[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.LexerBuilder(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::EXIT
this.ignoredSymbols == orig(arg1)
this.ignoredSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(arg0.rules.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.getClass().getName())
arg0.rules == orig(arg0.rules)
arg0.ruleHash == orig(arg0.ruleHash)
arg1[] == orig(arg1[])
this.charConsumers has only one value
arg0.rules has only one value
arg0.rules[] == []
arg0.rules[].getClass().getName() == []
arg0.ruleHash has only one value
arg1[] contains no nulls and has only one value, of length 1
arg1[] elements has only one value
arg1[].getClass().getName() == [java.lang.String]
arg1[].getClass().getName() elements == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.build(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
this.ignoredSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.charConsumers == null
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 16
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.build(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg0.rules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
arg0.rules == orig(arg0.rules)
arg0.ruleHash == orig(arg0.ruleHash)
this.charConsumers has only one value
arg0.rules has only one value
arg0.rules[] == []
arg0.rules[].getClass().getName() == []
arg0.ruleHash has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkNullableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::ENTER
this.ignoredSymbols.getClass().getName() == arg1.symbols.getClass().getName()
arg2 == arg3.pos
arg2 == arg3.array[arg2]
arg2 == arg3.array[arg3.pos]
this.charConsumers has only one value
arg0.toString one of { "newlines", "spaces", "whitespaces" }
arg1.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg2 one of { 0, 1, 2 }
arg3 has only one value
arg3.array has only one value
arg3.array[] == [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 0, 0, 0]
arg3.array[] elements >= 0
size(arg1.symbols[]) == 3
size(arg3.array[]) == 16
size(arg3.array[])-1 in arg3.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkNullableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT277
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkNullableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT277;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkNullableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == arg1.symbols.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.symbols.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
arg0.toString == orig(arg0.toString)
arg1.symbols == orig(arg1.symbols)
arg1.symbols[] == orig(arg1.symbols[])
arg3.array == orig(arg3.array)
arg3.array[] == orig(arg3.array[])
arg3.pos == orig(arg2)
arg3.pos == orig(arg3.pos)
arg3.pos == orig(arg3.array[post(arg2)])
arg3.pos == arg3.array[arg3.pos]
arg3.pos == arg3.array[orig(arg2)]
arg3.pos == arg3.array[orig(arg3.pos)]
arg3.pos == orig(arg3.array[post(arg3.pos)])
arg3.pos == orig(arg3.array[arg2])
arg3.pos == orig(arg3.array[arg3.pos])
this.charConsumers has only one value
arg0.toString one of { "newlines", "spaces", "whitespaces" }
arg1.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg3.array has only one value
arg3.array[] == [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 0, 0, 0]
arg3.array[] elements >= 0
arg3.pos one of { 0, 1, 2 }
return == false
size(arg1.symbols[]) == 3
size(arg3.array[]) == 16
size(arg3.array[])-1 in arg3.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkNullableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkRepeatableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::ENTER
this.ignoredSymbols.getClass().getName() == arg1.symbols.getClass().getName()
arg2 == arg3.pos
arg2 == arg3.array[arg2]
arg2 == arg3.array[arg3.pos]
this.charConsumers has only one value
arg0.toString one of { "newlines", "spaces", "whitespaces" }
arg1.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg2 one of { 0, 1, 2 }
arg3 has only one value
arg3.array has only one value
arg3.array[] == [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 0, 0, 0]
arg3.array[] elements >= 0
size(arg1.symbols[]) == 3
size(arg3.array[]) == 16
size(arg3.array[])-1 in arg3.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkRepeatableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT292
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkRepeatableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT292;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkRepeatableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == arg1.symbols.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.symbols.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
arg0.toString == orig(arg0.toString)
arg1.symbols == orig(arg1.symbols)
arg1.symbols[] == orig(arg1.symbols[])
arg3.array == orig(arg3.array)
arg3.array[] == orig(arg3.array[])
orig(arg2) == orig(arg3.array[post(arg2)])
orig(arg2) == arg3.array[arg3.pos-1]
orig(arg2) == arg3.array[orig(arg2)]
orig(arg2) == arg3.array[orig(arg3.pos)]
orig(arg2) == orig(arg3.array[post(arg3.pos)-1])
this.charConsumers has only one value
arg0.toString one of { "newlines", "spaces", "whitespaces" }
arg1.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg3.array has only one value
arg3.array[] == [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 0, 0, 0]
arg3.array[] elements >= 0
arg3.pos one of { 1, 2, 3 }
return == true
size(arg1.symbols[]) == 3
size(arg3.array[]) == 16
arg3.array[arg3.pos] one of { 1, 2, 4 }
size(arg3.array[])-1 in arg3.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.checkRepeatableRule(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.convertSymbol(java.lang.String):::ENTER
this.charConsumers has only one value
this.charConsumers != null
arg0 != null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.convertSymbol(java.lang.String):::EXIT339
arg0.toString one of { "'\\n'", "'\\r'" }
return.toString one of { "\n", "\r" }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.convertSymbol(java.lang.String):::EXIT352
return == orig(arg0)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.convertSymbol(java.lang.String):::EXIT354
arg0.toString one of { "0x20", "0x9", "0xC" }
return.toString one of { "\t", "\014", " " }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.convertSymbol(java.lang.String):::EXIT
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
arg0.toString == orig(arg0.toString)
this.charConsumers has only one value
this.charConsumers != null
return != null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.putCharConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.ignoredSymbols.getClass().getName() == arg1.sequence.getClass().getName()
this.ignoredSymbols.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.charConsumers has only one value
this.charConsumers != null
arg0 != null
arg1 != null
arg1.sequence != null
arg1.sequence[] elements != null
arg1.constraints == null
arg1.nullable == false
arg1.repeatable == false
arg1.rule != null
arg1.rule.symbols != null
arg1.rule.symbols[] elements != null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance == -1
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.putCharConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == arg1.sequence.getClass().getName()
this.ignoredSymbols.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.sequence.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
arg0.toString == orig(arg0.toString)
arg1.sequence == orig(arg1.sequence)
arg1.sequence[] == orig(arg1.sequence[])
arg1.constraints == orig(arg1.constraints)
arg1.nullable == orig(arg1.nullable)
arg1.repeatable == orig(arg1.repeatable)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.fixedLength == orig(arg1.fixedLength)
arg1.startLength == orig(arg1.startLength)
arg1.variance == orig(arg1.variance)
this.charConsumers has only one value
this.charConsumers != null
arg1.sequence != null
arg1.sequence[] elements != null
arg1.constraints == null
arg1.nullable == false
arg1.repeatable == false
arg1.rule != null
arg1.rule.symbols != null
arg1.rule.symbols[] elements != null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance == -1
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.translateLexerRule(fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::ENTER
this.ignoredSymbols.getClass().getName() == arg0.symbols.getClass().getName()
arg2.array[arg1] == arg2.array[arg2.pos]
this.charConsumers has only one value
this.charConsumers != null
arg0 != null
arg0.symbols != null
arg0.symbols[] elements != null
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2 has only one value
arg2 != null
arg2.array has only one value
arg2.array != null
arg2.array[] elements >= 0
size(arg0.symbols[]) one of { 2, 3 }
size(arg2.array[]) == 16
arg2.array[arg1] == 0
arg2.array[] elements <= arg1
arg1 >= arg2.pos
arg1 <= size(arg2.array[])-1
arg1 >= arg2.array[arg1]
arg2.array[] elements < size(arg2.array[])-1
arg2.array[] elements >= arg2.array[arg1]
arg2.pos < size(arg2.array[])-1
arg2.pos >= arg2.array[arg1]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.translateLexerRule(fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT149
arg2.array[] == orig(arg2.array[])
arg2.pos == orig(arg2.pos)
arg2.array[arg2.pos] == arg2.array[orig(arg1)]
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
arg2.array[] one of { [0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 0, 0, 0, 0] }
arg2.pos one of { 3, 9, 12 }
orig(arg1) one of { 3, 10, 14 }
size(arg0.symbols[]) == 3
arg2.array[arg2.pos-1] one of { 2, 9, 13 }
arg2.array[orig(arg1)-1] one of { 0, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.translateLexerRule(fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT239
orig(arg1) == arg2.array[arg2.pos-1]
orig(arg1) == arg2.array[orig(arg2.pos)]
arg2.array[arg2.pos] == orig(arg2.array[post(arg2.pos)-1])
orig(arg2.array[]) elements <= arg2.pos
arg2.pos - orig(arg2.pos) - 1 == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.translateLexerRule(fri.patterns.interpreter.parsergenerator.syntax.Rule, int, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == arg0.symbols.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg0.symbols.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG == orig(fri.patterns.interpreter.parsergenerator.lexer.LexerBuilder.DEBUG)
arg0.symbols == orig(arg0.symbols)
arg0.symbols[] == orig(arg0.symbols[])
arg2.array == orig(arg2.array)
size(arg2.array[]) == orig(size(arg2.array[]))
orig(arg2.array[post(arg1)]) == arg2.array[arg2.pos]
arg2.array[arg2.pos] == orig(arg2.array[post(arg2.pos)])
arg2.array[arg2.pos] == orig(arg2.array[arg1])
arg2.array[arg2.pos] == orig(arg2.array[arg2.pos])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  <==>  (arg2.array[arg2.pos] == orig(arg2.array[post(arg2.pos)-1]))
(orig(arg2.array[post(arg2.pos)-1]) == 0)  <==>  (orig(arg1) == arg2.array[arg2.pos-1])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  <==>  (orig(arg1) == arg2.array[orig(arg2.pos)])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  <==>  (orig(arg2.pos) <= arg2.array[orig(arg2.pos)])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] })
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (arg2.array[] elements <= arg2.array[orig(arg2.pos)])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (arg2.array[] elements >= orig(arg2.array[post(arg2.pos)-1]))
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (arg2.array[orig(arg1)] one of { 0, 1, 2 })
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (arg2.pos - orig(arg2.pos) - 1 == 0)
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (arg2.pos > orig(arg2.array[post(arg2.pos)-1]))
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (orig(arg2.array[]) elements <= arg2.array[orig(arg2.pos)])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (orig(arg2.array[]) elements <= arg2.pos)
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (orig(arg2.array[]) elements >= orig(arg2.array[post(arg2.pos)-1]))
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (orig(arg2.pos) <= arg2.array[arg2.pos-1])
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (orig(arg2.pos) >= orig(arg2.array[post(arg2.pos)-1]))
(orig(arg2.array[post(arg2.pos)-1]) == 0)  ==>  (size(arg0.symbols[]) one of { 2, 3 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  <==>  (arg2.pos == orig(arg2.pos))
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String])
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[] == orig(arg2.array[]))
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[] one of { [0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 0, 0, 0, 0] })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[arg1-1] one of { 0, 2 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[arg2.pos-1] one of { 2, 9, 13 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[arg2.pos] == arg2.array[orig(arg1)])
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[orig(arg1)-1] one of { 0, 2 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[orig(arg1)] == 0)
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[orig(arg2.pos)-1] one of { 2, 9, 13 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.array[orig(arg2.pos)] == 0)
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (arg2.pos one of { 3, 9, 12 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (orig(arg1) one of { 3, 10, 14 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (orig(arg2.array[]) one of { [0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 0, 0, 0, 0] })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (orig(arg2.array[arg1-1]) one of { 0, 2 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (orig(arg2.array[arg2.pos-1]) one of { 2, 9, 13 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (orig(arg2.array[post(arg1)-1]) one of { 0, 2 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (orig(arg2.pos) one of { 3, 9, 12 })
(orig(arg2.array[post(arg2.pos)-1]) one of { 2, 9, 13 })  ==>  (size(arg0.symbols[]) == 3)
this.charConsumers has only one value
this.charConsumers != null
arg0.symbols != null
arg0.symbols[] elements != null
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.array has only one value
arg2.array != null
arg2.array[] elements >= 0
size(arg0.symbols[]) one of { 2, 3 }
size(arg2.array[]) == 16
arg2.array[arg2.pos] == 0
arg2.array[orig(arg1)] one of { 0, 1, 2 }
arg2.array[] elements <= orig(arg1)
arg2.array[] >= orig(arg2.array[]) (elementwise)
arg2.array[] elements <= size(arg2.array[])-1
arg2.array[] elements >= arg2.array[arg2.pos]
arg2.array[] elements <= arg2.array[arg2.pos-1]
orig(arg2.array[post(arg2.pos)-1]) in arg2.array[]
arg2.pos >= orig(arg2.pos)
arg2.pos < size(arg2.array[])-1
arg2.pos > arg2.array[arg2.pos]
arg2.pos > arg2.array[orig(arg1)]
orig(arg1) <= size(arg2.array[])-1
orig(arg1) >= arg2.array[arg2.pos]
orig(arg1) >= arg2.array[arg2.pos-1]
orig(arg1) >= arg2.array[orig(arg1)]
orig(arg1) >= arg2.array[orig(arg2.pos)]
orig(arg1) >= orig(arg2.array[post(arg2.pos)-1])
orig(arg2.array[]) elements < size(arg2.array[])-1
orig(arg2.array[]) elements >= arg2.array[arg2.pos]
orig(arg2.array[]) elements <= arg2.array[arg2.pos-1]
orig(arg2.pos) < size(arg2.array[])-1
orig(arg2.pos) >= arg2.array[arg2.pos]
orig(arg2.pos) >= arg2.array[orig(arg1)]
size(arg2.array[])-1 >= arg2.array[arg2.pos-1]
size(arg2.array[])-1 > arg2.array[orig(arg1)]
size(arg2.array[])-1 >= arg2.array[orig(arg2.pos)]
size(arg2.array[])-1 > orig(arg2.array[post(arg2.pos)-1])
arg2.array[arg2.pos] <= arg2.array[arg2.pos-1]
arg2.array[arg2.pos] <= orig(arg2.array[post(arg2.pos)-1])
arg2.array[arg2.pos-1] >= arg2.array[orig(arg1)]
arg2.array[arg2.pos-1] >= arg2.array[orig(arg2.pos)]
arg2.array[orig(arg1)] <= arg2.array[orig(arg2.pos)]
arg2.array[arg2.pos-1] - arg2.array[orig(arg2.pos)] - orig(arg2.array[post(arg2.pos)-1]) == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl:::OBJECT
this.strategy.itemsWithoutStartChar.getClass().getName() == this.ignoredSymbols.getClass().getName()
this.strategy.itemsWithoutStartChar.getClass().getName() == this.input.lineLengths.getClass().getName()
this.ignoredSymbols.getClass().getName() == this.input.lineLengths.getClass().getName()
this.input.column == this.input.readOffset
this.input.line[this.input.column] == this.input.buffer[this.input.column]
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset]
this has only one value
this.strategy.itemsWithStartChar has only one value
this.strategy.itemsWithStartChar != null
this.strategy.itemsWithoutStartChar has only one value
this.strategy.itemsWithoutStartChar != null
this.strategy.itemsWithoutStartChar[] elements has only one value
this.strategy.itemsWithoutStartChar[] elements != null
this.strategy.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
this.strategy.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
this.strategy.itemsWithoutStartChar.getClass().getName() == java.util.ArrayList.class
this.strategy.competitiveGroups has only one value
this.strategy.competitiveGroups != null
this.strategy.competeForLongestInput == true
this.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.ignoredSymbols[] elements has only one value
this.ignoredSymbols[] elements != null
this.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.ignoredSymbols.getClass().getName() == java.util.ArrayList.class
this.charConsumers.getClass().getName() == java.util.Hashtable.class
this.input.line[] elements >= 0
this.input.prevLine == null
this.input.prevLength == 0
this.input.wasCr == false
this.input.column >= 0
this.input.lineLengths has only one value
this.input.lineLengths != null
this.input.lineLengths[] == []
this.input.lineLengths[].getClass().getName() == []
this.input.lineLengths.getClass().getName() == java.util.ArrayList.class
this.input.scanPoint[] one of { [1, 5], [1, 6], [1, 11] }
this.input.scanPoint[] elements >= 1
this.input.scanPoint[] sorted by <
this.input.inputStream == null
this.input.reader has only one value
this.input.reader != null
this.input.reader.getClass().getName() == java.io.StringReader.class
this.input.buffer[] elements >= 0
this.input.readPos == 0
this.input.readLen one of { 0, 1 }
this.listeners == null
this.debug == false
size(this.strategy.itemsWithoutStartChar[]) one of { 0, 1 }
size(this.ignoredSymbols[]) == 1
size(this.input.line[]) == 64
size(this.input.scanPoint[]) == 2
size(this.input.buffer[]) == 128
this.input.line[this.input.column] == 0
this.input.line[this.input.readPos] == 72
this.input.line[this.input.readLen] one of { 0, 72, 101 }
this.input.buffer[this.input.column-1] one of { 0, 72, 111 }
this.input.buffer[this.input.readPos] one of { 32, 72, 87 }
this.strategy.itemsWithoutStartChar.getClass().getName() != this.charConsumers.getClass().getName()
this.strategy.itemsWithoutStartChar.getClass().getName() != this.input.reader.getClass().getName()
this.ignoredSymbols.getClass().getName() != this.charConsumers.getClass().getName()
this.ignoredSymbols.getClass().getName() != this.input.reader.getClass().getName()
this.charConsumers.getClass().getName() != this.input.lineLengths.getClass().getName()
this.charConsumers.getClass().getName() != this.input.reader.getClass().getName()
this.input.line[] elements >= this.input.line[this.input.column]
this.input.buffer[this.input.column-1] in this.input.line[]
this.input.buffer[this.input.readPos] in this.input.line[]
this.input.buffer[this.input.readLen] in this.input.line[]
this.input.scanPoint[] elements <= this.input.column
this.input.column >= this.input.readPos
this.input.column >= this.input.readLen
this.input.column < size(this.input.line[])-1
this.input.column < size(this.input.buffer[])-1
this.input.lineLengths.getClass().getName() != this.input.reader.getClass().getName()
this.input.scanPoint[] elements > this.input.readPos
this.input.scanPoint[] elements >= this.input.readLen
this.input.scanPoint[] elements < size(this.input.line[])-1
this.input.scanPoint[] elements < size(this.input.buffer[])-1
this.input.buffer[] elements >= this.input.line[this.input.column]
this.input.line[this.input.column-1] in this.input.buffer[]
this.input.readPos <= this.input.readLen
this.input.readLen < size(this.input.line[])-1
this.input.readLen < size(this.input.buffer[])-1
this.input.line[this.input.column] < this.input.line[this.input.column-1]
this.input.line[this.input.column] <= this.input.line[this.input.readLen]
this.input.line[this.input.column] <= this.input.buffer[this.input.column-1]
this.input.line[this.input.column] < this.input.buffer[this.input.readPos]
this.input.line[this.input.column] <= this.input.buffer[this.input.readLen]
this.input.line[this.input.column-1] != this.input.line[this.input.readLen]
this.input.buffer[this.input.column-1] % this.input.line[this.input.column-1] == 0
this.input.line[this.input.column-1] >= this.input.buffer[this.input.column-1]
this.input.line[this.input.column-1] >= this.input.buffer[this.input.readPos]
this.input.line[this.input.readLen] != this.input.buffer[this.input.column-1]
this.input.buffer[this.input.column-1] != this.input.buffer[this.input.readLen]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.LexerImpl(java.util.List, java.util.Map):::ENTER
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg1.getClass().getName() == java.util.Hashtable.class
size(arg0[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.LexerImpl(java.util.List, java.util.Map):::EXIT
this.ignoredSymbols == orig(arg0)
this.ignoredSymbols.getClass().getName() == orig(arg0.getClass().getName())
this.charConsumers == orig(arg1)
this.charConsumers.getClass().getName() == orig(arg1.getClass().getName())
arg0[] == orig(arg0[])
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.clear():::ENTER
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
size(this.strategy.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.clear():::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
size(this.strategy.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.createToken(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.ResultTree, fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic):::ENTER
this.ignoredSymbols.getClass().getName() == arg1.sequenceList.getClass().getName()
this.input.readPos == this.input.readLen
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
arg0.toString one of { "\"Hello\"", "\"World\"" }
arg1.rule == null
arg1.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
arg1.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
arg1.stringResult == null
arg2 == null
size(this.strategy.itemsWithoutStartChar[]) == 1
size(arg1.sequenceList[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
this.input.column in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.createToken(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.ResultTree, fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic):::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == arg1.sequenceList.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg1.sequenceList.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.input.line == orig(this.input.line)
this.input.line[] == orig(this.input.line[])
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.column == orig(this.input.column)
this.input.column == orig(this.input.readOffset)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.scanPoint == orig(this.input.scanPoint)
this.input.scanPoint[] == orig(this.input.scanPoint[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.buffer == orig(this.input.buffer)
this.input.buffer[] == orig(this.input.buffer[])
this.input.readPos == this.input.readLen
this.input.readPos == orig(this.input.readPos)
this.input.readPos == orig(this.input.readLen)
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
arg0.toString == orig(arg0.toString)
arg1.rule == orig(arg1.rule)
arg1.sequenceList == orig(arg1.sequenceList)
arg1.sequenceList[] == orig(arg1.sequenceList[])
arg1.range == return.range
arg1.range == orig(arg1.range)
arg1.range.start == return.range.start
arg1.range.start == orig(arg1.range.start)
arg1.range.end == return.range.end
arg1.range.end == orig(arg1.range.end)
arg1.buffer == orig(arg1.buffer)
arg1.stringResult == return.text
return.symbol == orig(arg0)
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
arg0.toString one of { "\"Hello\"", "\"World\"" }
arg1.rule == null
arg1.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
arg1.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
arg1.stringResult.toString one of { "Hello", "World" }
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
return.symbol.toString one of { "\"Hello\"", "\"World\"" }
return.text.getClass().getName() == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
size(arg1.sequenceList[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
return.text.getClass().getName() in this.ignoredSymbols[].getClass().getName()
this.input.column in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.createToken(java.lang.String, java.lang.String, fri.patterns.interpreter.parsergenerator.Token$Range):::ENTER
this.input.column == arg2.end.column
this.input.column == arg2.end.offset
this.input.readPos == this.input.readLen
arg2.start.line == arg2.end.line
arg2.start.column == arg2.start.offset
this.input.line[this.input.column] == this.input.buffer[arg2.end.column]
this.input.line[this.input.column] == this.input.buffer[arg2.end.offset]
this.input.line[this.input.readPos] == this.input.line[arg2.start.line-1]
this.input.line[this.input.readPos] == this.input.line[arg2.end.line-1]
this.input.buffer[this.input.readPos] == this.input.buffer[arg2.start.line-1]
this.input.buffer[this.input.readPos] == this.input.buffer[arg2.end.line-1]
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
arg1.toString one of { "Hello", "World" }
arg2.start.line == 1
arg2.start.column one of { 0, 6, 11 }
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.line[arg2.start.line] == 101
this.input.line[arg2.start.column] one of { 0, 72, 87 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
this.input.buffer[arg2.start.line] one of { 101, 111 }
this.input.buffer[arg2.start.column] one of { 0, 72 }
this.input.buffer[arg2.start.line] in this.input.line[]
this.input.buffer[arg2.start.column] in this.input.line[]
this.input.column in this.input.scanPoint[]
arg2.start.line in this.input.scanPoint[]
this.input.line[arg2.start.column] in this.input.buffer[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.createToken(java.lang.String, java.lang.String, fri.patterns.interpreter.parsergenerator.Token$Range):::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.input.line == orig(this.input.line)
this.input.line[] == orig(this.input.line[])
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.column == arg2.end.column
this.input.column == arg2.end.offset
this.input.column == orig(this.input.column)
this.input.column == orig(this.input.readOffset)
this.input.column == orig(arg2.end.column)
this.input.column == orig(arg2.end.offset)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.scanPoint == orig(this.input.scanPoint)
this.input.scanPoint[] == orig(this.input.scanPoint[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.buffer == orig(this.input.buffer)
this.input.buffer[] == orig(this.input.buffer[])
this.input.readPos == this.input.readLen
this.input.readPos == orig(this.input.readPos)
this.input.readPos == orig(this.input.readLen)
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
arg0.toString == orig(arg0.toString)
arg1.toString == orig(arg1.toString)
arg2.start == return.range.start
arg2.start == orig(arg2.start)
arg2.start.line == arg2.end.line
arg2.start.line == orig(arg2.start.line)
arg2.start.line == orig(arg2.end.line)
arg2.start.column == arg2.start.offset
arg2.start.column == orig(arg2.start.column)
arg2.start.column == orig(arg2.start.offset)
arg2.end == return.range.end
arg2.end == orig(arg2.end)
return.symbol == orig(arg0)
return.text == orig(arg1)
return.range == orig(arg2)
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == this.input.buffer[arg2.end.column]
this.input.line[this.input.column] == this.input.buffer[arg2.end.offset]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == this.input.buffer[orig(arg2.end.column)]
this.input.line[this.input.column] == this.input.buffer[orig(arg2.end.offset)]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[post(arg2.end.column)])
this.input.line[this.input.column] == orig(this.input.buffer[post(arg2.end.offset)])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.input.line[this.input.column] == orig(this.input.buffer[arg2.end.column])
this.input.line[this.input.column] == orig(this.input.buffer[arg2.end.offset])
this.input.line[this.input.readPos] == this.input.line[arg2.start.line-1]
this.input.line[this.input.readPos] == this.input.line[arg2.end.line-1]
this.input.line[this.input.readPos] == this.input.line[orig(arg2.start.line)-1]
this.input.line[this.input.readPos] == this.input.line[orig(arg2.end.line)-1]
this.input.line[this.input.readPos] == orig(this.input.line[post(arg2.start.line)-1])
this.input.line[this.input.readPos] == orig(this.input.line[post(arg2.end.line)-1])
this.input.line[this.input.readPos] == orig(this.input.line[arg2.start.line-1])
this.input.line[this.input.readPos] == orig(this.input.line[arg2.end.line-1])
this.input.buffer[this.input.readPos] == this.input.buffer[arg2.start.line-1]
this.input.buffer[this.input.readPos] == this.input.buffer[arg2.end.line-1]
this.input.buffer[this.input.readPos] == this.input.buffer[orig(arg2.start.line)-1]
this.input.buffer[this.input.readPos] == this.input.buffer[orig(arg2.end.line)-1]
this.input.buffer[this.input.readPos] == orig(this.input.buffer[post(arg2.start.line)-1])
this.input.buffer[this.input.readPos] == orig(this.input.buffer[post(arg2.end.line)-1])
this.input.buffer[this.input.readPos] == orig(this.input.buffer[arg2.start.line-1])
this.input.buffer[this.input.readPos] == orig(this.input.buffer[arg2.end.line-1])
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
arg1.toString one of { "Hello", "World" }
arg2.start.line == 1
arg2.start.column one of { 0, 6, 11 }
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
return.symbol.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
return.text.getClass().getName() == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.line[arg2.start.line] == 101
this.input.line[arg2.start.column] one of { 0, 72, 87 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
this.input.buffer[arg2.start.line] one of { 101, 111 }
this.input.buffer[arg2.start.column] one of { 0, 72 }
return.text.getClass().getName() in this.ignoredSymbols[].getClass().getName()
this.input.buffer[arg2.start.line] in this.input.line[]
this.input.buffer[arg2.start.column] in this.input.line[]
this.input.column in this.input.scanPoint[]
arg2.start.line in this.input.scanPoint[]
this.input.line[arg2.start.column] in this.input.buffer[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.ensureStrategy():::ENTER
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
size(this.strategy.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.ensureStrategy():::EXIT
this.strategy == return
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == return.itemsWithStartChar
this.strategy.itemsWithoutStartChar == return.itemsWithoutStartChar
this.strategy.itemsWithoutStartChar[].getClass().getName() == orig(this.strategy.itemsWithoutStartChar[].getClass().getName())
this.strategy.competitiveGroups == return.competitiveGroups
this.strategy.competeForLongestInput == return.competeForLongestInput
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == return.itemsWithoutStartChar.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
return.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
return.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
return.competitiveGroups == orig(this.strategy.competitiveGroups)
return.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.strategy.inited == false
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
return has only one value
return.inited == false
return.itemsWithStartChar has only one value
return.itemsWithoutStartChar has only one value
return.itemsWithoutStartChar[] elements has only one value
return.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
return.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
return.competitiveGroups has only one value
return.competeForLongestInput == true
size(return.itemsWithoutStartChar[]) one of { 0, 1 }
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[]) (elementwise)
this.strategy.itemsWithoutStartChar[] is the reverse of orig(this.strategy.itemsWithoutStartChar[])
this.strategy.itemsWithoutStartChar[].getClass().getName() == orig(this.strategy.itemsWithoutStartChar[].getClass().getName()) (elementwise)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.fireTokenReceived(fri.patterns.interpreter.parsergenerator.Token, boolean):::ENTER
this.input.readPos == this.input.readLen
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg0.symbol.toString one of { "\"Hello\"", "\"World\"" }
arg0.text.getClass().getName() == java.lang.String.class
arg1 == false
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
arg0.text.getClass().getName() in this.ignoredSymbols[].getClass().getName()
this.input.column in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.fireTokenReceived(fri.patterns.interpreter.parsergenerator.Token, boolean):::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.input.line == orig(this.input.line)
this.input.line[] == orig(this.input.line[])
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.column == orig(this.input.column)
this.input.column == orig(this.input.readOffset)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.scanPoint == orig(this.input.scanPoint)
this.input.scanPoint[] == orig(this.input.scanPoint[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.buffer == orig(this.input.buffer)
this.input.buffer[] == orig(this.input.buffer[])
this.input.readPos == this.input.readLen
this.input.readPos == orig(this.input.readPos)
this.input.readPos == orig(this.input.readLen)
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
fri.patterns.interpreter.parsergenerator.Token.EPSILON == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON)
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == orig(fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString)
fri.patterns.interpreter.parsergenerator.Token.UPTO == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO)
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == orig(fri.patterns.interpreter.parsergenerator.Token.UPTO.toString)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT)
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == orig(fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString)
fri.patterns.interpreter.parsergenerator.Token.TOKEN == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN)
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == orig(fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString)
fri.patterns.interpreter.parsergenerator.Token.IGNORED == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED)
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == orig(fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER)
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == orig(fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString)
arg0.symbol == orig(arg0.symbol)
arg0.symbol.toString == orig(arg0.symbol.toString)
arg0.text == orig(arg0.text)
arg0.text.getClass().getName() == orig(arg0.text.getClass().getName())
arg0.range == orig(arg0.range)
arg0.range.start == orig(arg0.range.start)
arg0.range.end == orig(arg0.range.end)
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
arg0.symbol.toString one of { "\"Hello\"", "\"World\"" }
arg0.text.getClass().getName() == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
arg0.text.getClass().getName() in this.ignoredSymbols[].getClass().getName()
this.input.column in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextLexerItem(java.util.Map, int):::ENTER
this.charConsumers.getClass().getName() == arg0.getClass().getName()
arg1 == this.input.buffer[this.input.readPos]
this.input.line[this.input.column-1] == this.input.buffer[this.input.readPos]
this.input.line[this.input.readPos] == this.input.line[this.input.readLen-1]
this.input.line[this.input.readOffset-1] == this.input.buffer[this.input.readPos]
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen-1]
this.strategy has only one value
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 1, 6, 7 }
this.input.scanPoint == null
this.input.buffer has only one value
this.input.buffer[] one of { [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.readLen == 1
this.input.eof == false
this.input.buffering == true
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.readLen] one of { 0, 101 }
this.input.buffer[this.input.column-1] one of { 0, 72 }
this.input.buffer[this.input.readLen] one of { 0, 87, 101 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextLexerItem(java.util.Map, int):::EXIT
this.strategy == orig(this.strategy)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == return.consumer.sequence.getClass().getName()
this.ignoredSymbols.getClass().getName() == return.result.sequenceList.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.charConsumers.getClass().getName() == orig(arg0.getClass().getName())
this.input == orig(this.input)
this.input.line == orig(this.input.line)
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.buffer == orig(this.input.buffer)
this.input.readPos == orig(this.input.readPos)
this.input.eof == orig(this.input.eof)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
return.consumer.rule == return.result.rule
orig(arg1) == this.input.line[orig(this.input.column)-1]
orig(arg1) == this.input.line[orig(this.input.readOffset)-1]
orig(arg1) == orig(this.input.buffer[post(this.input.readPos)])
orig(arg1) == orig(this.input.line[this.input.column-1])
orig(arg1) == orig(this.input.line[this.input.readOffset-1])
orig(arg1) == orig(this.input.buffer[this.input.readLen-1])
size(this.input.line[]) == orig(size(this.input.line[]))
size(this.input.buffer[]) == orig(size(this.input.buffer[]))
this.input.line[this.input.column] == orig(this.input.line[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.line[post(this.input.column)-1])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)-1])
this.input.line[this.input.column] == orig(this.input.line[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.line[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.line[this.input.column])
this.input.line[this.input.column] == orig(this.input.line[this.input.readOffset])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.input.line[this.input.readPos] == this.input.line[orig(this.input.readLen)-1]
this.input.line[this.input.readPos] == orig(this.input.line[post(this.input.readPos)])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readPos])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readLen-1])
this.input.line[this.input.readLen] == orig(this.input.line[post(this.input.readLen)])
this.input.line[orig(this.input.column)] == this.input.buffer[orig(this.input.readLen)]
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen]
this.input.buffer[this.input.readPos] == this.input.buffer[orig(this.input.readLen)-1]
this.input.buffer[orig(this.input.column)-1] == orig(this.input.buffer[this.input.column-1])
this.input.buffer[orig(this.input.column)-1] == orig(this.input.buffer[this.input.readOffset-1])
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 7, 11 }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
return.symbol.toString one of { "\"Hello\"", "\"World\"", "whitespaces" }
return.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
return.consumer.constraints == null
return.consumer.nullable == false
return.consumer.fixedLength == -1
return.consumer.startLength == -1
return.consumer.variance == -1
return.result.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.result.stringResult == null
orig(arg1) one of { 32, 72, 87 }
size(this.strategy.itemsWithoutStartChar[]) == 1
size(return.consumer.sequence[]) == 1
size(return.result.sequenceList[]) == 1
this.input.line[this.input.column-1] one of { 87, 100, 111 }
this.input.line[this.input.readLen] one of { 72, 101 }
this.input.line[orig(this.input.column)] one of { 87, 101, 111 }
this.input.line[orig(this.input.readLen)] == 101
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
this.input.buffer[orig(this.input.column)] one of { 0, 101 }
this.input.buffer[orig(this.input.column)-1] one of { 0, 72 }
orig(this.input.buffer[post(this.input.readLen)]) one of { 72, 87, 101 }
this.input.buffer[orig(this.input.column)] in this.input.line[]
this.input.buffer[orig(this.input.column)-1] in this.input.line[]
orig(this.input.buffer[post(this.input.readLen)]) in this.input.line[]
orig(this.input.line[this.input.readLen]) in this.input.line[]
orig(this.input.buffer[this.input.readLen]) in this.input.line[]
orig(this.input.readLen) in this.input.scanPoint[]
this.input.buffer[orig(this.input.column)-1] in orig(this.input.line[])
orig(this.input.buffer[post(this.input.readLen)]) in orig(this.input.line[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic, java.util.Map):::ENTER
this.charConsumers.getClass().getName() == arg1.getClass().getName()
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen]
this.strategy has only one value
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
arg0 == null
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 87, 100, 111 }
this.input.line[this.input.readLen] one of { 72, 101 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic, java.util.Map):::EXIT189
this.strategy.inited == orig(this.strategy.inited)
this.input.line == orig(this.input.line)
this.input.line[] == orig(this.input.line[])
this.input.column == orig(this.input.column)
this.input.column == orig(this.input.readOffset)
this.input.buffer == orig(this.input.buffer)
this.input.buffer[] == orig(this.input.buffer[])
this.input.readPos == orig(this.input.readLen)
fri.patterns.interpreter.parsergenerator.Token.EPSILON == return.symbol
return.range.start == return.range.end
this.input.line[this.input.column] == this.input.buffer[this.input.column-1]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)-1])
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset-1]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)-1]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)-1]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column-1])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset-1])
this.input.line[] == [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.column == 11
this.input.scanPoint == null
this.input.buffer[] == [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.eof == true
this.input.buffering == true
return has only one value
return.symbol.toString == "\"EoI\""
return.text == null
return.range has only one value
return.range.start has only one value
orig(this.input.scanPoint) has only one value
orig(this.input.scanPoint[]) == [1, 11]
orig(this.input.scanPoint[]) elements one of { 1, 11 }
orig(arg1) has only one value
this.input.line[this.input.column-1] == 100
this.input.buffer[this.input.readPos] == 87
this.input.column in orig(this.input.scanPoint[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic, java.util.Map):::EXIT198
this.strategy.inited == orig(this.strategy.inited)
this.input.line == orig(this.input.line)
this.input.buffer == orig(this.input.buffer)
this.input.readPos == orig(this.input.readLen)
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.input.line[this.input.column] == this.input.buffer[this.input.column-1]
this.input.line[this.input.column] == orig(this.input.line[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.line[post(this.input.column)-1])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)-1])
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset-1]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == orig(this.input.line[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.line[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.line[this.input.readOffset])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.input.line[this.input.column-1] == this.input.buffer[orig(this.input.column)-1]
this.input.line[this.input.column-1] == this.input.buffer[orig(this.input.readOffset)-1]
this.input.line[this.input.readPos] == orig(this.input.line[post(this.input.readPos)])
this.input.line[this.input.readPos] == orig(this.input.buffer[post(this.input.readPos)])
this.input.line[this.input.readPos] == orig(this.input.line[post(this.input.readLen)])
this.input.line[this.input.readPos] == orig(this.input.buffer[post(this.input.readLen)])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readLen])
this.input.line[this.input.readPos] == orig(this.input.buffer[this.input.readPos])
this.input.line[this.input.readPos] == orig(this.input.buffer[this.input.readLen])
this.input.line[orig(this.input.column)-1] == orig(this.input.line[this.input.column-1])
this.input.line[orig(this.input.column)-1] == orig(this.input.line[this.input.readOffset-1])
this.input.line[orig(this.input.column)-1] == orig(this.input.buffer[this.input.column-1])
this.input.line[orig(this.input.column)-1] == orig(this.input.buffer[this.input.readOffset-1])
this.input.line[] == [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.column == 11
this.input.scanPoint has only one value
this.input.scanPoint[] == [1, 11]
this.input.scanPoint[] elements one of { 1, 11 }
this.input.buffer[] == [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.eof == false
this.input.buffering == false
return has only one value
return.symbol has only one value
return.symbol.toString == "\"World\""
return.text has only one value
return.range has only one value
return.range.start has only one value
return.range.end has only one value
orig(this.input.line[]) == [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
orig(this.input.column) == 5
orig(this.input.scanPoint) has only one value
orig(this.input.scanPoint[]) == [1, 5]
orig(this.input.scanPoint[]) elements one of { 1, 5 }
orig(this.input.buffer[]) == [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
orig(arg1) has only one value
this.input.line[this.input.column-1] == 100
this.input.line[orig(this.input.column)] == 32
this.input.line[orig(this.input.column)-1] == 111
this.input.buffer[this.input.readPos] == 87
this.input.line[orig(this.input.column)-1] in this.input.buffer[]
orig(this.input.column) in orig(this.input.scanPoint[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic, java.util.Map):::EXIT203
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.input.line[orig(this.input.column)] == this.input.buffer[orig(this.input.readLen)]
orig(this.input.line[post(this.input.column)-1]) == orig(this.input.line[this.input.column])
this.input.buffer[this.input.readPos] == orig(this.input.buffer[this.input.readPos])
orig(this.input.line[post(this.input.readOffset)-1]) == orig(this.input.line[this.input.column])
orig(this.input.line[this.input.column]) == orig(this.input.buffer[this.input.column-1])
orig(this.input.line[this.input.column]) == orig(this.input.buffer[this.input.readOffset-1])
orig(this.input.line[this.input.column-1]) == orig(this.input.buffer[this.input.readPos])
orig(this.input.line[this.input.readPos]) == orig(this.input.line[this.input.readLen-1])
orig(this.input.line[this.input.readOffset-1]) == orig(this.input.buffer[this.input.readPos])
orig(this.input.buffer[this.input.readPos]) == orig(this.input.buffer[this.input.readLen-1])
this.input.eof == false
this.input.buffering == false
return.symbol.toString one of { "\"Hello\"", "\"World\"" }
orig(this.input.line[]) == [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
orig(this.input.column) one of { 0, 7 }
orig(this.input.scanPoint[]) == [1, 6]
orig(this.input.scanPoint[]) elements one of { 1, 6 }
orig(this.input.buffer[]) == [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.line[orig(this.input.column)] one of { 72, 111 }
orig(this.input.line[this.input.readLen]) == 101
orig(this.input.buffer[this.input.readPos]) == 87
orig(this.input.buffer[this.input.readPos]) in this.input.buffer[]
this.input.line[orig(this.input.column)] in orig(this.input.line[])
this.input.buffer[this.input.readPos] in orig(this.input.line[])
orig(this.input.readLen) in orig(this.input.scanPoint[])
this.input.line[orig(this.input.column)] in orig(this.input.buffer[])
this.input.buffer[this.input.readPos] in orig(this.input.buffer[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(fri.patterns.interpreter.parsergenerator.lexer.LexerSemantic, java.util.Map):::EXIT
this.strategy == orig(this.strategy)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.charConsumers.getClass().getName() == orig(arg1.getClass().getName())
this.input == orig(this.input)
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.readPos == this.input.readLen
this.input.readPos == orig(this.input.readPos)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
size(this.input.line[]) == orig(size(this.input.line[]))
size(this.input.scanPoint[]) == orig(size(this.input.scanPoint[]))
size(this.input.buffer[]) == orig(size(this.input.buffer[]))
this.input.line[this.input.column] == orig(this.input.line[this.input.column])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readPos])
this.input.line[orig(this.input.readLen)] == orig(this.input.line[this.input.readLen])
this.input.buffer[this.input.column-1] == orig(this.input.line[this.input.column])
orig(this.input.line[post(this.input.column)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.column)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.column)-1]) == orig(this.input.line[this.input.column])
this.input.buffer[orig(this.input.column)] == orig(this.input.line[this.input.column])
orig(this.input.line[post(this.input.readOffset)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.readOffset)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.readOffset)-1]) == orig(this.input.line[this.input.column])
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
return.symbol.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
return.text.getClass().getName() == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.line[orig(this.input.readLen)] one of { 72, 101 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
orig(this.input.line[post(this.input.column)-1]) one of { 0, 100 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
this.input.buffer[orig(this.input.column)] one of { 0, 72 }
this.input.buffer[orig(this.input.readLen)] one of { 72, 87, 111 }
return.text.getClass().getName() in this.ignoredSymbols[].getClass().getName()
orig(this.input.line[post(this.input.column)-1]) in this.input.line[]
this.input.buffer[orig(this.input.column)] in this.input.line[]
this.input.buffer[orig(this.input.readLen)] in this.input.line[]
orig(this.input.line[this.input.column]) in this.input.line[]
orig(this.input.line[this.input.column-1]) in this.input.line[]
orig(this.input.line[this.input.readPos]) in this.input.line[]
orig(this.input.line[this.input.readLen]) in this.input.line[]
orig(this.input.buffer[this.input.column-1]) in this.input.line[]
orig(this.input.buffer[this.input.readPos]) in this.input.line[]
this.input.column in this.input.scanPoint[]
orig(this.input.line[post(this.input.column)-1]) in this.input.buffer[]
orig(this.input.line[this.input.column]) in this.input.buffer[]
orig(this.input.line[this.input.column-1]) in this.input.buffer[]
orig(this.input.buffer[this.input.column-1]) in this.input.buffer[]
this.input.line[this.input.column] in orig(this.input.line[])
this.input.line[this.input.readPos] in orig(this.input.line[])
this.input.line[orig(this.input.readLen)] in orig(this.input.line[])
this.input.buffer[this.input.column-1] in orig(this.input.line[])
this.input.buffer[orig(this.input.column)] in orig(this.input.line[])
this.input.line[this.input.column] in orig(this.input.buffer[])
this.input.buffer[this.input.column-1] in orig(this.input.buffer[])
orig(this.input.line[post(this.input.column)-1]) in orig(this.input.buffer[])
this.input.buffer[orig(this.input.column)] in orig(this.input.buffer[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(java.util.Map):::ENTER
this.charConsumers.getClass().getName() == arg0.getClass().getName()
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen]
this.strategy has only one value
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.eof == false
this.input.buffering == false
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 87, 100, 111 }
this.input.line[this.input.readLen] one of { 72, 101 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.getNextToken(java.util.Map):::EXIT
this.strategy == orig(this.strategy)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.charConsumers.getClass().getName() == orig(arg0.getClass().getName())
this.input == orig(this.input)
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.readPos == this.input.readLen
this.input.readPos == orig(this.input.readPos)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
size(this.input.line[]) == orig(size(this.input.line[]))
size(this.input.scanPoint[]) == orig(size(this.input.scanPoint[]))
size(this.input.buffer[]) == orig(size(this.input.buffer[]))
this.input.line[this.input.column] == orig(this.input.line[this.input.column])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readPos])
this.input.line[orig(this.input.readLen)] == orig(this.input.line[this.input.readLen])
this.input.buffer[this.input.column-1] == orig(this.input.line[this.input.column])
orig(this.input.line[post(this.input.column)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.column)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.column)-1]) == orig(this.input.line[this.input.column])
this.input.buffer[orig(this.input.column)] == orig(this.input.line[this.input.column])
orig(this.input.line[post(this.input.readOffset)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.readOffset)]) == orig(this.input.line[this.input.column])
orig(this.input.buffer[post(this.input.readOffset)-1]) == orig(this.input.line[this.input.column])
this.strategy has only one value
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line has only one value
this.input.line[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.input.column one of { 5, 11 }
this.input.scanPoint[] elements one of { 1, 5, 11 }
this.input.scanPoint[] one of { [1, 5], [1, 11] }
this.input.buffer has only one value
this.input.buffer[] one of { [72, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 111, 114, 108, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
fri.patterns.interpreter.parsergenerator.Token.EPSILON has only one value
fri.patterns.interpreter.parsergenerator.Token.EPSILON.toString == "\"EoI\""
fri.patterns.interpreter.parsergenerator.Token.UPTO has only one value
fri.patterns.interpreter.parsergenerator.Token.UPTO.toString == ".."
fri.patterns.interpreter.parsergenerator.Token.BUTNOT has only one value
fri.patterns.interpreter.parsergenerator.Token.BUTNOT.toString == "-"
fri.patterns.interpreter.parsergenerator.Token.TOKEN has only one value
fri.patterns.interpreter.parsergenerator.Token.TOKEN.toString == "token"
fri.patterns.interpreter.parsergenerator.Token.IGNORED has only one value
fri.patterns.interpreter.parsergenerator.Token.IGNORED.toString == "ignored"
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER has only one value
fri.patterns.interpreter.parsergenerator.Token.ARTIFICIAL_NONTERMINAL_START_CHARACTER.toString == "_"
return.symbol.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
return.text.getClass().getName() == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.column-1] one of { 100, 111 }
this.input.line[orig(this.input.readLen)] one of { 72, 101 }
this.input.buffer[this.input.column-1] one of { 0, 111 }
orig(this.input.line[post(this.input.column)-1]) one of { 0, 100 }
this.input.buffer[this.input.readPos] one of { 72, 87 }
this.input.buffer[orig(this.input.column)] one of { 0, 72 }
this.input.buffer[orig(this.input.readLen)] one of { 72, 87, 111 }
return.text.getClass().getName() in this.ignoredSymbols[].getClass().getName()
orig(this.input.line[post(this.input.column)-1]) in this.input.line[]
this.input.buffer[orig(this.input.column)] in this.input.line[]
this.input.buffer[orig(this.input.readLen)] in this.input.line[]
orig(this.input.line[this.input.column]) in this.input.line[]
orig(this.input.line[this.input.column-1]) in this.input.line[]
orig(this.input.line[this.input.readPos]) in this.input.line[]
orig(this.input.line[this.input.readLen]) in this.input.line[]
orig(this.input.buffer[this.input.column-1]) in this.input.line[]
orig(this.input.buffer[this.input.readPos]) in this.input.line[]
this.input.column in this.input.scanPoint[]
orig(this.input.line[post(this.input.column)-1]) in this.input.buffer[]
orig(this.input.line[this.input.column]) in this.input.buffer[]
orig(this.input.line[this.input.column-1]) in this.input.buffer[]
orig(this.input.buffer[this.input.column-1]) in this.input.buffer[]
this.input.line[this.input.column] in orig(this.input.line[])
this.input.line[this.input.readPos] in orig(this.input.line[])
this.input.line[orig(this.input.readLen)] in orig(this.input.line[])
this.input.buffer[this.input.column-1] in orig(this.input.line[])
this.input.buffer[orig(this.input.column)] in orig(this.input.line[])
this.input.line[this.input.column] in orig(this.input.buffer[])
this.input.buffer[this.input.column-1] in orig(this.input.buffer[])
orig(this.input.line[post(this.input.column)-1]) in orig(this.input.buffer[])
this.input.buffer[orig(this.input.column)] in orig(this.input.buffer[])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.newStrategy():::ENTER
this.input.line[this.input.column] == this.input.buffer[this.input.column-1]
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset-1]
this.input.line[this.input.column-1] == this.input.buffer[this.input.readPos]
this.input.line[this.input.readPos] == this.input.line[this.input.readLen-1]
this.input.line[this.input.readLen] == this.input.buffer[this.input.readLen]
this.input.line[this.input.readOffset-1] == this.input.buffer[this.input.readPos]
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen-1]
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input.line has only one value
this.input.line[] == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.column == 6
this.input.scanPoint[] == [1, 5]
this.input.scanPoint[] elements one of { 1, 5 }
this.input.buffer has only one value
this.input.buffer[] == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.readLen == 1
this.input.eof == false
this.input.buffering == true
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.readLen] == 101
this.input.buffer[this.input.readPos] == 32
this.input.readLen in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.newStrategy():::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.itemsWithoutStartChar.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.strategy.itemsWithoutStartChar.getClass().getName() == orig(this.input.lineLengths.getClass().getName())
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == return.itemsWithoutStartChar.getClass().getName()
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.input.line == orig(this.input.line)
this.input.line[] == orig(this.input.line[])
this.input.prevLine == orig(this.input.prevLine)
this.input.prevLength == orig(this.input.prevLength)
this.input.wasCr == orig(this.input.wasCr)
this.input.column == orig(this.input.column)
this.input.column == orig(this.input.readOffset)
this.input.lineLengths == orig(this.input.lineLengths)
this.input.lineLengths[] == orig(this.input.lineLengths[])
this.input.scanPoint == orig(this.input.scanPoint)
this.input.scanPoint[] == orig(this.input.scanPoint[])
this.input.inputStream == orig(this.input.inputStream)
this.input.reader == orig(this.input.reader)
this.input.reader.getClass().getName() == orig(this.input.reader.getClass().getName())
this.input.buffer == orig(this.input.buffer)
this.input.buffer[] == orig(this.input.buffer[])
this.input.readPos == orig(this.input.readPos)
this.input.readLen == orig(this.input.readLen)
this.input.eof == orig(this.input.eof)
this.input.buffering == orig(this.input.buffering)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
this.input.line[this.input.column] == this.input.buffer[this.input.column-1]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.column)-1])
this.input.line[this.input.column] == this.input.buffer[this.input.readOffset-1]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.column)-1]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)]
this.input.line[this.input.column] == this.input.buffer[orig(this.input.readOffset)-1]
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)])
this.input.line[this.input.column] == orig(this.input.buffer[post(this.input.readOffset)-1])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.column-1])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset])
this.input.line[this.input.column] == orig(this.input.buffer[this.input.readOffset-1])
this.input.line[this.input.column-1] == this.input.buffer[this.input.readPos]
this.input.line[this.input.readPos] == this.input.line[this.input.readLen-1]
this.input.line[this.input.readPos] == this.input.line[orig(this.input.readLen)-1]
this.input.line[this.input.readPos] == orig(this.input.line[post(this.input.readLen)-1])
this.input.line[this.input.readPos] == orig(this.input.line[this.input.readLen-1])
this.input.line[this.input.readLen] == this.input.buffer[this.input.readLen]
this.input.line[this.input.readLen] == this.input.buffer[orig(this.input.readLen)]
this.input.line[this.input.readLen] == orig(this.input.buffer[post(this.input.readLen)])
this.input.line[this.input.readLen] == orig(this.input.buffer[this.input.readLen])
this.input.line[this.input.readOffset-1] == this.input.buffer[this.input.readPos]
this.input.line[orig(this.input.column)-1] == this.input.buffer[this.input.readPos]
this.input.line[orig(this.input.readOffset)-1] == this.input.buffer[this.input.readPos]
orig(this.input.line[post(this.input.column)-1]) == this.input.buffer[this.input.readPos]
this.input.buffer[this.input.readPos] == this.input.buffer[this.input.readLen-1]
this.input.buffer[this.input.readPos] == this.input.buffer[orig(this.input.readLen)-1]
this.input.buffer[this.input.readPos] == orig(this.input.buffer[post(this.input.readLen)-1])
this.input.buffer[this.input.readPos] == orig(this.input.line[post(this.input.readOffset)-1])
this.input.buffer[this.input.readPos] == orig(this.input.line[this.input.column-1])
this.input.buffer[this.input.readPos] == orig(this.input.line[this.input.readOffset-1])
this.input.buffer[this.input.readPos] == orig(this.input.buffer[this.input.readLen-1])
this.strategy.inited == true
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input.line has only one value
this.input.line[] == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.column == 6
this.input.scanPoint[] == [1, 5]
this.input.scanPoint[] elements one of { 1, 5 }
this.input.buffer has only one value
this.input.buffer[] == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
this.input.readLen == 1
this.input.eof == false
this.input.buffering == true
return.inited == false
return.itemsWithoutStartChar[] == []
return.itemsWithoutStartChar[].getClass().getName() == []
return.competeForLongestInput == true
size(this.strategy.itemsWithoutStartChar[]) == 1
this.input.line[this.input.readLen] == 101
this.input.buffer[this.input.readPos] == 32
this.input.readLen in this.input.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.setConsumers(java.util.List, java.util.Map):::ENTER
this.strategy == null
this.ignoredSymbols == null
this.charConsumers == null
this.input == null
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg1.getClass().getName() == java.util.Hashtable.class
size(arg0[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.setConsumers(java.util.List, java.util.Map):::EXIT
this.ignoredSymbols == orig(arg0)
this.ignoredSymbols.getClass().getName() == orig(arg0.getClass().getName())
this.charConsumers == orig(arg1)
this.charConsumers.getClass().getName() == orig(arg1.getClass().getName())
this.input == orig(this.input)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
arg0[] == orig(arg0[])
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.setInput(java.lang.Object):::ENTER
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
arg0 has only one value
arg0.getClass().getName() == java.lang.String.class
size(this.strategy.itemsWithoutStartChar[]) == 1
arg0.getClass().getName() in this.ignoredSymbols[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.setInput(java.lang.Object):::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input.line == this.input.buffer
this.input.column == this.input.readPos
this.input.column == this.input.readLen
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input has only one value
this.input.line == null
this.input.column == 0
this.input.scanPoint == null
this.input.eof == false
this.input.buffering == false
size(this.strategy.itemsWithoutStartChar[]) == 1
orig(arg0.getClass().getName()) in this.ignoredSymbols[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.setTerminals(java.util.List):::ENTER
this.ignoredSymbols.getClass().getName() == arg0.getClass().getName()
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
arg0[].getClass().getName() elements == java.lang.String.class
arg0[].getClass().getName() one of { [], [java.lang.String, java.lang.String] }
size(this.strategy.itemsWithoutStartChar[]) == 1
size(arg0[]) one of { 0, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.LexerImpl.setTerminals(java.util.List):::EXIT
this.strategy == orig(this.strategy)
this.strategy.inited == orig(this.strategy.inited)
this.strategy.itemsWithStartChar == orig(this.strategy.itemsWithStartChar)
this.strategy.itemsWithoutStartChar == orig(this.strategy.itemsWithoutStartChar)
this.strategy.itemsWithoutStartChar[] == orig(this.strategy.itemsWithoutStartChar[])
this.strategy.competitiveGroups == orig(this.strategy.competitiveGroups)
this.strategy.competeForLongestInput == orig(this.strategy.competeForLongestInput)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == orig(this.strategy.itemsWithoutStartChar.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.ignoredSymbols.getClass().getName() == orig(arg0.getClass().getName())
this.charConsumers == orig(this.charConsumers)
this.charConsumers.getClass().getName() == orig(this.charConsumers.getClass().getName())
this.input == orig(this.input)
this.listeners == orig(this.listeners)
this.debug == orig(this.debug)
arg0[] == orig(arg0[])
this.strategy has only one value
this.strategy.inited == false
this.strategy.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.strategy.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.ignoredSymbols has only one value
this.charConsumers has only one value
this.input == null
arg0[].getClass().getName() elements == java.lang.String.class
arg0[].getClass().getName() one of { [], [java.lang.String, java.lang.String] }
size(this.strategy.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree:::OBJECT
this.rule.symbols.getClass().getName() == this.sequenceList.getClass().getName()
this.rule.symbols != null
this.rule.symbols[] elements != null
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.sequenceList[] elements != null
this.sequenceList.getClass().getName() == java.util.ArrayList.class
this.range.start != null
this.range.start.line == 1
this.range.start.column one of { 0, 5, 6 }
this.range.start.offset one of { 0, 5, 6 }
this.range.end != null
this.range.end.line == 1
this.range.end.column one of { 5, 6, 11 }
this.range.end.offset one of { 5, 6, 11 }
this.stringResult.toString one of { "Hello", "World" }
size(this.rule.symbols[]) == 2
size(this.sequenceList[]) one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.ResultTree(fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols.getClass().getName() == java.util.ArrayList.class
size(arg0.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.ResultTree(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.rule == orig(arg0)
this.rule.symbols == arg0.symbols
this.rule.symbols.getClass().getName() == arg0.symbols.getClass().getName()
arg0.symbols == orig(arg0.symbols)
arg0.symbols[] == orig(arg0.symbols[])
arg0.symbols.getClass().getName() == orig(arg0.symbols.getClass().getName())
this.sequenceList == null
this.range == null
this.buffer == null
this.stringResult == null
arg0.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols.getClass().getName() == java.util.ArrayList.class
size(arg0.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.addChild(fri.patterns.interpreter.parsergenerator.lexer.ResultTree):::ENTER
this.rule.symbols.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == arg0.sequenceList.getClass().getName()
this.sequenceList == null
this.range == null
this.buffer == null
this.stringResult == null
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
arg0.stringResult == null
size(arg0.rule.symbols[]) == 2
size(arg0.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.addChild(fri.patterns.interpreter.parsergenerator.lexer.ResultTree):::EXIT
this.rule == return.rule
this.rule == orig(this.rule)
this.rule.symbols == return.rule.symbols
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.sequenceList == return.sequenceList
this.sequenceList.getClass().getName() == arg0.rule.symbols.getClass().getName()
this.sequenceList.getClass().getName() == arg0.sequenceList.getClass().getName()
this.sequenceList.getClass().getName() == return.rule.symbols.getClass().getName()
this.sequenceList.getClass().getName() == return.sequenceList.getClass().getName()
this.sequenceList.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
this.sequenceList.getClass().getName() == orig(arg0.sequenceList.getClass().getName())
this.range == orig(this.range)
this.buffer == orig(this.buffer)
this.stringResult == orig(this.stringResult)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.sequenceList == orig(arg0.sequenceList)
arg0.sequenceList[] == orig(arg0.sequenceList[])
arg0.range == orig(arg0.range)
arg0.range.start == orig(arg0.range.start)
arg0.range.end == orig(arg0.range.end)
arg0.buffer == orig(arg0.buffer)
arg0.stringResult == orig(arg0.stringResult)
return == orig(this)
this.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
this.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
this.range == null
this.buffer == null
this.stringResult == null
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
arg0.stringResult == null
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
return.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
return.range == null
return.buffer == null
return.stringResult == null
size(this.sequenceList[]) == 1
size(arg0.rule.symbols[]) == 2
size(arg0.sequenceList[]) == 1
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.append(java.lang.String):::ENTER
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList == null
this.range == null
this.buffer == null
this.stringResult == null
arg0.toString one of { " ", "Hello", "World" }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.append(java.lang.String):::EXIT
this.rule == return.rule
this.rule == orig(this.rule)
this.rule.symbols == return.rule.symbols
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList == return.sequenceList
this.sequenceList.getClass().getName() == return.sequenceList.getClass().getName()
this.range == orig(this.range)
this.buffer == return.buffer
this.stringResult == orig(this.stringResult)
arg0.toString == orig(arg0.toString)
return == orig(this)
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
this.range == null
this.stringResult == null
arg0.toString one of { " ", "Hello", "World" }
return.rule.symbols[] contains no nulls and has only one value, of length 2
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
return.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
return.range == null
return.stringResult == null
size(this.sequenceList[]) == 1
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.ensureSequenceList():::ENTER
this.sequenceList == null
this.range == null
this.stringResult == null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.ensureSequenceList():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == return.getClass().getName()
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList == return
this.sequenceList.getClass().getName() == return.getClass().getName()
this.range == orig(this.range)
this.buffer == orig(this.buffer)
this.stringResult == orig(this.stringResult)
this.sequenceList[] == []
this.sequenceList[].getClass().getName() == []
this.range == null
this.stringResult == null
return[] == []
return[].getClass().getName() == []
return.getClass().getName() == java.util.ArrayList.class
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.ensureStringBuffer(java.lang.String):::ENTER
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList == null
this.range == null
this.buffer == null
this.stringResult == null
arg0.toString one of { " ", "Hello", "World" }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.ensureStringBuffer(java.lang.String):::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.range == orig(this.range)
this.buffer == return
this.stringResult == orig(this.stringResult)
arg0.toString == orig(arg0.toString)
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
this.range == null
this.stringResult == null
arg0.toString one of { " ", "Hello", "World" }
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.getChildCount():::ENTER
this has only one value
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList has only one value
this.sequenceList[] contains no nulls and has only one value, of length 1
this.sequenceList[] elements has only one value
this.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
this.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
this.range == null
this.buffer == null
this.stringResult == null
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.getChildCount():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.sequenceList == orig(this.sequenceList)
this.sequenceList[] == orig(this.sequenceList[])
this.sequenceList.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList.getClass().getName() == orig(this.sequenceList.getClass().getName())
this.range == orig(this.range)
this.buffer == orig(this.buffer)
this.stringResult == orig(this.stringResult)
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList has only one value
this.sequenceList[] contains no nulls and has only one value, of length 1
this.sequenceList[] elements has only one value
this.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
this.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
this.range == null
this.buffer == null
this.stringResult == null
return == 1
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.getRange():::ENTER
this.range.start.line == this.range.end.line
this.range.start.column == this.range.start.offset
this.range.end.column == this.range.end.offset
this.rule == null
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
this.range.start.column one of { 0, 6 }
this.range.end.column one of { 5, 11 }
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.getRange():::EXIT
this.rule == orig(this.rule)
this.sequenceList == orig(this.sequenceList)
this.sequenceList[] == orig(this.sequenceList[])
this.sequenceList.getClass().getName() == orig(this.sequenceList.getClass().getName())
this.range == return
this.range.start == return.start
this.range.start.line == return.start.line
this.range.start.column == return.start.column
this.range.start.offset == return.start.column
this.range.end == return.end
this.range.end.line == return.start.line
this.range.end.column == return.end.column
this.range.end.offset == return.end.column
this.buffer == orig(this.buffer)
this.stringResult == orig(this.stringResult)
this.stringResult.toString == orig(this.stringResult.toString)
return == orig(this.range)
return.start == orig(this.range.start)
return.start.line == return.end.line
return.start.line == orig(this.range.start.line)
return.start.line == orig(this.range.end.line)
return.start.column == return.start.offset
return.start.column == orig(this.range.start.column)
return.start.column == orig(this.range.start.offset)
return.end == orig(this.range.end)
return.end.column == return.end.offset
return.end.column == orig(this.range.end.column)
return.end.column == orig(this.range.end.offset)
this.rule == null
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
return.start.line == 1
return.start.column one of { 0, 6 }
return.end.column one of { 5, 11 }
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::ENTER
this.range.start.line == this.range.end.line
this.range.start.column == this.range.start.offset
this.range.end.column == this.range.end.offset
this.sequenceList != null
this.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
this.stringResult == null
size(this.sequenceList[]) == 1
this.range.start.column < this.range.end.column
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::EXIT39
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
this.buffer != null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::EXIT39;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::EXIT42
this.sequenceList.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
this.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
this.range.start.column == 5
this.range.end.column == 6
this.buffer == null
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::EXIT42;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList == orig(this.sequenceList)
this.sequenceList[] == orig(this.sequenceList[])
this.sequenceList.getClass().getName() == orig(this.sequenceList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == this.range.end.line
this.range.start.line == orig(this.range.start.line)
this.range.start.line == orig(this.range.end.line)
this.range.start.column == this.range.start.offset
this.range.start.column == orig(this.range.start.column)
this.range.start.column == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.column == this.range.end.offset
this.range.end.column == orig(this.range.end.column)
this.range.end.column == orig(this.range.end.offset)
this.buffer == orig(this.buffer)
this.stringResult == orig(this.stringResult)
this.sequenceList != null
this.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
this.stringResult == null
return == true
size(this.sequenceList[]) == 1
this.range.start.column < this.range.end.column
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.hasText():::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.setRange(fri.patterns.interpreter.parsergenerator.Token$Range):::ENTER
this.range.start.line == this.range.end.line
this.range.start.line == arg0.start.line
this.range.start.column == this.range.start.offset
this.range.start.column == arg0.start.column
this.range.end.column == this.range.end.offset
this.range.end.column == arg0.end.column
arg0.start.line == arg0.end.line
arg0.start.column == arg0.start.offset
arg0.end.column == arg0.end.offset
this.sequenceList != null
this.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
this.stringResult == null
arg0 != null
arg0.start != null
arg0.start.line == 1
arg0.start.column one of { 0, 5, 6 }
arg0.end != null
arg0.end.column one of { 5, 6, 11 }
size(this.sequenceList[]) == 1
arg0.start.column < arg0.end.column
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.setRange(fri.patterns.interpreter.parsergenerator.Token$Range):::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.sequenceList == orig(this.sequenceList)
this.sequenceList[] == orig(this.sequenceList[])
this.sequenceList.getClass().getName() == orig(this.sequenceList.getClass().getName())
this.range == orig(arg0)
this.range.start == arg0.start
this.range.start.line == arg0.start.line
this.range.start.column == arg0.start.column
this.range.start.offset == arg0.start.column
this.range.end == arg0.end
this.range.end.line == arg0.start.line
this.range.end.column == arg0.end.column
this.range.end.offset == arg0.end.column
this.buffer == orig(this.buffer)
this.stringResult == orig(this.stringResult)
arg0.start == orig(arg0.start)
arg0.start.line == arg0.end.line
arg0.start.line == orig(this.range.start.line)
arg0.start.line == orig(arg0.start.line)
arg0.start.line == orig(arg0.end.line)
arg0.start.column == arg0.start.offset
arg0.start.column == orig(this.range.start.column)
arg0.start.column == orig(arg0.start.column)
arg0.start.column == orig(arg0.start.offset)
arg0.end == orig(arg0.end)
arg0.end.column == arg0.end.offset
arg0.end.column == orig(this.range.end.column)
arg0.end.column == orig(arg0.end.column)
arg0.end.column == orig(arg0.end.offset)
this.sequenceList != null
this.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
this.range != null
this.stringResult == null
arg0.start != null
arg0.start.line == 1
arg0.start.column one of { 0, 5, 6 }
arg0.end != null
arg0.end.column one of { 5, 6, 11 }
size(this.sequenceList[]) == 1
arg0.start.column < arg0.end.column
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.toString():::ENTER
this.rule == null
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
this.range.start.column one of { 0, 6 }
this.range.start.offset one of { 0, 6 }
this.range.end.column one of { 5, 11 }
this.range.end.offset one of { 5, 11 }
this.stringResult == null
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.ResultTree.toString():::EXIT
this.rule == orig(this.rule)
this.sequenceList == orig(this.sequenceList)
this.sequenceList[] == orig(this.sequenceList[])
this.sequenceList.getClass().getName() == orig(this.sequenceList.getClass().getName())
this.range == orig(this.range)
this.range.start == orig(this.range.start)
this.range.start.line == orig(this.range.start.line)
this.range.start.column == orig(this.range.start.column)
this.range.start.offset == orig(this.range.start.offset)
this.range.end == orig(this.range.end)
this.range.end.line == orig(this.range.end.line)
this.range.end.column == orig(this.range.end.column)
this.range.end.offset == orig(this.range.end.offset)
this.buffer == orig(this.buffer)
this.rule == null
this.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
this.range.start.column one of { 0, 6 }
this.range.start.offset one of { 0, 6 }
this.range.end.column one of { 5, 11 }
this.range.end.offset one of { 5, 11 }
return.toString one of { "Hello", "World" }
size(this.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules:::CLASS
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == java.lang.String[][].class
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] contains no nulls and has only one value, of length 301
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] contains no nulls and has only one value, of length 6
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] contains no nulls and has only one value, of length 106
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] contains no nulls and has only one value, of length 6
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] contains no nulls and has only one value, of length 25
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] contains no nulls and has only one value, of length 2
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] contains no nulls and has only one value, of length 2
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules has only one value
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules != null
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] contains no nulls and has only one value, of length 4
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] elements != null
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[]) == 301
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[]) == 6
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[]) == 106
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[]) == 6
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[]) == 25
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[]) == 2
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[]) == 2
size(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.catenizeRules(java.lang.String[][][]):::ENTER
arg0.getClass().getName() == java.lang.String[][][].class
size(arg0[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.catenizeRules(java.lang.String[][][]):::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
arg0[] == orig(arg0[])
size(return[]) one of { 5, 7, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getNewlineRules():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getNewlineRules():::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
return has only one value
return[] contains no nulls and has only one value, of length 5
size(return[]) == 5
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getNewlinesRules():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getNewlinesRules():::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
return has only one value
return[] contains no nulls and has only one value, of length 7
size(return[]) == 7
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSomeRules(int, int):::ENTER
arg0 one of { 13, 16, 242 }
arg1 one of { 16, 21, 244 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSomeRules(int, int):::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
size(return[]) one of { 2, 3, 5 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSomeRules(int, int, java.lang.String[][]):::ENTER
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == arg2.getClass().getName()
size(arg2[]) one of { 2, 4, 301 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSomeRules(int, int, java.lang.String[][]):::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(arg2.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
arg2[] == orig(arg2[])
arg2[orig(arg0)] in return[]
arg2[orig(arg1)-1] in return[]
size(arg2[])-1 % size(return[])-1 == 0
orig(arg0) - orig(arg1) + size(return[]) == 0
orig(arg0) - orig(arg1) + size(return[])-1 + 1 == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSpaceRules():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSpaceRules():::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
return has only one value
return[] contains no nulls and has only one value, of length 3
size(return[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSpacesRules():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getSpacesRules():::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
return has only one value
return[] contains no nulls and has only one value, of length 5
size(return[]) == 5
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getWhitespacesRules():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.getWhitespacesRules():::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
return has only one value
return[] contains no nulls and has only one value, of length 16
size(return[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.rulesForIdentifier(java.lang.String):::ENTER
arg0 has only one value
arg0.toString == "whitespaces"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.rulesForIdentifier(java.lang.String):::EXIT96
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.rulesForIdentifier(java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.lexerSyntax[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCharRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.xmlCombinigAndExtenderRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.digitRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.numberRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.newlinesRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.chardefRules[])
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules)
fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[] == orig(fri.patterns.interpreter.parsergenerator.lexer.StandardLexerRules.whitespaceRules[])
arg0.toString == orig(arg0.toString)
arg0.toString == "whitespaces"
return has only one value
return[] contains no nulls and has only one value, of length 16
size(return[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item:::OBJECT
this.consumer.sequence.getClass().getName() == this.consumer.rule.symbols.getClass().getName()
this.consumer.sequence.getClass().getName() == this.result.rule.symbols.getClass().getName()
this.consumer.sequence.getClass().getName() == this.result.sequenceList.getClass().getName()
this.consumer.rule == this.result.rule
this.consumer.rule.symbols == this.result.rule.symbols
this.consumer.rule.symbols.getClass().getName() == this.result.rule.symbols.getClass().getName()
this.consumer.rule.symbols.getClass().getName() == this.result.sequenceList.getClass().getName()
this.result.rule.symbols.getClass().getName() == this.result.sequenceList.getClass().getName()
this.symbol != null
this.consumer != null
this.consumer.sequence != null
this.consumer.sequence[] elements != null
this.consumer.sequence.getClass().getName() == java.util.ArrayList.class
this.consumer.constraints == null
this.consumer.nullable == false
this.consumer.rule.symbols != null
this.consumer.rule.symbols[] elements != null
this.consumer.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.consumer.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.consumer.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.consumer.fixedLength == -1
this.consumer.startLength one of { -1, 1, 2 }
this.consumer.startLength != 0
this.consumer.variance one of { -1, 1, 3 }
this.consumer.variance != 0
this.result.rule.symbols != null
this.result.rule.symbols[] elements != null
this.result.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.result.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.result.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.result.sequenceList != null
this.result.sequenceList[] elements != null
this.result.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
this.result.sequenceList.getClass().getName() == java.util.ArrayList.class
this.result.range != null
this.result.range.start != null
this.result.range.end != null
this.result.stringResult == null
size(this.consumer.sequence[]) one of { 1, 2 }
size(this.consumer.rule.symbols[]) one of { 2, 3 }
size(this.result.rule.symbols[]) == 2
size(this.result.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.Item(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
arg1.sequence.getClass().getName() == arg1.rule.symbols.getClass().getName()
arg1.sequence.getClass().getName() == java.util.ArrayList.class
arg1.constraints == null
arg1.nullable == false
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance one of { -1, 1 }
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.Item(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.symbol == orig(arg0)
this.consumer == orig(arg1)
this.consumer.sequence == arg1.sequence
this.consumer.sequence.getClass().getName() == arg1.sequence.getClass().getName()
this.consumer.nullable == arg1.nullable
this.consumer.repeatable == arg1.repeatable
this.consumer.rule == arg1.rule
this.consumer.rule.symbols == arg1.rule.symbols
this.consumer.rule.symbols.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.consumer.fixedLength == arg1.fixedLength
this.consumer.startLength == arg1.startLength
this.consumer.variance == arg1.variance
arg0.toString == orig(arg0.toString)
arg1.sequence == orig(arg1.sequence)
arg1.sequence[] == orig(arg1.sequence[])
arg1.sequence.getClass().getName() == arg1.rule.symbols.getClass().getName()
arg1.sequence.getClass().getName() == orig(arg1.sequence.getClass().getName())
arg1.constraints == orig(arg1.constraints)
arg1.nullable == orig(arg1.nullable)
arg1.repeatable == orig(arg1.repeatable)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.fixedLength == orig(arg1.fixedLength)
arg1.startLength == orig(arg1.startLength)
arg1.variance == orig(arg1.variance)
this.result == null
arg1.sequence.getClass().getName() == java.util.ArrayList.class
arg1.constraints == null
arg1.nullable == false
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance one of { -1, 1 }
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.compareTo(java.lang.Object):::ENTER
this.symbol.toString one of { "newline", "whitespace" }
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives] }
this.consumer.repeatable == false
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength == -1
this.consumer.variance one of { -1, 1 }
this.result == null
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.class
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.compareTo(java.lang.Object):::EXIT281
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.compareTo(java.lang.Object):::EXIT
this.symbol == orig(this.symbol)
this.symbol.toString == orig(this.symbol.toString)
this.consumer == orig(this.consumer)
this.consumer.sequence == orig(this.consumer.sequence)
this.consumer.sequence[] == orig(this.consumer.sequence[])
this.consumer.sequence.getClass().getName() == orig(this.consumer.sequence.getClass().getName())
this.consumer.sequence.getClass().getName() == orig(this.consumer.rule.symbols.getClass().getName())
this.consumer.constraints == orig(this.consumer.constraints)
this.consumer.nullable == orig(this.consumer.nullable)
this.consumer.repeatable == orig(this.consumer.repeatable)
this.consumer.rule == orig(this.consumer.rule)
this.consumer.rule.symbols == orig(this.consumer.rule.symbols)
this.consumer.rule.symbols[] == orig(this.consumer.rule.symbols[])
this.consumer.fixedLength == orig(this.consumer.fixedLength)
this.consumer.startLength == return
this.result == orig(this.result)
this.symbol.toString one of { "newline", "whitespace" }
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Consumer], [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives] }
this.consumer.repeatable == false
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.variance one of { 1, 3 }
this.result == null
return == 1
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText):::ENTER
this.consumer.sequence.getClass().getName() == arg0.lineLengths.getClass().getName()
arg0.column == arg0.readOffset
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1]
arg0.line[arg0.readOffset-1] == arg0.buffer[arg0.readPos]
arg0.buffer[arg0.readPos] == arg0.buffer[arg0.readLen-1]
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.result.rule has only one value
this.result.rule.symbols has only one value
this.result.rule.symbols[] contains no nulls and has only one value, of length 2
this.result.sequenceList has only one value
this.result.sequenceList[] contains no nulls and has only one value, of length 1
this.result.sequenceList[] elements has only one value
this.result.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
this.result.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
this.result.range has only one value
this.result.range.start has only one value
this.result.range.end has only one value
this.result.buffer == null
arg0 has only one value
arg0.line has only one value
arg0.line[] one of { [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.column one of { 1, 6, 7 }
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint == null
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
arg0.eof == false
arg0.buffering == true
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
size(arg0.line[]) == 64
size(arg0.buffer[]) == 128
arg0.line[arg0.column] == 0
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 0, 101, 108 }
arg0.buffer[arg0.column-1] one of { 0, 72 }
arg0.buffer[arg0.readPos] one of { 32, 72, 87 }
this.consumer.sequence.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.column > arg0.readPos
arg0.column >= arg0.readLen
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.readPos < arg0.readLen
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
arg0.line[arg0.column] < arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] < arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.readPos] != arg0.line[arg0.readLen]
arg0.line[arg0.readPos] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readPos] != arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] != arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.buffer[arg0.column-1] % arg0.buffer[arg0.readPos] == 0
arg0.buffer[arg0.column-1] <= arg0.buffer[arg0.readPos]
arg0.buffer[arg0.column-1] != arg0.buffer[arg0.readLen]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText):::EXIT
this.symbol == orig(this.symbol)
this.symbol.toString == orig(this.symbol.toString)
this.consumer == orig(this.consumer)
this.consumer.sequence == orig(this.consumer.sequence)
this.consumer.sequence[] == orig(this.consumer.sequence[])
this.consumer.sequence.getClass().getName() == arg0.lineLengths.getClass().getName()
this.consumer.constraints == orig(this.consumer.constraints)
this.consumer.nullable == orig(this.consumer.nullable)
this.consumer.repeatable == orig(this.consumer.repeatable)
this.consumer.rule == return.rule
this.consumer.rule == orig(this.consumer.rule)
this.consumer.rule == orig(this.result.rule)
this.consumer.rule.symbols == return.rule.symbols
this.consumer.rule.symbols == orig(this.consumer.rule.symbols)
this.consumer.rule.symbols == orig(this.result.rule.symbols)
this.consumer.rule.symbols[] == orig(this.consumer.rule.symbols[])
this.consumer.rule.symbols.getClass().getName() == arg0.lineLengths.getClass().getName()
this.consumer.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.consumer.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
this.consumer.rule.symbols.getClass().getName() == orig(this.consumer.rule.symbols.getClass().getName())
this.consumer.rule.symbols.getClass().getName() == orig(this.result.sequenceList.getClass().getName())
this.consumer.fixedLength == orig(this.consumer.fixedLength)
this.consumer.startLength == orig(this.consumer.startLength)
this.consumer.variance == orig(this.consumer.variance)
this.result == return
this.result.rule == return.rule
this.result.rule.symbols == return.rule.symbols
this.result.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.result.sequenceList == return.sequenceList
this.result.sequenceList.getClass().getName() == return.sequenceList.getClass().getName()
this.result.range == return.range
this.result.range.start == return.range.start
this.result.range.end == return.range.end
this.result.buffer == return.buffer
arg0.line == orig(arg0.line)
arg0.prevLine == orig(arg0.prevLine)
arg0.prevLength == orig(arg0.prevLength)
arg0.wasCr == orig(arg0.wasCr)
arg0.column == arg0.readOffset
arg0.lineLengths == orig(arg0.lineLengths)
arg0.lineLengths[] == orig(arg0.lineLengths[])
arg0.lineLengths.getClass().getName() == return.rule.symbols.getClass().getName()
arg0.lineLengths.getClass().getName() == return.sequenceList.getClass().getName()
arg0.lineLengths.getClass().getName() == orig(this.consumer.sequence.getClass().getName())
arg0.lineLengths.getClass().getName() == orig(this.result.sequenceList.getClass().getName())
arg0.lineLengths.getClass().getName() == orig(arg0.lineLengths.getClass().getName())
arg0.inputStream == orig(arg0.inputStream)
arg0.reader == orig(arg0.reader)
arg0.reader.getClass().getName() == orig(arg0.reader.getClass().getName())
arg0.buffer == orig(arg0.buffer)
arg0.eof == orig(arg0.eof)
arg0.buffering == orig(arg0.buffering)
return.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
size(arg0.line[]) == orig(size(arg0.line[]))
size(arg0.buffer[]) == orig(size(arg0.buffer[]))
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)-1])
arg0.line[arg0.column] == orig(arg0.line[arg0.column])
arg0.line[arg0.column] == orig(arg0.line[arg0.readOffset])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readPos)])
arg0.line[arg0.readLen] == orig(arg0.line[post(arg0.readLen)])
arg0.line[orig(arg0.column)-1] == arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.readPos)] == arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readPos])
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readLen-1])
arg0.line[orig(arg0.readOffset)-1] == arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.column-1])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readOffset-1])
arg0.buffer[orig(arg0.readPos)] == arg0.buffer[orig(arg0.readLen)-1]
arg0.buffer[orig(arg0.readPos)] == orig(arg0.line[arg0.column-1])
arg0.buffer[orig(arg0.readPos)] == orig(arg0.line[arg0.readOffset-1])
arg0.buffer[orig(arg0.readPos)] == orig(arg0.buffer[arg0.readPos])
arg0.buffer[orig(arg0.readPos)] == orig(arg0.buffer[arg0.readLen-1])
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.line has only one value
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.lineLengths.getClass().getName() == java.util.ArrayList.class
arg0.scanPoint[] one of { [1, 5], [1, 6], [1, 11] }
arg0.scanPoint[] elements >= 1
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1, 5 }
arg0.readLen one of { 1, 2, 5 }
arg0.eof == false
arg0.buffering == true
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.sequenceList.getClass().getName() == java.util.ArrayList.class
return.stringResult == null
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
arg0.line[arg0.column] == 0
arg0.line[arg0.readLen-1] one of { 72, 101, 111 }
arg0.line[orig(arg0.readPos)] one of { 72, 101 }
arg0.line[orig(arg0.readLen)] one of { 101, 108 }
arg0.buffer[arg0.column-1] one of { 0, 111 }
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 }
arg0.buffer[arg0.readLen] one of { 0, 101, 108 }
arg0.buffer[orig(arg0.column)] one of { 0, 101 }
arg0.buffer[orig(arg0.column)-1] one of { 0, 72 }
arg0.buffer[orig(arg0.readPos)] one of { 32, 72, 87 }
this.result.rule.symbols[] is the reverse of orig(this.result.rule.symbols[])
orig(this.result.sequenceList.getClass().getName()) in this.result.rule.symbols[].getClass().getName()
this.result.sequenceList[] is the reverse of orig(this.result.sequenceList[])
orig(this.result.sequenceList.getClass().getName()) in this.result.sequenceList[].getClass().getName()
arg0.line[] >= orig(arg0.line[]) (elementwise)
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
orig(arg0.line[post(arg0.column)-1]) in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.buffer[orig(arg0.column)] in arg0.line[]
arg0.buffer[orig(arg0.column)-1] in arg0.line[]
arg0.buffer[orig(arg0.readLen)] in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)]) in arg0.line[]
orig(arg0.line[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.line[arg0.readLen]) in arg0.line[]
orig(arg0.buffer[arg0.readLen]) in arg0.line[]
arg0.column >= arg0.readPos
arg0.column >= arg0.readLen
arg0.column >= orig(arg0.column)
arg0.column > orig(arg0.readPos)
arg0.column > orig(arg0.readLen)
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
arg0.lineLengths.getClass().getName() != arg0.reader.getClass().getName()
orig(arg0.readLen) in arg0.scanPoint[]
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.line[orig(arg0.column)] in arg0.buffer[]
orig(arg0.line[post(arg0.column)-1]) in arg0.buffer[]
arg0.readPos <= arg0.readLen
arg0.readPos != orig(arg0.column)
arg0.readPos >= orig(arg0.readPos)
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen != orig(arg0.column)
arg0.readLen > orig(arg0.readPos)
arg0.readLen % orig(arg0.readLen) == 0
arg0.readLen >= orig(arg0.readLen)
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
orig(this.result.sequenceList.getClass().getName()) in return.rule.symbols[].getClass().getName()
return.rule.symbols.getClass().getName() in orig(this.result.rule.symbols[].getClass().getName())
return.rule.symbols.getClass().getName() in orig(this.result.sequenceList[].getClass().getName())
orig(this.result.sequenceList.getClass().getName()) in return.sequenceList[].getClass().getName()
return.sequenceList.getClass().getName() in orig(this.result.rule.symbols[].getClass().getName())
return.sequenceList.getClass().getName() in orig(this.result.sequenceList[].getClass().getName())
orig(arg0.line[]) elements >= arg0.line[arg0.column]
arg0.buffer[arg0.readLen] in orig(arg0.line[])
arg0.buffer[orig(arg0.column)-1] in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readPos)]) in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readLen)-1]) in orig(arg0.line[])
orig(arg0.column) < size(arg0.line[])-1
orig(arg0.column) < size(arg0.buffer[])-1
orig(arg0.buffer[]) elements >= arg0.line[arg0.column]
orig(arg0.line[post(arg0.column)-1]) in orig(arg0.buffer[])
orig(arg0.readPos) < size(arg0.line[])-1
orig(arg0.readPos) < size(arg0.buffer[])-1
orig(arg0.readLen) < size(arg0.line[])-1
orig(arg0.readLen) < size(arg0.buffer[])-1
arg0.line[arg0.column] < arg0.line[arg0.column-1]
arg0.line[arg0.column] <= arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] < arg0.line[arg0.readLen-1]
arg0.line[arg0.column] < arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.line[orig(arg0.readLen)]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.column] <= arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readLen)]
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.column] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.column-1] != arg0.line[arg0.readPos]
arg0.line[arg0.column-1] != arg0.line[arg0.readLen]
arg0.line[arg0.column-1] <= arg0.line[arg0.readLen-1]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readLen)]
arg0.buffer[arg0.column-1] % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] >= arg0.buffer[arg0.column-1]
orig(arg0.line[post(arg0.column)-1]) % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column-1] >= arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.line[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readPos] <= arg0.line[arg0.readLen]
arg0.line[arg0.readPos] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readPos] <= arg0.line[orig(arg0.readLen)]
arg0.line[arg0.readPos] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readPos] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readPos] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readPos] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readLen] != arg0.line[arg0.readLen-1]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.readPos)]
arg0.line[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.readPos)]
arg0.buffer[arg0.column-1] % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen-1] > orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.readPos)]
orig(arg0.line[post(arg0.readLen)-1]) % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.readPos)]
arg0.line[orig(arg0.column)] != orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.column)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.column)] != arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readPos)] < arg0.line[orig(arg0.readLen)]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readPos)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.readPos)] != arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readPos)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readPos)] < arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.readPos)] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.readPos)] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[orig(arg0.readPos)] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.readPos)] != orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readLen)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readLen)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readLen)] >= arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.readPos)]
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[arg0.readLen]) % arg0.line[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)]
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readPos]
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readLen]
orig(arg0.line[post(arg0.column)-1]) % arg0.buffer[orig(arg0.readPos)] == 0
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[orig(arg0.readPos)]
orig(arg0.line[post(arg0.column)-1]) < arg0.buffer[orig(arg0.readLen)]
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readPos] <= arg0.buffer[arg0.readLen]
arg0.buffer[arg0.readPos] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readLen] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[orig(arg0.column)] != arg0.buffer[orig(arg0.readPos)]
arg0.buffer[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.buffer[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] % arg0.buffer[orig(arg0.readPos)] == 0
arg0.buffer[orig(arg0.column)-1] <= arg0.buffer[orig(arg0.readPos)]
arg0.buffer[orig(arg0.column)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.readPos)] < arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.readPos)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.readPos)] != orig(arg0.line[arg0.readLen])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.line[arg0.readLen])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.readLen)-1]) >= orig(arg0.buffer[post(arg0.readLen)-1])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.getResultTree():::ENTER
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.repeatable == false
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength one of { -1, 1 }
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.getResultTree():::EXIT
this.symbol == orig(this.symbol)
this.symbol.toString == orig(this.symbol.toString)
this.consumer == orig(this.consumer)
this.consumer.sequence == orig(this.consumer.sequence)
this.consumer.sequence[] == orig(this.consumer.sequence[])
this.consumer.sequence.getClass().getName() == return.sequenceList.getClass().getName()
this.consumer.constraints == orig(this.consumer.constraints)
this.consumer.nullable == orig(this.consumer.nullable)
this.consumer.repeatable == orig(this.consumer.repeatable)
this.consumer.rule == return.rule
this.consumer.rule.symbols == return.rule.symbols
this.consumer.rule.symbols[] == orig(this.consumer.rule.symbols[])
this.consumer.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.consumer.fixedLength == orig(this.consumer.fixedLength)
this.consumer.startLength == orig(this.consumer.startLength)
this.consumer.variance == orig(this.consumer.variance)
this.result == return
this.result.rule == return.rule
this.result.rule.symbols == return.rule.symbols
this.result.rule.symbols[] == orig(this.result.rule.symbols[])
this.result.rule.symbols.getClass().getName() == return.rule.symbols.getClass().getName()
this.result.sequenceList == return.sequenceList
this.result.sequenceList[] == orig(this.result.sequenceList[])
this.result.sequenceList.getClass().getName() == return.sequenceList.getClass().getName()
this.result.range == return.range
this.result.range.start == return.range.start
this.result.range.end == return.range.end
this.result.buffer == return.buffer
this.result.stringResult == orig(this.result.stringResult)
return == orig(this.result)
return.rule == orig(this.consumer.rule)
return.rule == orig(this.result.rule)
return.rule.symbols == orig(this.consumer.rule.symbols)
return.rule.symbols == orig(this.result.rule.symbols)
return.rule.symbols.getClass().getName() == return.sequenceList.getClass().getName()
return.rule.symbols.getClass().getName() == orig(this.consumer.rule.symbols.getClass().getName())
return.rule.symbols.getClass().getName() == orig(this.result.rule.symbols.getClass().getName())
return.sequenceList == orig(this.result.sequenceList)
return.sequenceList.getClass().getName() == orig(this.consumer.sequence.getClass().getName())
return.sequenceList.getClass().getName() == orig(this.result.sequenceList.getClass().getName())
return.range == orig(this.result.range)
return.range.start == orig(this.result.range.start)
return.range.end == orig(this.result.range.end)
return.buffer == orig(this.result.buffer)
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.repeatable == false
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength one of { -1, 1 }
return.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.sequenceList.getClass().getName() == java.util.ArrayList.class
return.stringResult == null
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
size(return.rule.symbols[]) == 2
size(return.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.getSymbol():::ENTER
this.symbol.toString one of { "\"Hello\"", "\"World\"", "whitespaces" }
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.rule.symbols has only one value
this.consumer.rule.symbols[] contains no nulls and has only one value, of length 2
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength == -1
this.consumer.variance == -1
this.result.rule.symbols has only one value
this.result.rule.symbols[] contains no nulls and has only one value, of length 2
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.getSymbol():::EXIT
this.symbol == return
this.symbol.toString == orig(this.symbol.toString)
this.consumer == orig(this.consumer)
this.consumer.sequence == orig(this.consumer.sequence)
this.consumer.sequence[] == orig(this.consumer.sequence[])
this.consumer.sequence.getClass().getName() == orig(this.consumer.sequence.getClass().getName())
this.consumer.constraints == orig(this.consumer.constraints)
this.consumer.nullable == orig(this.consumer.nullable)
this.consumer.repeatable == orig(this.consumer.repeatable)
this.consumer.rule == orig(this.consumer.rule)
this.consumer.rule.symbols == orig(this.consumer.rule.symbols)
this.consumer.rule.symbols[] == orig(this.consumer.rule.symbols[])
this.consumer.rule.symbols.getClass().getName() == orig(this.consumer.rule.symbols.getClass().getName())
this.consumer.fixedLength == orig(this.consumer.fixedLength)
this.consumer.startLength == orig(this.consumer.startLength)
this.consumer.variance == orig(this.consumer.variance)
this.result == orig(this.result)
this.result.rule == orig(this.result.rule)
this.result.rule.symbols == orig(this.result.rule.symbols)
this.result.rule.symbols[] == orig(this.result.rule.symbols[])
this.result.sequenceList == orig(this.result.sequenceList)
this.result.sequenceList[] == orig(this.result.sequenceList[])
this.result.sequenceList.getClass().getName() == orig(this.result.sequenceList.getClass().getName())
this.result.range == orig(this.result.range)
this.result.range.start == orig(this.result.range.start)
this.result.range.end == orig(this.result.range.end)
this.result.buffer == orig(this.result.buffer)
this.result.stringResult == orig(this.result.stringResult)
return == orig(this.symbol)
this.symbol.toString one of { "\"Hello\"", "\"World\"", "whitespaces" }
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.rule.symbols has only one value
this.consumer.rule.symbols[] contains no nulls and has only one value, of length 2
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength == -1
this.consumer.variance == -1
this.result.rule.symbols has only one value
this.result.rule.symbols[] contains no nulls and has only one value, of length 2
return.toString one of { "\"Hello\"", "\"World\"", "whitespaces" }
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.getTokenIdentifier():::ENTER
this.symbol.toString one of { "\"Hello\"", "\"World\"" }
this.consumer.sequence[].getClass().getName() == [java.lang.String]
this.consumer.sequence[].getClass().getName() elements == java.lang.String.class
this.consumer.repeatable == false
this.consumer.rule == null
this.consumer.startLength == -1
this.consumer.variance == -1
this.result.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.result.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
size(this.consumer.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.getTokenIdentifier():::EXIT
this.symbol == return
this.symbol.toString == orig(this.symbol.toString)
this.consumer == orig(this.consumer)
this.consumer.sequence == orig(this.consumer.sequence)
this.consumer.sequence[] == orig(this.consumer.sequence[])
this.consumer.sequence.getClass().getName() == orig(this.consumer.sequence.getClass().getName())
this.consumer.sequence.getClass().getName() == orig(this.result.sequenceList.getClass().getName())
this.consumer.constraints == orig(this.consumer.constraints)
this.consumer.nullable == orig(this.consumer.nullable)
this.consumer.repeatable == orig(this.consumer.repeatable)
this.consumer.rule == orig(this.consumer.rule)
this.consumer.rule == orig(this.result.rule)
this.consumer.fixedLength == orig(this.consumer.fixedLength)
this.consumer.startLength == orig(this.consumer.startLength)
this.consumer.variance == orig(this.consumer.variance)
this.result == orig(this.result)
this.result.sequenceList == orig(this.result.sequenceList)
this.result.sequenceList[] == orig(this.result.sequenceList[])
this.result.range == orig(this.result.range)
this.result.range.start == orig(this.result.range.start)
this.result.range.end == orig(this.result.range.end)
this.result.buffer == orig(this.result.buffer)
this.result.stringResult == orig(this.result.stringResult)
return == orig(this.symbol)
this.symbol.toString one of { "\"Hello\"", "\"World\"" }
this.consumer.sequence[].getClass().getName() == [java.lang.String]
this.consumer.sequence[].getClass().getName() elements == java.lang.String.class
this.consumer.repeatable == false
this.consumer.rule == null
this.consumer.startLength == -1
this.consumer.variance == -1
this.result.sequenceList[].getClass().getName() == [java.lang.StringBuffer]
this.result.sequenceList[].getClass().getName() elements == java.lang.StringBuffer.class
return.toString one of { "\"Hello\"", "\"World\"" }
size(this.consumer.sequence[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.hashCode():::ENTER
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength one of { -1, 1 }
this.result != null
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.hashCode():::EXIT
this.symbol == orig(this.symbol)
this.symbol.toString == orig(this.symbol.toString)
this.consumer == orig(this.consumer)
this.consumer.sequence == orig(this.consumer.sequence)
this.consumer.sequence[] == orig(this.consumer.sequence[])
this.consumer.sequence.getClass().getName() == orig(this.consumer.sequence.getClass().getName())
this.consumer.sequence.getClass().getName() == orig(this.result.sequenceList.getClass().getName())
this.consumer.constraints == orig(this.consumer.constraints)
this.consumer.nullable == orig(this.consumer.nullable)
this.consumer.repeatable == orig(this.consumer.repeatable)
this.consumer.rule == orig(this.consumer.rule)
this.consumer.rule == orig(this.result.rule)
this.consumer.rule.symbols == orig(this.consumer.rule.symbols)
this.consumer.rule.symbols == orig(this.result.rule.symbols)
this.consumer.rule.symbols[] == orig(this.consumer.rule.symbols[])
this.consumer.rule.symbols.getClass().getName() == orig(this.consumer.rule.symbols.getClass().getName())
this.consumer.rule.symbols.getClass().getName() == orig(this.result.rule.symbols.getClass().getName())
this.consumer.fixedLength == orig(this.consumer.fixedLength)
this.consumer.startLength == orig(this.consumer.startLength)
this.consumer.variance == orig(this.consumer.variance)
this.result == orig(this.result)
this.result.rule.symbols[] == orig(this.result.rule.symbols[])
this.result.sequenceList == orig(this.result.sequenceList)
this.result.sequenceList[] == orig(this.result.sequenceList[])
this.result.range == orig(this.result.range)
this.result.range.start == orig(this.result.range.start)
this.result.range.end == orig(this.result.range.end)
this.result.buffer == orig(this.result.buffer)
this.result.stringResult == orig(this.result.stringResult)
this.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
this.consumer.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.consumer.startLength one of { -1, 1 }
this.result != null
size(this.consumer.sequence[]) == 1
size(this.consumer.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator:::OBJECT
this.it1.getClass().getName() == this.it2.getClass().getName()
this.it != null
this.it1.getClass().getName() == java.util.ArrayList$Itr.class
this.it2 != null
this.it2.getClass().getName() == java.util.ArrayList$Itr.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar != null
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar != null
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[] elements != null
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName() == java.util.ArrayList.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups != null
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput == true
size(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[]) one of { 0, 1, 2 }
this.it.getClass().getName() != this.it1.getClass().getName()
this.it.getClass().getName() != this.it2.getClass().getName()
this.it.getClass().getName() != fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName()
this.it1.getClass().getName() != fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName()
this.it2.getClass().getName() != fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.ItemEnumerator(fri.patterns.interpreter.parsergenerator.lexer.Strategy):::ENTER
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName() == java.util.ArrayList.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput == true
size(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[]) one of { 0, 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.ItemEnumerator(fri.patterns.interpreter.parsergenerator.lexer.Strategy):::EXIT
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[] == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[])
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.hasMoreElements():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.hasMoreElements():::EXIT
this.it == orig(this.it)
this.it.getClass().getName() == orig(this.it.getClass().getName())
this.it1 == orig(this.it1)
this.it1.getClass().getName() == orig(this.it1.getClass().getName())
this.it2 == orig(this.it2)
this.it2.getClass().getName() == orig(this.it2.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[] == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[])
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput)
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.hasMoreElements():::EXIT;condition="return == true"
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.hasMoreElements():::EXIT;condition="not(return == true)"
return == false
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.nextElement():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.nextElement():::EXIT314
this.it1 == orig(this.it1)
this.it1.getClass().getName() == orig(this.it2.getClass().getName())
this.it.getClass().getName() == java.util.Hashtable$Enumerator.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[] elements has only one value
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
size(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[]) one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.nextElement():::EXIT317
this.it1.getClass().getName() == orig(this.it2.getClass().getName())
this.it.getClass().getName() == java.util.Hashtable$Enumerator.class
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited == true
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[] elements has only one value
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
size(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[]) one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.nextElement():::EXIT320
this.it1 == orig(this.it1)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item, fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
size(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[]) one of { 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy$ItemEnumerator.nextElement():::EXIT
this.it == orig(this.it)
this.it.getClass().getName() == orig(this.it.getClass().getName())
this.it1.getClass().getName() == orig(this.it1.getClass().getName())
this.it2 == orig(this.it2)
this.it2.getClass().getName() == orig(this.it2.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.inited)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithStartChar)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[] == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar[])
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName() == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName())
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competitiveGroups)
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput == orig(fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.competeForLongestInput)
return != null
return.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.class
this.it.getClass().getName() != return.getClass().getName()
this.it1.getClass().getName() != return.getClass().getName()
this.it2.getClass().getName() != return.getClass().getName()
fri.patterns.interpreter.parsergenerator.lexer.Strategy.this.itemsWithoutStartChar.getClass().getName() != return.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy:::OBJECT
this.itemsWithStartChar != null
this.itemsWithoutStartChar != null
this.itemsWithoutStartChar[] elements != null
this.itemsWithoutStartChar[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
this.itemsWithoutStartChar.getClass().getName() == java.util.ArrayList.class
this.competitiveGroups != null
this.competeForLongestInput == true
size(this.itemsWithoutStartChar[]) one of { 0, 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.Strategy():::EXIT
this.inited == false
this.itemsWithoutStartChar[] == []
this.itemsWithoutStartChar[].getClass().getName() == []
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.addConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.itemsWithoutStartChar.getClass().getName() == arg1.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.inited == false
this.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
arg1.constraints == null
arg1.nullable == false
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance one of { -1, 1 }
size(this.itemsWithoutStartChar[]) one of { 0, 1 }
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.addConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.inited == orig(this.inited)
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar.getClass().getName() == arg1.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg1.sequence.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
arg0.toString == orig(arg0.toString)
arg1.sequence == orig(arg1.sequence)
arg1.sequence[] == orig(arg1.sequence[])
arg1.constraints == orig(arg1.constraints)
arg1.nullable == orig(arg1.nullable)
arg1.repeatable == orig(arg1.repeatable)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.fixedLength == orig(arg1.fixedLength)
arg1.startLength == orig(arg1.startLength)
arg1.variance == orig(arg1.variance)
this.inited == false
arg1.constraints == null
arg1.nullable == false
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance one of { -1, 1 }
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
size(this.itemsWithoutStartChar[]) >= orig(size(this.itemsWithoutStartChar[]))
size(this.itemsWithoutStartChar[])-1 <= orig(size(this.itemsWithoutStartChar[]))
size(this.itemsWithoutStartChar[])-1 >= orig(size(this.itemsWithoutStartChar[]))-1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.addIgnoringConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.itemsWithoutStartChar.getClass().getName() == arg1.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg1.rule.symbols.getClass().getName()
this has only one value
this.inited == false
this.itemsWithStartChar has only one value
this.itemsWithoutStartChar has only one value
this.itemsWithoutStartChar[] == []
this.itemsWithoutStartChar[].getClass().getName() == []
this.competitiveGroups has only one value
arg0 has only one value
arg0.toString == "whitespaces"
arg1 has only one value
arg1.sequence has only one value
arg1.sequence[] contains no nulls and has only one value, of length 1
arg1.sequence[] elements has only one value
arg1.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
arg1.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
arg1.constraints == null
arg1.nullable == false
arg1.repeatable == true
arg1.rule has only one value
arg1.rule.symbols has only one value
arg1.rule.symbols[] contains no nulls and has only one value, of length 2
arg1.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance == -1
size(arg1.sequence[]) == 1
size(arg1.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.addIgnoringConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.inited == orig(this.inited)
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar.getClass().getName() == arg1.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg1.sequence.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
arg0.toString == orig(arg0.toString)
arg1.sequence == orig(arg1.sequence)
arg1.sequence[] == orig(arg1.sequence[])
arg1.constraints == orig(arg1.constraints)
arg1.nullable == orig(arg1.nullable)
arg1.repeatable == orig(arg1.repeatable)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.fixedLength == orig(arg1.fixedLength)
arg1.startLength == orig(arg1.startLength)
arg1.variance == orig(arg1.variance)
size(this.itemsWithoutStartChar[])-1 == orig(size(this.itemsWithoutStartChar[]))
this.inited == false
this.itemsWithStartChar has only one value
this.itemsWithoutStartChar has only one value
this.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.itemsWithoutStartChar[] elements has only one value
this.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.competitiveGroups has only one value
arg0.toString == "whitespaces"
arg1.sequence has only one value
arg1.sequence[] contains no nulls and has only one value, of length 1
arg1.sequence[] elements has only one value
arg1.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
arg1.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
arg1.constraints == null
arg1.nullable == false
arg1.repeatable == true
arg1.rule has only one value
arg1.rule.symbols has only one value
arg1.rule.symbols[] contains no nulls and has only one value, of length 2
arg1.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance == -1
size(this.itemsWithoutStartChar[]) == 1
size(arg1.sequence[]) == 1
size(arg1.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.addTokenConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::ENTER
this.itemsWithoutStartChar.getClass().getName() == arg1.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.inited == false
this.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
arg1.constraints == null
arg1.nullable == false
arg1.repeatable == false
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance one of { -1, 1 }
size(this.itemsWithoutStartChar[]) one of { 0, 1 }
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.addTokenConsumer(java.lang.String, fri.patterns.interpreter.parsergenerator.lexer.Consumer):::EXIT
this.inited == orig(this.inited)
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar.getClass().getName() == arg1.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg1.rule.symbols.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg1.sequence.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
arg0.toString == orig(arg0.toString)
arg1.sequence == orig(arg1.sequence)
arg1.sequence[] == orig(arg1.sequence[])
arg1.constraints == orig(arg1.constraints)
arg1.nullable == orig(arg1.nullable)
arg1.repeatable == orig(arg1.repeatable)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.fixedLength == orig(arg1.fixedLength)
arg1.startLength == orig(arg1.startLength)
arg1.variance == orig(arg1.variance)
this.inited == false
arg1.constraints == null
arg1.nullable == false
arg1.repeatable == false
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.fixedLength == -1
arg1.startLength == -1
arg1.variance one of { -1, 1 }
size(arg1.sequence[]) one of { 1, 2 }
size(arg1.rule.symbols[]) one of { 2, 3 }
size(this.itemsWithoutStartChar[]) >= orig(size(this.itemsWithoutStartChar[]))
size(this.itemsWithoutStartChar[])-1 <= orig(size(this.itemsWithoutStartChar[]))
size(this.itemsWithoutStartChar[])-1 >= orig(size(this.itemsWithoutStartChar[]))-1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText, int, java.util.Map):::ENTER
this.itemsWithoutStartChar.getClass().getName() == arg0.lineLengths.getClass().getName()
arg0.column == arg0.readOffset
arg1 == arg0.line[arg0.column-1]
arg1 == arg0.line[arg0.readOffset-1]
arg1 == arg0.buffer[arg0.readPos]
arg1 == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1]
arg0 has only one value
arg0.line has only one value
arg0.line[] one of { [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.column one of { 1, 6, 7 }
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint == null
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
arg0.eof == false
arg0.buffering == true
arg1 one of { 32, 72, 87 }
arg2.getClass().getName() == java.util.Hashtable.class
size(arg0.line[]) == 64
size(arg0.buffer[]) == 128
arg0.line[arg0.column] == 0
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 0, 101, 108 }
arg0.buffer[arg0.column-1] one of { 0, 72 }
this.itemsWithoutStartChar.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.column > arg0.readPos
arg0.column >= arg0.readLen
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.readPos < arg0.readLen
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
arg1 > arg0.line[arg0.column]
arg1 != arg0.line[arg0.readLen]
arg0.buffer[arg0.column-1] % arg1 == 0
arg1 >= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] < arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.readPos] != arg0.line[arg0.readLen]
arg0.line[arg0.readPos] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readPos] != arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.buffer[arg0.column-1] != arg0.buffer[arg0.readLen]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText, int, java.util.Map):::EXIT163
this.itemsWithoutStartChar.getClass().getName() == return.result.sequenceList.getClass().getName()
arg0.readPos one of { 1, 5 }
orig(arg0.buffer[]) one of { [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [87, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
orig(arg0.readPos) == 0
orig(arg0.readLen) == 1
arg0.line[arg0.readPos] one of { 0, 32, 101 }
arg0.line[arg0.readPos-1] one of { 72, 111 }
arg0.line[orig(arg0.readPos)] == 72
arg0.line[orig(arg0.readLen)] == 101
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32 }
arg0.buffer[arg0.readPos] one of { 0, 87, 101 }
arg0.buffer[arg0.readPos-1] one of { 32, 100, 111 }
arg0.buffer[orig(arg0.readLen)] one of { 87, 101, 111 }
orig(arg0.line[post(arg0.readPos)-1]) one of { 0, 72, 111 }
orig(arg0.buffer[post(arg0.readPos)]) one of { 0, 101 }
orig(arg0.buffer[post(arg0.readPos)-1]) one of { 0, 32, 111 }
orig(arg0.line[arg0.readLen]) one of { 0, 101 }
orig(arg0.buffer[arg0.readLen]) one of { 0, 87, 101 }
arg0.buffer[arg0.readPos-1] in arg0.line[]
orig(arg0.line[post(arg0.readPos)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)-1]) in arg0.buffer[]
arg0.readLen % arg0.readPos == 0
orig(arg0.buffer[post(arg0.readPos)-1]) in orig(arg0.line[])
orig(arg0.line[post(arg0.readPos)-1]) % arg0.line[arg0.readPos-1] == 0
arg0.buffer[arg0.column-1] % arg0.buffer[arg0.readPos-1] == 0
orig(arg0.line[post(arg0.column)-1]) % arg0.buffer[arg0.readPos-1] == 0
arg0.buffer[arg0.readPos] % arg0.buffer[orig(arg0.readLen)] == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText, int, java.util.Map):::EXIT171
this.inited == orig(this.inited)
this.itemsWithoutStartChar.getClass().getName() == return.result.sequenceList.getClass().getName()
arg0.readPos == orig(arg0.readLen)
orig(arg1) == arg0.buffer[arg0.readPos-1]
orig(arg1) == orig(arg0.buffer[post(arg0.readPos)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.column-1]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)-1]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.readOffset)-1])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column-1])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset-1])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.readPos] == orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.readPos] == orig(arg0.line[arg0.readLen])
arg0.line[arg0.readPos] == orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readPos-1] == arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readPos-1] == orig(arg0.line[post(arg0.readPos)-1])
arg0.line[arg0.readPos-1] == orig(arg0.line[arg0.readPos])
arg0.line[arg0.readPos-1] == orig(arg0.line[arg0.readLen-1])
arg0.line[arg0.readLen] == arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.line[arg0.readOffset-1] == arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.column)] == arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readOffset)] == arg0.buffer[arg0.readPos]
arg0.buffer[arg0.readPos] == arg0.buffer[arg0.readLen-1]
this.itemsWithStartChar has only one value
this.itemsWithoutStartChar has only one value
this.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.itemsWithoutStartChar[] elements has only one value
this.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.competitiveGroups has only one value
arg0.line[] == [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
arg0.column == 7
arg0.scanPoint has only one value
arg0.scanPoint[] == [1, 6]
arg0.scanPoint[] elements one of { 1, 6 }
arg0.buffer[] == [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
arg0.readPos == 1
arg0.readLen == 2
return has only one value
return.symbol has only one value
return.symbol.toString == "whitespaces"
return.consumer has only one value
return.consumer.sequence has only one value
return.consumer.sequence[] contains no nulls and has only one value, of length 1
return.consumer.sequence[] elements has only one value
return.consumer.sequence[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives]
return.consumer.sequence[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives.class
return.consumer.repeatable == true
return.consumer.rule has only one value
return.consumer.startLength == -1
return.consumer.variance == -1
return.result has only one value
return.result.sequenceList has only one value
return.result.sequenceList[] contains no nulls and has only one value, of length 1
return.result.sequenceList[] elements has only one value
return.result.sequenceList[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.ResultTree]
return.result.sequenceList[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.ResultTree.class
return.result.range has only one value
return.result.buffer == null
orig(this) has only one value
orig(arg0.line[]) == [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
orig(arg0.column) == 6
orig(arg0.buffer[]) == [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
orig(arg0.readPos) == 0
orig(arg1) == 32
orig(arg2) has only one value
size(this.itemsWithoutStartChar[]) == 1
arg0.line[arg0.readPos] == 101
arg0.line[arg0.readPos-1] == 72
arg0.line[arg0.readLen] == 108
arg0.buffer[arg0.readPos] == 87
arg0.readPos in arg0.scanPoint[]
orig(arg0.column) in arg0.scanPoint[]
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText, int, java.util.Map):::EXIT173
arg0.line[] == orig(arg0.line[])
arg0.column == orig(arg0.column)
arg0.column == orig(arg0.readOffset)
arg0.scanPoint == orig(arg0.scanPoint)
arg0.buffer[] == orig(arg0.buffer[])
arg0.readPos == orig(arg0.readPos)
arg0.readLen == orig(arg0.readLen)
orig(arg1) == arg0.line[arg0.column-1]
orig(arg1) == arg0.line[arg0.readOffset-1]
orig(arg1) == orig(arg0.line[post(arg0.column)-1])
orig(arg1) == arg0.buffer[arg0.readPos]
orig(arg1) == arg0.buffer[arg0.readLen-1]
orig(arg1) == orig(arg0.buffer[post(arg0.readPos)])
orig(arg1) == orig(arg0.buffer[post(arg0.readLen)-1])
orig(arg1) == orig(arg0.line[post(arg0.readOffset)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.column-1]
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)]
arg0.line[arg0.column] == arg0.buffer[orig(arg0.readOffset)-1]
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column-1])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset-1])
arg0.line[arg0.readPos] == arg0.line[arg0.readLen-1]
arg0.line[arg0.readPos] == arg0.line[orig(arg0.readLen)-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.readPos] == orig(arg0.line[arg0.readLen-1])
arg0.line[arg0.readLen] == arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] == arg0.buffer[orig(arg0.readLen)]
arg0.line[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.line[arg0.readLen] == orig(arg0.buffer[arg0.readLen])
this.itemsWithoutStartChar[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item, fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item] }
arg0.line[] one of { [72, 101, 108, 108, 111, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [72, 101, 108, 108, 111, 32, 87, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.column one of { 6, 7 }
arg0.scanPoint == null
arg0.buffer[] one of { [32, 87, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [32, 101, 108, 108, 111, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
arg0.readPos one of { 0, 1 }
arg0.readLen one of { 1, 2 }
return == null
orig(arg1) one of { 32, 87 }
orig(arg2) == null
size(this.itemsWithoutStartChar[]) one of { 0, 2 }
arg0.line[arg0.readPos] one of { 72, 101 }
arg0.line[arg0.readLen] one of { 101, 108 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.consume(fri.patterns.interpreter.parsergenerator.lexer.InputText, int, java.util.Map):::EXIT
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar[] == orig(this.itemsWithoutStartChar[])
this.itemsWithoutStartChar.getClass().getName() == arg0.lineLengths.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == return.consumer.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg0.lineLengths.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
arg0.line == orig(arg0.line)
arg0.prevLine == orig(arg0.prevLine)
arg0.prevLength == orig(arg0.prevLength)
arg0.wasCr == orig(arg0.wasCr)
arg0.column == arg0.readOffset
arg0.lineLengths == orig(arg0.lineLengths)
arg0.lineLengths[] == orig(arg0.lineLengths[])
arg0.inputStream == orig(arg0.inputStream)
arg0.reader == orig(arg0.reader)
arg0.reader.getClass().getName() == orig(arg0.reader.getClass().getName())
arg0.buffer == orig(arg0.buffer)
arg0.eof == orig(arg0.eof)
arg0.buffering == orig(arg0.buffering)
return.consumer.sequence.getClass().getName() == return.result.sequenceList.getClass().getName()
return.consumer.rule == return.result.rule
orig(arg1) == arg0.line[orig(arg0.column)-1]
orig(arg1) == arg0.line[orig(arg0.readOffset)-1]
orig(arg1) == arg0.buffer[orig(arg0.readPos)]
orig(arg1) == arg0.buffer[orig(arg0.readLen)-1]
size(arg0.line[]) == orig(size(arg0.line[]))
size(arg0.buffer[]) == orig(size(arg0.buffer[]))
arg0.line[arg0.column] == arg0.buffer[arg0.column]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.column)-1])
arg0.line[arg0.column] == arg0.buffer[arg0.readOffset]
arg0.line[arg0.column] == orig(arg0.line[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)])
arg0.line[arg0.column] == orig(arg0.buffer[post(arg0.readOffset)-1])
arg0.line[arg0.column] == orig(arg0.line[arg0.column])
arg0.line[arg0.column] == orig(arg0.line[arg0.readOffset])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.column])
arg0.line[arg0.column] == orig(arg0.buffer[arg0.readOffset])
arg0.line[arg0.column-1] == arg0.buffer[arg0.readLen-1]
arg0.line[arg0.readPos] == orig(arg0.line[post(arg0.readPos)])
arg0.line[arg0.readLen] == orig(arg0.line[post(arg0.readLen)])
arg0.line[orig(arg0.readPos)] == arg0.line[orig(arg0.readLen)-1]
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readPos])
arg0.line[orig(arg0.readPos)] == orig(arg0.line[arg0.readLen-1])
arg0.buffer[arg0.readLen] == orig(arg0.buffer[post(arg0.readLen)])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.column-1])
arg0.buffer[orig(arg0.column)-1] == orig(arg0.buffer[arg0.readOffset-1])
this.inited == true
arg0.line has only one value
arg0.line[] elements >= 0
arg0.prevLine == null
arg0.prevLength == 0
arg0.wasCr == false
arg0.lineLengths has only one value
arg0.lineLengths[] == []
arg0.lineLengths[].getClass().getName() == []
arg0.scanPoint[] one of { [1, 5], [1, 6], [1, 11] }
arg0.scanPoint[] elements >= 1
arg0.inputStream == null
arg0.reader has only one value
arg0.reader.getClass().getName() == java.io.StringReader.class
arg0.buffer has only one value
arg0.buffer[] elements >= 0
arg0.readPos one of { 0, 1, 5 }
arg0.readLen one of { 1, 2, 5 }
arg0.eof == false
arg0.buffering == true
return.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
return.consumer.sequence.getClass().getName() == java.util.ArrayList.class
return.consumer.constraints == null
return.consumer.nullable == false
return.consumer.fixedLength == -1
return.consumer.startLength one of { -1, 1 }
return.consumer.variance one of { -1, 1, 3 }
return.result.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
return.result.stringResult == null
size(arg0.line[]) == 64
size(arg0.scanPoint[]) == 2
size(arg0.buffer[]) == 128
size(return.consumer.sequence[]) == 1
size(return.result.sequenceList[]) == 1
arg0.line[arg0.column] == 0
arg0.line[arg0.readLen-1] one of { 72, 101, 111 }
arg0.line[orig(arg0.readPos)] one of { 72, 101 }
arg0.line[orig(arg0.readLen)] one of { 101, 108 }
arg0.buffer[arg0.column-1] one of { 0, 111 }
orig(arg0.line[post(arg0.column)-1]) one of { 0, 32, 87 }
arg0.buffer[arg0.readLen] one of { 0, 101, 108 }
arg0.buffer[orig(arg0.column)] one of { 0, 101 }
arg0.buffer[orig(arg0.column)-1] one of { 0, 72 }
this.itemsWithoutStartChar.getClass().getName() != arg0.reader.getClass().getName()
arg0.line[] >= orig(arg0.line[]) (elementwise)
arg0.line[] elements >= arg0.line[arg0.column]
arg0.buffer[arg0.column-1] in arg0.line[]
orig(arg0.line[post(arg0.column)-1]) in arg0.line[]
arg0.buffer[arg0.readPos] in arg0.line[]
arg0.buffer[arg0.readLen] in arg0.line[]
arg0.buffer[orig(arg0.column)] in arg0.line[]
arg0.buffer[orig(arg0.column)-1] in arg0.line[]
arg0.buffer[orig(arg0.readLen)] in arg0.line[]
orig(arg0.buffer[post(arg0.readPos)]) in arg0.line[]
orig(arg0.line[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.buffer[post(arg0.readLen)-1]) in arg0.line[]
orig(arg0.line[arg0.readLen]) in arg0.line[]
orig(arg0.buffer[arg0.readLen]) in arg0.line[]
arg0.column >= arg0.readPos
arg0.column >= arg0.readLen
arg0.column >= orig(arg0.column)
arg0.column > orig(arg0.readPos)
arg0.column > orig(arg0.readLen)
arg0.column < size(arg0.line[])-1
arg0.column < size(arg0.buffer[])-1
orig(arg0.readLen) in arg0.scanPoint[]
arg0.buffer[] elements >= arg0.line[arg0.column]
arg0.line[orig(arg0.column)] in arg0.buffer[]
orig(arg0.line[post(arg0.column)-1]) in arg0.buffer[]
arg0.readPos <= arg0.readLen
arg0.readPos != orig(arg0.column)
arg0.readPos >= orig(arg0.readPos)
arg0.readPos < size(arg0.line[])-1
arg0.readPos < size(arg0.buffer[])-1
arg0.readLen != orig(arg0.column)
arg0.readLen > orig(arg0.readPos)
arg0.readLen % orig(arg0.readLen) == 0
arg0.readLen >= orig(arg0.readLen)
arg0.readLen < size(arg0.line[])-1
arg0.readLen < size(arg0.buffer[])-1
orig(arg0.line[]) elements >= arg0.line[arg0.column]
arg0.buffer[arg0.readLen] in orig(arg0.line[])
arg0.buffer[orig(arg0.column)-1] in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readPos)]) in orig(arg0.line[])
orig(arg0.buffer[post(arg0.readLen)-1]) in orig(arg0.line[])
orig(arg0.column) < size(arg0.line[])-1
orig(arg0.column) < size(arg0.buffer[])-1
orig(arg0.buffer[]) elements >= arg0.line[arg0.column]
orig(arg0.line[post(arg0.column)-1]) in orig(arg0.buffer[])
orig(arg0.readPos) < size(arg0.line[])-1
orig(arg0.readPos) < size(arg0.buffer[])-1
orig(arg0.readLen) < size(arg0.line[])-1
orig(arg0.readLen) < size(arg0.buffer[])-1
orig(arg1) > arg0.line[arg0.column]
orig(arg1) <= arg0.line[arg0.column-1]
orig(arg1) != arg0.line[arg0.readPos]
orig(arg1) != arg0.line[arg0.readLen]
orig(arg1) < arg0.line[arg0.readLen-1]
orig(arg1) != arg0.line[orig(arg0.column)]
orig(arg1) < arg0.line[orig(arg0.readLen)]
orig(arg1) != arg0.buffer[arg0.column-1]
orig(arg0.line[post(arg0.column)-1]) % orig(arg1) == 0
orig(arg1) >= orig(arg0.line[post(arg0.column)-1])
orig(arg1) != arg0.buffer[arg0.readLen]
orig(arg1) != arg0.buffer[orig(arg0.column)]
arg0.buffer[orig(arg0.column)-1] % orig(arg1) == 0
orig(arg1) >= arg0.buffer[orig(arg0.column)-1]
orig(arg1) < arg0.buffer[orig(arg0.readLen)]
orig(arg1) != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column] < arg0.line[arg0.column-1]
arg0.line[arg0.column] <= arg0.line[arg0.readPos]
arg0.line[arg0.column] <= arg0.line[arg0.readLen]
arg0.line[arg0.column] < arg0.line[arg0.readLen-1]
arg0.line[arg0.column] < arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column] < arg0.line[orig(arg0.readLen)]
arg0.line[arg0.column] <= arg0.buffer[arg0.column-1]
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.column] <= arg0.buffer[arg0.readPos]
arg0.line[arg0.column] <= arg0.buffer[arg0.readLen]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column] <= arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column] < arg0.buffer[orig(arg0.readLen)]
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.column] <= orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[arg0.column] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.column] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.column-1] != arg0.line[arg0.readPos]
arg0.line[arg0.column-1] != arg0.line[arg0.readLen]
arg0.line[arg0.column-1] <= arg0.line[arg0.readLen-1]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.column-1] != arg0.line[orig(arg0.readLen)]
arg0.buffer[arg0.column-1] % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] >= arg0.buffer[arg0.column-1]
orig(arg0.line[post(arg0.column)-1]) % arg0.line[arg0.column-1] == 0
arg0.line[arg0.column-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.column-1] > arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.line[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.line[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readPos] <= arg0.line[arg0.readLen]
arg0.line[arg0.readPos] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readPos] <= arg0.line[orig(arg0.readLen)]
arg0.line[arg0.readPos] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readPos] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readPos] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readPos] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readPos] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.line[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.line[arg0.readLen] != arg0.line[arg0.readLen-1]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.line[orig(arg0.readPos)]
arg0.line[arg0.readLen] != arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen] >= orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen] >= arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen] != arg0.buffer[orig(arg0.column)-1]
arg0.line[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.column)]
arg0.line[arg0.readLen-1] >= arg0.line[orig(arg0.readPos)]
arg0.buffer[arg0.column-1] % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= arg0.buffer[arg0.column-1]
arg0.line[arg0.readLen-1] > orig(arg0.line[post(arg0.column)-1])
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readPos]
arg0.line[arg0.readLen-1] != arg0.buffer[arg0.readLen]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)]
arg0.line[arg0.readLen-1] > arg0.buffer[orig(arg0.column)-1]
orig(arg0.line[post(arg0.readLen)-1]) % arg0.line[arg0.readLen-1] == 0
arg0.line[arg0.readLen-1] >= orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[orig(arg0.column)] != arg0.line[orig(arg0.readPos)]
arg0.line[orig(arg0.column)] != orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.column)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readPos)] < arg0.line[orig(arg0.readLen)]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readPos)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readPos)] != arg0.buffer[arg0.readLen]
arg0.line[orig(arg0.readPos)] != arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readPos)] >= arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readPos)] < arg0.buffer[orig(arg0.readLen)]
arg0.line[orig(arg0.readPos)] != orig(arg0.buffer[post(arg0.readPos)])
arg0.line[orig(arg0.readPos)] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.line[orig(arg0.readPos)] != orig(arg0.line[arg0.readLen])
arg0.line[orig(arg0.readPos)] != orig(arg0.buffer[arg0.readLen])
arg0.line[orig(arg0.readLen)] != arg0.buffer[arg0.column-1]
arg0.line[orig(arg0.readLen)] > orig(arg0.line[post(arg0.column)-1])
arg0.line[orig(arg0.readLen)] >= arg0.buffer[arg0.readPos]
arg0.line[orig(arg0.readLen)] >= arg0.buffer[orig(arg0.column)]
arg0.line[orig(arg0.readLen)] > arg0.buffer[orig(arg0.column)-1]
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[arg0.readLen]) % arg0.line[orig(arg0.readLen)] == 0
arg0.line[orig(arg0.readLen)] >= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)]
arg0.buffer[arg0.column-1] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[arg0.column-1] != arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.column-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[arg0.column-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.column-1] != orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readPos]
orig(arg0.line[post(arg0.column)-1]) <= arg0.buffer[arg0.readLen]
orig(arg0.line[post(arg0.column)-1]) < arg0.buffer[orig(arg0.readLen)]
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readPos)])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[post(arg0.readLen)-1])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.line[arg0.readLen])
orig(arg0.line[post(arg0.column)-1]) <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readPos] <= arg0.buffer[arg0.readLen]
arg0.buffer[arg0.readPos] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[arg0.readPos] <= orig(arg0.line[arg0.readLen])
arg0.buffer[arg0.readPos] <= orig(arg0.buffer[arg0.readLen])
arg0.buffer[arg0.readLen] >= orig(arg0.buffer[post(arg0.readPos)])
arg0.buffer[orig(arg0.column)] >= arg0.buffer[orig(arg0.column)-1]
arg0.buffer[orig(arg0.column)] % arg0.buffer[orig(arg0.readLen)] == 0
arg0.buffer[orig(arg0.column)] <= arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)] != orig(arg0.buffer[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] < arg0.buffer[orig(arg0.readLen)]
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[post(arg0.readLen)-1])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.line[arg0.readLen])
arg0.buffer[orig(arg0.column)-1] != orig(arg0.buffer[arg0.readLen])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.line[arg0.readLen])
orig(arg0.buffer[post(arg0.readPos)]) <= orig(arg0.buffer[arg0.readLen])
orig(arg0.line[post(arg0.readLen)-1]) >= orig(arg0.buffer[post(arg0.readLen)-1])
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.getItemsWithStartCharacter(int):::ENTER
arg0 one of { 32, 72, 87 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.getItemsWithStartCharacter(int):::EXIT
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar[] == orig(this.itemsWithoutStartChar[])
this.itemsWithoutStartChar.getClass().getName() == return.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
this.inited == true
return[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
return.getClass().getName() == java.util.ArrayList.class
size(return[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.getItemsWithoutStartCharacter():::ENTER
this.inited == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.getItemsWithoutStartCharacter():::EXIT
this.inited == orig(this.inited)
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == return
this.itemsWithoutStartChar[] == orig(this.itemsWithoutStartChar[])
this.itemsWithoutStartChar.getClass().getName() == return.getClass().getName()
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
return == orig(this.itemsWithoutStartChar)
return.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.inited == true
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
return.getClass().getName() == java.util.ArrayList.class
size(return[]) one of { 0, 1, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.hasTerminal(java.lang.String):::ENTER
this has only one value
this.inited == false
this.itemsWithStartChar has only one value
this.itemsWithoutStartChar has only one value
this.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.itemsWithoutStartChar[] elements has only one value
this.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.competitiveGroups has only one value
arg0.toString one of { "\"Hello\"", "\"World\"" }
size(this.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.hasTerminal(java.lang.String):::EXIT67
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.hasTerminal(java.lang.String):::EXIT67;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.hasTerminal(java.lang.String):::EXIT
this.inited == orig(this.inited)
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar[] == orig(this.itemsWithoutStartChar[])
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
arg0.toString == orig(arg0.toString)
this.inited == false
this.itemsWithStartChar has only one value
this.itemsWithoutStartChar has only one value
this.itemsWithoutStartChar[] contains no nulls and has only one value, of length 1
this.itemsWithoutStartChar[] elements has only one value
this.itemsWithoutStartChar[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
this.competitiveGroups has only one value
arg0.toString one of { "\"Hello\"", "\"World\"" }
return == false
size(this.itemsWithoutStartChar[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.hasTerminal(java.lang.String):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.init():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.init():::EXIT
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar[] == orig(this.itemsWithoutStartChar[])
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
this.inited == true
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.initCompetitors(fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item):::ENTER
this.itemsWithoutStartChar.getClass().getName() == arg0.consumer.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg0.result.sequenceList.getClass().getName()
arg0.consumer.rule == arg0.result.rule
this.inited == true
arg0.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
arg0.consumer.constraints == null
arg0.consumer.nullable == false
arg0.consumer.fixedLength == -1
arg0.consumer.startLength one of { -1, 1 }
arg0.consumer.variance one of { -1, 1, 3 }
arg0.result.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
arg0.result.stringResult == null
size(arg0.consumer.sequence[]) == 1
size(arg0.result.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.initCompetitors(fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item):::EXIT126
===========================================================================
fri.patterns.interpreter.parsergenerator.lexer.Strategy.initCompetitors(fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item):::EXIT
this.inited == orig(this.inited)
this.itemsWithStartChar == orig(this.itemsWithStartChar)
this.itemsWithoutStartChar == orig(this.itemsWithoutStartChar)
this.itemsWithoutStartChar[] == orig(this.itemsWithoutStartChar[])
this.itemsWithoutStartChar.getClass().getName() == arg0.consumer.sequence.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == arg0.result.sequenceList.getClass().getName()
this.itemsWithoutStartChar.getClass().getName() == orig(this.itemsWithoutStartChar.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg0.consumer.sequence.getClass().getName())
this.itemsWithoutStartChar.getClass().getName() == orig(arg0.result.sequenceList.getClass().getName())
this.competitiveGroups == orig(this.competitiveGroups)
this.competeForLongestInput == orig(this.competeForLongestInput)
arg0.symbol == orig(arg0.symbol)
arg0.symbol.toString == orig(arg0.symbol.toString)
arg0.consumer == orig(arg0.consumer)
arg0.consumer.sequence == orig(arg0.consumer.sequence)
arg0.consumer.sequence[] == orig(arg0.consumer.sequence[])
arg0.consumer.constraints == orig(arg0.consumer.constraints)
arg0.consumer.nullable == orig(arg0.consumer.nullable)
arg0.consumer.repeatable == orig(arg0.consumer.repeatable)
arg0.consumer.rule == arg0.result.rule
arg0.consumer.rule == orig(arg0.consumer.rule)
arg0.consumer.rule == orig(arg0.result.rule)
arg0.consumer.fixedLength == orig(arg0.consumer.fixedLength)
arg0.consumer.startLength == orig(arg0.consumer.startLength)
arg0.consumer.variance == orig(arg0.consumer.variance)
arg0.result == orig(arg0.result)
arg0.result.sequenceList == orig(arg0.result.sequenceList)
arg0.result.sequenceList[] == orig(arg0.result.sequenceList[])
arg0.result.range == orig(arg0.result.range)
arg0.result.buffer == orig(arg0.result.buffer)
arg0.result.stringResult == orig(arg0.result.stringResult)
this.inited == true
arg0.consumer.sequence[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ConsumerAlternatives], [java.lang.String] }
arg0.consumer.constraints == null
arg0.consumer.nullable == false
arg0.consumer.fixedLength == -1
arg0.consumer.startLength one of { -1, 1 }
arg0.consumer.variance one of { -1, 1, 3 }
arg0.result.sequenceList[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.lexer.ResultTree], [java.lang.StringBuffer] }
arg0.result.stringResult == null
return == null
size(arg0.consumer.sequence[]) == 1
size(arg0.result.sequenceList[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables:::CLASS
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables:::OBJECT
this.syntax.rules.getClass().getName() == this.gotoTable.getClass().getName()
this.gotoTable.getClass().getName() == this.parseTable.getClass().getName()
this.gotoTable.getClass().getName() == this.symbols.getClass().getName()
this.symbols.getClass().getName() == this.terminals.getClass().getName()
this.symbols.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.symbols.getClass().getName() == this.nonterminals.getClass().getName()
this has only one value
this.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
this.syntax.rules has only one value
this.syntax.rules != null
this.syntax.rules[] contains no nulls and has only one value, of length 2
this.syntax.rules[] elements != null
this.syntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.syntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.syntax.ruleHash has only one value
this.syntax.ruleHash != null
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.gotoTable.getClass().getName() == java.util.ArrayList.class
this.parseTable[] contains no nulls and has only one value, of length 4
this.parseTable[] elements != null
this.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
this.parseTable[].getClass().getName() elements == java.util.Hashtable.class
this.symbols has only one value
this.symbols != null
this.symbols[] elements != null
this.symbols[].getClass().getName() elements == java.lang.String.class
this.symbols[].getClass().getName() one of { [], [java.lang.String, java.lang.String, java.lang.String, java.lang.String] }
this.symbols.getClass().getName() == java.util.ArrayList.class
this.terminals has only one value
this.terminals != null
this.terminals[] elements != null
this.terminals[].getClass().getName() elements == java.lang.String.class
this.terminals[].getClass().getName() one of { [], [java.lang.String, java.lang.String, java.lang.String] }
this.terminalsWithoutEpsilon has only one value
this.terminalsWithoutEpsilon != null
this.terminalsWithoutEpsilon[] elements != null
this.terminalsWithoutEpsilon[].getClass().getName() elements == java.lang.String.class
this.terminalsWithoutEpsilon[].getClass().getName() one of { [], [java.lang.String, java.lang.String] }
this.nonterminals has only one value
this.nonterminals != null
this.nonterminals[] elements != null
this.nonterminals[].getClass().getName() elements == java.lang.String.class
this.nonterminals[].getClass().getName() one of { [], [java.lang.String, java.lang.String] }
this.f == null
size(this.syntax.rules[]) == 2
size(this.gotoTable[]) == 4
size(this.parseTable[]) == 4
size(this.symbols[]) one of { 0, 4 }
size(this.symbols[])-1 != 0
size(this.terminals[]) one of { 0, 3 }
size(this.terminals[])-1 != 0
size(this.terminalsWithoutEpsilon[]) one of { 0, 2 }
size(this.terminalsWithoutEpsilon[])-1 != 0
size(this.nonterminals[]) one of { 0, 2 }
size(this.nonterminals[])-1 != 0
this.getClass().getName() != this.gotoTable.getClass().getName()
this.getClass().getName() != this.symbols.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.AbstractParserTables():::EXIT
this.syntax == null
this.gotoTable == null
this.parseTable == null
this.symbols[] == []
this.symbols[].getClass().getName() == []
this.terminals[] == []
this.terminals[].getClass().getName() == []
this.terminalsWithoutEpsilon[] == []
this.terminalsWithoutEpsilon[].getClass().getName() == []
this.nonterminals[] == []
this.nonterminals[].getClass().getName() == []
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.construct(java.lang.Class, fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
arg0 has only one value
arg1 has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 1
arg1.rules[] elements has only one value
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
size(arg1.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.construct(java.lang.Class, fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT121
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.construct(java.lang.Class, fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
arg1.rules == return.syntax.rules
arg1.rules == orig(arg1.rules)
arg1.rules.getClass().getName() == return.syntax.rules.getClass().getName()
arg1.rules.getClass().getName() == return.gotoTable.getClass().getName()
arg1.rules.getClass().getName() == return.parseTable.getClass().getName()
arg1.rules.getClass().getName() == return.symbols.getClass().getName()
arg1.rules.getClass().getName() == return.terminals.getClass().getName()
arg1.rules.getClass().getName() == return.terminalsWithoutEpsilon.getClass().getName()
arg1.rules.getClass().getName() == return.nonterminals.getClass().getName()
arg1.rules.getClass().getName() == orig(arg1.rules.getClass().getName())
arg1.ruleHash == return.syntax.ruleHash
arg1.ruleHash == orig(arg1.ruleHash)
return.syntax == orig(arg1)
size(arg1.rules[])-1 == orig(size(arg1.rules[]))
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 2
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
return has only one value
return.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.class
return.syntax has only one value
return.syntax.rules[] contains no nulls and has only one value, of length 2
return.syntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.syntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.gotoTable has only one value
return.gotoTable[] has only one value, of length 4
return.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
return.parseTable has only one value
return.parseTable[] contains no nulls and has only one value, of length 4
return.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
return.parseTable[].getClass().getName() elements == java.util.Hashtable.class
return.symbols has only one value
return.symbols[] contains no nulls and has only one value, of length 4
return.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
return.symbols[].getClass().getName() elements == java.lang.String.class
return.terminals has only one value
return.terminals[] contains no nulls and has only one value, of length 3
return.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
return.terminals[].getClass().getName() elements == java.lang.String.class
return.terminalsWithoutEpsilon has only one value
return.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
return.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
return.terminalsWithoutEpsilon[].getClass().getName() elements == java.lang.String.class
return.nonterminals has only one value
return.nonterminals[] contains no nulls and has only one value, of length 2
return.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
return.nonterminals[].getClass().getName() elements == java.lang.String.class
return.f == null
size(arg1.rules[]) == 2
size(return.syntax.rules[]) == 2
size(return.gotoTable[]) == 4
size(return.parseTable[]) == 4
size(return.symbols[]) == 4
size(return.terminals[]) == 3
size(return.terminalsWithoutEpsilon[]) == 2
size(return.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getExpected(java.lang.Integer):::ENTER
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getExpected(java.lang.Integer):::EXIT
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.gotoTable[] == orig(this.gotoTable[])
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.gotoTable.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.gotoTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.parseTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.symbols.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminals.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.nonterminals.getClass().getName())
this.parseTable == orig(this.parseTable)
this.parseTable[] == orig(this.parseTable[])
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
return.getClass().getName() == java.util.Hashtable.class
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
return.getClass().getName() in this.gotoTable[].getClass().getName()
return.getClass().getName() in this.parseTable[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getGotoState(java.lang.Integer, java.lang.String):::ENTER
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.toString one of { "\"Hello\"", "\"World\"", "Start" }
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getGotoState(java.lang.Integer, java.lang.String):::EXIT
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.gotoTable[] == orig(this.gotoTable[])
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.gotoTable.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.gotoTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.parseTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.symbols.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminals.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.nonterminals.getClass().getName())
this.parseTable == orig(this.parseTable)
this.parseTable[] == orig(this.parseTable[])
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
arg1.toString == orig(arg1.toString)
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.toString one of { "\"Hello\"", "\"World\"", "Start" }
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getParseAction(java.lang.Integer, java.lang.String):::ENTER
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getParseAction(java.lang.Integer, java.lang.String):::EXIT
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.gotoTable[] == orig(this.gotoTable[])
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.gotoTable.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.gotoTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.parseTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.symbols.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminals.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.nonterminals.getClass().getName())
this.parseTable == orig(this.parseTable)
this.parseTable[] == orig(this.parseTable[])
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
arg1.toString == orig(arg1.toString)
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getSyntax():::ENTER
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getSyntax():::EXIT
this.syntax == return
this.syntax.rules == return.rules
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.ruleHash == return.ruleHash
this.gotoTable == orig(this.gotoTable)
this.gotoTable[] == orig(this.gotoTable[])
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.gotoTable.getClass().getName() == return.rules.getClass().getName()
this.gotoTable.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.gotoTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.parseTable.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.symbols.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminals.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.gotoTable.getClass().getName() == orig(this.nonterminals.getClass().getName())
this.parseTable == orig(this.parseTable)
this.parseTable[] == orig(this.parseTable[])
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
return == orig(this.syntax)
return.rules == orig(this.syntax.rules)
return.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
return has only one value
return.rules has only one value
return.rules[] contains no nulls and has only one value, of length 2
return.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.ruleHash has only one value
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(return.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getTerminals():::ENTER
this.gotoTable.getClass().getName() == this.terminals.getClass().getName()
this.gotoTable.getClass().getName() == this.terminalsWithoutEpsilon.getClass().getName()
this.gotoTable.getClass().getName() == this.nonterminals.getClass().getName()
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.getTerminals():::EXIT
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == return.getClass().getName()
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.gotoTable[] == orig(this.gotoTable[])
this.gotoTable.getClass().getName() == return.getClass().getName()
this.parseTable == orig(this.parseTable)
this.parseTable[] == orig(this.parseTable[])
this.parseTable.getClass().getName() == return.getClass().getName()
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == return.getClass().getName()
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == return.getClass().getName()
this.terminalsWithoutEpsilon == return
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == return.getClass().getName()
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == return.getClass().getName()
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
return == orig(this.terminalsWithoutEpsilon)
return.getClass().getName() == orig(this.syntax.rules.getClass().getName())
return.getClass().getName() == orig(this.gotoTable.getClass().getName())
return.getClass().getName() == orig(this.parseTable.getClass().getName())
return.getClass().getName() == orig(this.symbols.getClass().getName())
return.getClass().getName() == orig(this.terminals.getClass().getName())
return.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
return.getClass().getName() == orig(this.nonterminals.getClass().getName())
this.syntax has only one value
this.gotoTable has only one value
this.parseTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
return has only one value
return[] contains no nulls and has only one value, of length 2
return[].getClass().getName() == [java.lang.String, java.lang.String]
return[].getClass().getName() elements == java.lang.String.class
return.getClass().getName() == java.util.ArrayList.class
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(return[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets:::OBJECT
this has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.FirstSets(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, java.util.List):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1 has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg2 has only one value
arg2[] contains no nulls and has only one value, of length 2
arg2[].getClass().getName() == [java.lang.String, java.lang.String]
arg2[].getClass().getName() elements == java.lang.String.class
arg2.getClass().getName() == java.util.ArrayList.class
size(arg0.rules[]) == 2
size(arg2[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.FirstSets(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, java.util.List):::EXIT
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
arg2[] == orig(arg2[])
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg2[] contains no nulls and has only one value, of length 2
arg2[].getClass().getName() == [java.lang.String, java.lang.String]
arg2[].getClass().getName() elements == java.lang.String.class
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.generateFirstSet(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, java.lang.String, java.util.Map):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1 has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg2.toString one of { "<START>", "Start" }
arg3 has only one value
arg3.getClass().getName() == java.util.Hashtable.class
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.generateFirstSet(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, java.lang.String, java.util.Map):::EXIT112
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.generateFirstSet(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, java.lang.String, java.util.Map):::EXIT51
arg2.toString == "Start"
orig(arg2) has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.generateFirstSet(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, java.lang.String, java.util.Map):::EXIT
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
arg2.toString == orig(arg2.toString)
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg2.toString one of { "<START>", "Start" }
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.put(java.lang.Object, java.lang.Object):::ENTER
arg0.getClass().getName() == java.lang.String.class
arg1 has only one value
arg1.getClass().getName() == java.lang.String.class
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.FirstSets.put(java.lang.Object, java.lang.Object):::EXIT
return == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables:::CLASS
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables:::OBJECT
this has only one value
this.syntaxNodes has only one value
this.syntaxNodes[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
this.syntaxNodes[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode] }
this.syntaxNodes.getClass().getName() == java.util.ArrayList.class
this.firstSets has only one value
this.followSets == null
this.syntax has only one value
this.syntax.rules has only one value
this.syntax.rules[] contains no nulls and has only one value, of length 2
this.syntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.syntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.syntax.rules.getClass().getName() == java.util.ArrayList.class
this.syntax.ruleHash has only one value
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.gotoTable.getClass().getName() == java.util.ArrayList.class
this.parseTable[] contains no nulls and has only one value, of length 4
this.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
this.parseTable[].getClass().getName() elements == java.util.Hashtable.class
this.parseTable.getClass().getName() == java.util.ArrayList.class
this.symbols has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.symbols[].getClass().getName() elements == java.lang.String.class
this.symbols.getClass().getName() == java.util.ArrayList.class
this.terminals has only one value
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminals[].getClass().getName() elements == java.lang.String.class
this.terminals.getClass().getName() == java.util.ArrayList.class
this.terminalsWithoutEpsilon has only one value
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[].getClass().getName() elements == java.lang.String.class
this.terminalsWithoutEpsilon.getClass().getName() == java.util.ArrayList.class
this.nonterminals has only one value
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[].getClass().getName() elements == java.lang.String.class
this.nonterminals.getClass().getName() == java.util.ArrayList.class
this.f == null
size(this.syntaxNodes[]) one of { 0, 4 }
size(this.syntax.rules[]) == 2
size(this.gotoTable[]) == 4
size(this.parseTable[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.LALRParserTables(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.LALRParserTables(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
arg0.rules == orig(arg0.rules)
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
size(arg0.rules[])-1 == orig(size(arg0.rules[]))
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.gotoTable has only one value
this.parseTable has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(this.syntaxNodes[]) == 4
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.createStartNode(fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::ENTER
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.gotoTable == null
this.parseTable == null
arg0 has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg1 has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRParserTables.createStartNode(fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes[] == orig(this.syntaxNodes[])
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.firstSets == orig(this.firstSets)
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.parseTable == orig(this.parseTable)
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.gotoTable == null
this.parseTable == null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
return has only one value
return.nullable has only one value
return.firstSets has only one value
return.entries has only one value
return.kernels == 0
return.hashCache == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem:::OBJECT
this.propagateItems != null
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets != null
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries != null
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == null
this.lookahead != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == null
this.rule != null
this.rule.symbols != null
this.rule.symbols[] elements != null
this.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.pointerPosition one of { 1, 2, 3 }
this.ruleIndex one of { 0, 1 }
this.followNodeIndex != 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries != null
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(this.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.LALRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.LALRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.pointerPosition == orig(arg1.pointerPosition)
arg1.ruleIndex == orig(arg1.ruleIndex)
arg1.followNodeIndex == orig(arg1.followNodeIndex)
arg1.hashCache == orig(arg1.hashCache)
this.needsPropagation == false
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.LALRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == null
arg1 one of { 0, 1 }
arg2.symbols[].getClass().getName() elements == java.lang.String.class
arg2.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.symbols.getClass().getName() == java.util.ArrayList.class
size(arg2.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.LALRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
arg2.symbols == orig(arg2.symbols)
arg2.symbols[] == orig(arg2.symbols[])
arg2.symbols.getClass().getName() == orig(arg2.symbols.getClass().getName())
this.needsPropagation == false
this.pointerPosition == 1
this.followNodeIndex == -1
this.hashCache == null
arg2.symbols[].getClass().getName() elements == java.lang.String.class
arg2.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.symbols.getClass().getName() == java.util.ArrayList.class
size(arg2.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.addPropagate(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
this.pointerPosition one of { 1, 2 }
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition one of { 1, 2, 3 }
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.addPropagate(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
this.propagateItems == orig(this.propagateItems)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.pointerPosition == orig(arg0.pointerPosition)
arg0.ruleIndex == orig(arg0.ruleIndex)
arg0.followNodeIndex == orig(arg0.followNodeIndex)
arg0.hashCache == orig(arg0.hashCache)
this.needsPropagation == true
this.pointerPosition one of { 1, 2 }
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition one of { 1, 2, 3 }
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.createRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition one of { 1, 2 }
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.createRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
this.needsPropagation == orig(this.needsPropagation)
this.propagateItems == orig(this.propagateItems)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.pointerPosition == orig(arg0.pointerPosition)
arg0.ruleIndex == orig(arg0.ruleIndex)
arg0.followNodeIndex == orig(arg0.followNodeIndex)
arg0.hashCache == orig(arg0.hashCache)
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition one of { 1, 2 }
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.pointerPosition one of { 1, 2 }
return.ruleIndex one of { 0, 1 }
return.followNodeIndex == -1
return.hashCache == null
size(arg0.rule.symbols[]) one of { 2, 3 }
size(return.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.equals(java.lang.Object):::ENTER
this.needsPropagation == false
this.pointerPosition one of { 2, 3 }
this.followNodeIndex == -1
arg0.getClass().getName() == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.class
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.equals(java.lang.Object):::EXIT
this.needsPropagation == orig(this.needsPropagation)
this.propagateItems == orig(this.propagateItems)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.needsPropagation == false
this.pointerPosition one of { 2, 3 }
this.followNodeIndex == -1
return == true
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.equals(java.lang.Object):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.hashCode():::ENTER
this.needsPropagation == false
this.followNodeIndex == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.hashCode():::EXIT
this.needsPropagation == orig(this.needsPropagation)
this.propagateItems == orig(this.propagateItems)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.needsPropagation == false
this.followNodeIndex == -1
this.hashCache != null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.propagateLookaheads(java.util.Iterator):::ENTER
arg0.getClass().getName() == java.util.Hashtable$Enumerator.class
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.propagateLookaheads(java.util.Iterator):::EXIT154
this.needsPropagation == orig(this.needsPropagation)
this.pointerPosition one of { 2, 3 }
this.followNodeIndex one of { -1, 3 }
orig(arg0) == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.propagateLookaheads(java.util.Iterator):::EXIT168
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode$LALRRuleStateItem.propagateLookaheads(java.util.Iterator):::EXIT
this.propagateItems == orig(this.propagateItems)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.this.hashCache)
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.needsPropagation == false
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode:::OBJECT
this.nullable has only one value
this.nullable != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
this.firstSets has only one value
this.firstSets != null
this.entries != null
this.kernels one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRSyntaxNode(fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::ENTER
arg0 has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg1 has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRSyntaxNode(fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.kernels == 0
this.hashCache == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.addRulesDerivingPendingNonTerminal(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0 has only one value
arg0.rule has only one value
arg0.rule.symbols has only one value
arg0.rule.symbols[] contains no nulls and has only one value, of length 2
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition == 1
arg0.ruleIndex == 0
arg0.followNodeIndex == -1
arg0.hashCache has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1 has only one value
arg1.toString == "Start"
arg2 has only one value
arg2.rules has only one value
arg2.rules[] contains no nulls and has only one value, of length 2
arg2.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg2.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg2.rules.getClass().getName() == java.util.ArrayList.class
arg2.ruleHash has only one value
arg3 has only one value
arg3[] contains no nulls and has only one value, of length 1
arg3[] elements has only one value
arg3[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRRuleStateItem]
arg3[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRRuleStateItem.class
arg3.getClass().getName() == java.util.ArrayList.class
size(arg0.rule.symbols[]) == 2
size(arg2.rules[]) == 2
size(arg3[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.addRulesDerivingPendingNonTerminal(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.pointerPosition == orig(arg0.pointerPosition)
arg0.ruleIndex == orig(arg0.ruleIndex)
arg0.followNodeIndex == orig(arg0.followNodeIndex)
arg0.hashCache == orig(arg0.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg1.toString == orig(arg1.toString)
arg2.rules == orig(arg2.rules)
arg2.rules[] == orig(arg2.rules[])
arg2.rules.getClass().getName() == orig(arg2.rules.getClass().getName())
arg2.ruleHash == orig(arg2.ruleHash)
size(arg3[])-1 == orig(size(arg3[]))
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0.rule has only one value
arg0.rule.symbols has only one value
arg0.rule.symbols[] contains no nulls and has only one value, of length 2
arg0.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition == 1
arg0.ruleIndex == 0
arg0.followNodeIndex == -1
arg0.hashCache has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1.toString == "Start"
arg2.rules has only one value
arg2.rules[] contains no nulls and has only one value, of length 2
arg2.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg2.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg2.rules.getClass().getName() == java.util.ArrayList.class
arg2.ruleHash has only one value
arg3[] contains no nulls and has only one value, of length 2
arg3[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRRuleStateItem, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRRuleStateItem]
arg3[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.LALRRuleStateItem.class
size(arg0.rule.symbols[]) == 2
size(arg2.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.build(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List, java.util.Hashtable):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1 has only one value
arg1[] == []
arg1[].getClass().getName() == []
arg1.getClass().getName() == java.util.ArrayList.class
arg2 has only one value
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.build(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List, java.util.Hashtable):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1[] contains no nulls and has only one value, of length 4
arg1[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg1[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
return has only one value
return[] contains no nulls and has only one value, of length 4
return[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
return.getClass().getName() == java.util.ArrayList.class
size(arg0.rules[]) == 2
size(return[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.createRuleStateItem(int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0 one of { 0, 1 }
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg1.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.symbols.getClass().getName() == java.util.ArrayList.class
size(arg1.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.createRuleStateItem(int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg1.symbols == orig(arg1.symbols)
arg1.symbols[] == orig(arg1.symbols[])
arg1.symbols.getClass().getName() == orig(arg1.symbols.getClass().getName())
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg1.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.symbols.getClass().getName() == java.util.ArrayList.class
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.pointerPosition == 1
return.ruleIndex one of { 0, 1 }
return.followNodeIndex == -1
return.hashCache == null
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(arg1.symbols[]) one of { 2, 3 }
size(return.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.createSyntaxNode():::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.createSyntaxNode():::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
return.kernels == 0
return.hashCache == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.linkParentItemToChild(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, int, java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition one of { 1, 2 }
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1 one of { 1, 2, 3 }
arg2 has only one value
arg2[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg2.getClass().getName() == java.util.ArrayList.class
arg3.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg3.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg3.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg3.pointerPosition one of { 2, 3 }
arg3.ruleIndex one of { 0, 1 }
arg3.followNodeIndex == -1
size(arg0.rule.symbols[]) one of { 2, 3 }
size(arg2[]) one of { 2, 3, 4 }
size(arg3.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.linkParentItemToChild(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, int, java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.pointerPosition == orig(arg0.pointerPosition)
arg0.ruleIndex == orig(arg0.ruleIndex)
arg0.hashCache == orig(arg0.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg2[] == orig(arg2[])
arg3.rule == orig(arg3.rule)
arg3.rule.symbols == orig(arg3.rule.symbols)
arg3.rule.symbols[] == orig(arg3.rule.symbols[])
arg3.rule.symbols.getClass().getName() == orig(arg3.rule.symbols.getClass().getName())
arg3.pointerPosition == orig(arg3.pointerPosition)
arg3.ruleIndex == orig(arg3.ruleIndex)
arg3.followNodeIndex == orig(arg3.followNodeIndex)
arg3.hashCache == orig(arg3.hashCache)
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition one of { 1, 2 }
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex one of { 1, 2, 3 }
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg2[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg3.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg3.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg3.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg3.pointerPosition one of { 2, 3 }
arg3.ruleIndex one of { 0, 1 }
arg3.followNodeIndex == -1
size(arg0.rule.symbols[]) one of { 2, 3 }
size(arg3.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRParserTables:::CLASS
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRParserTables:::OBJECT
this has only one value
this.syntaxNodes has only one value
this.syntaxNodes[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
this.syntaxNodes[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode] }
this.syntaxNodes.getClass().getName() == java.util.ArrayList.class
this.followSets == null
this.syntax has only one value
this.syntax.rules has only one value
this.syntax.rules[] contains no nulls and has only one value, of length 2
this.syntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.syntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.syntax.rules.getClass().getName() == java.util.ArrayList.class
this.syntax.ruleHash has only one value
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.gotoTable.getClass().getName() == java.util.ArrayList.class
this.parseTable[] contains no nulls and has only one value, of length 4
this.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
this.parseTable[].getClass().getName() elements == java.util.Hashtable.class
this.parseTable.getClass().getName() == java.util.ArrayList.class
this.symbols has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.symbols[].getClass().getName() elements == java.lang.String.class
this.symbols.getClass().getName() == java.util.ArrayList.class
this.terminals has only one value
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminals[].getClass().getName() elements == java.lang.String.class
this.terminals.getClass().getName() == java.util.ArrayList.class
this.terminalsWithoutEpsilon has only one value
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[].getClass().getName() elements == java.lang.String.class
this.terminalsWithoutEpsilon.getClass().getName() == java.util.ArrayList.class
this.nonterminals has only one value
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[].getClass().getName() elements == java.lang.String.class
this.nonterminals.getClass().getName() == java.util.ArrayList.class
this.f == null
size(this.syntaxNodes[]) one of { 0, 4 }
size(this.syntax.rules[]) == 2
size(this.gotoTable[]) == 4
size(this.parseTable[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRParserTables.LRParserTables(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRParserTables.LRParserTables(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
arg0.rules == orig(arg0.rules)
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
size(arg0.rules[])-1 == orig(size(arg0.rules[]))
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.gotoTable has only one value
this.parseTable has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(this.syntaxNodes[]) == 4
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRParserTables.init():::ENTER
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.firstSets == null
this.gotoTable == null
this.parseTable == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRParserTables.init():::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.gotoTable has only one value
this.parseTable has only one value
size(this.syntaxNodes[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem:::OBJECT
this.lookahead != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries != null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == null
this.rule != null
this.rule.symbols != null
this.rule.symbols[] elements != null
this.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.pointerPosition one of { 1, 2, 3 }
this.ruleIndex one of { 0, 1 }
this.followNodeIndex one of { -1, 1, 3 }
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries != null
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(this.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.LRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.LRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.pointerPosition == orig(arg1.pointerPosition)
arg1.ruleIndex == orig(arg1.ruleIndex)
arg1.followNodeIndex == orig(arg1.followNodeIndex)
arg1.hashCache == orig(arg1.hashCache)
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.LRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode, int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == null
arg1 one of { 0, 1 }
arg2.symbols[].getClass().getName() elements == java.lang.String.class
arg2.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.symbols.getClass().getName() == java.util.ArrayList.class
size(arg2.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.LRRuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode, int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
arg2.symbols == orig(arg2.symbols)
arg2.symbols[] == orig(arg2.symbols[])
arg2.symbols.getClass().getName() == orig(arg2.symbols.getClass().getName())
this.pointerPosition == 1
this.followNodeIndex == -1
this.hashCache == null
arg2.symbols[].getClass().getName() elements == java.lang.String.class
arg2.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.symbols.getClass().getName() == java.util.ArrayList.class
size(arg2.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.addLookahead(java.util.Iterator):::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.addLookahead(java.util.Iterator):::EXIT
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
(return == false)  <==>  (orig(arg0.getClass().getName()) == java.util.Hashtable$Enumerator.class)
(return == false)  ==>  (this.followNodeIndex one of { -1, 1, 3 })
(return == false)  ==>  (this.pointerPosition one of { 1, 2, 3 })
(return == true)  <==>  (orig(arg0.getClass().getName()) == java.util.ArrayList$Itr.class)
(return == true)  ==>  (this.followNodeIndex == -1)
(return == true)  ==>  (this.pointerPosition == 1)
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.addLookahead(java.util.Iterator):::EXIT;condition="return == true"
this.pointerPosition == 1
this.followNodeIndex == -1
return == true
orig(arg0.getClass().getName()) == java.util.ArrayList$Itr.class
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.addLookahead(java.util.Iterator):::EXIT;condition="not(return == true)"
return == false
orig(arg0.getClass().getName()) == java.util.Hashtable$Enumerator.class
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.calculateLookahead(java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::ENTER
this has only one value
this.lookahead has only one value
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.pointerPosition == 1
this.ruleIndex == 0
this.followNodeIndex == -1
this.hashCache has only one value
arg0 has only one value
arg0[] == []
arg0[].getClass().getName() == []
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg2 has only one value
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.calculateLookahead(java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT188
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.calculateLookahead(java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT188;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.calculateLookahead(java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT
this.lookahead == orig(this.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
size(arg0[])-1 == orig(size(arg0[]))
this.lookahead has only one value
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.pointerPosition == 1
this.ruleIndex == 0
this.followNodeIndex == -1
this.hashCache has only one value
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [java.lang.String]
arg0[].getClass().getName() elements == java.lang.String.class
return == true
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem.calculateLookahead(java.util.List, fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode:::OBJECT
this.nullable has only one value
this.nullable != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
this.firstSets has only one value
this.firstSets != null
this.entries != null
this.kernels one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.LRSyntaxNode(fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::ENTER
arg0 has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
arg1 has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.LRSyntaxNode(fri.patterns.interpreter.parsergenerator.parsertables.Nullable, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.kernels == 0
this.hashCache == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.addStartLookahead(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem, int):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == null
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition == 1
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
arg0.hashCache == null
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1 one of { 0, 1 }
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.addStartLookahead(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode$LRRuleStateItem, int):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.lookahead == orig(arg0.lookahead)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache)
arg0.rule == orig(arg0.rule)
arg0.rule.symbols == orig(arg0.rule.symbols)
arg0.rule.symbols[] == orig(arg0.rule.symbols[])
arg0.rule.symbols.getClass().getName() == orig(arg0.rule.symbols.getClass().getName())
arg0.pointerPosition == orig(arg0.pointerPosition)
arg0.ruleIndex == orig(arg0.ruleIndex)
arg0.followNodeIndex == orig(arg0.followNodeIndex)
arg0.hashCache == orig(arg0.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.entries has only one value
this.kernels == 0
this.hashCache == null
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.nullable has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.firstSets has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.this.hashCache == null
arg0.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg0.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg0.pointerPosition == 1
arg0.ruleIndex one of { 0, 1 }
arg0.followNodeIndex == -1
arg0.hashCache == null
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(arg0.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.getNontermShiftSymbols(fri.patterns.interpreter.parsergenerator.parsertables.FirstSets, java.lang.String):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0 has only one value
arg1 has only one value
arg1.toString == "<START>"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.getNontermShiftSymbols(fri.patterns.interpreter.parsergenerator.parsertables.FirstSets, java.lang.String):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg1.toString == orig(arg1.toString)
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg1.toString == "<START>"
return == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.getReduceSymbols(fri.patterns.interpreter.parsergenerator.parsertables.FollowSets, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
this.kernels == 1
arg0 == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 2, 3 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.LRSyntaxNode.getReduceSymbols(fri.patterns.interpreter.parsergenerator.parsertables.FollowSets, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
this.nullable == orig(this.nullable)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
this.firstSets == orig(this.firstSets)
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.pointerPosition == orig(arg1.pointerPosition)
arg1.ruleIndex == orig(arg1.ruleIndex)
arg1.followNodeIndex == orig(arg1.followNodeIndex)
arg1.hashCache == orig(arg1.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.kernels == 1
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 2, 3 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
return.getClass().getName() == java.util.Hashtable$Enumerator.class
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable:::CLASS
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL has only one value
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL != null
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == ""
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable:::OBJECT
this has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.Nullable(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1 has only one value
arg1[] contains no nulls and has only one value, of length 2
arg1[].getClass().getName() == [java.lang.String, java.lang.String]
arg1[].getClass().getName() elements == java.lang.String.class
arg1.getClass().getName() == java.util.ArrayList.class
size(arg0.rules[]) == 2
size(arg1[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.Nullable(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List):::EXIT
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
arg1[] == orig(arg1[])
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1[] contains no nulls and has only one value, of length 2
arg1[].getClass().getName() == [java.lang.String, java.lang.String]
arg1[].getClass().getName() elements == java.lang.String.class
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1.toString one of { "<START>", "Start" }
arg2 has only one value
arg2.getClass().getName() == java.util.Hashtable.class
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::EXIT105
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::EXIT105;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::EXIT59
arg1.toString == "Start"
orig(arg1) has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::EXIT59;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
arg1.toString == orig(arg1.toString)
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1.toString one of { "<START>", "Start" }
return == false
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.checkNullability(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.lang.String, java.util.Map):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.isNull(java.lang.String):::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.isNull(java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
arg0.toString == orig(arg0.toString)
return == false
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.isNull(java.lang.String):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.isNullable(java.lang.String):::ENTER
arg0 has only one value
arg0.toString == "Start"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.isNullable(java.lang.String):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
arg0.toString == orig(arg0.toString)
arg0.toString == "Start"
return == false
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.isNullable(java.lang.String):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.putSymbol(java.lang.String, boolean):::ENTER
arg0.toString one of { "<START>", "Start" }
arg1 == false
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.putSymbol(java.lang.String, boolean):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL)
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString == orig(fri.patterns.interpreter.parsergenerator.parsertables.Nullable.NULL.toString)
arg0.toString == orig(arg0.toString)
arg0.toString one of { "<START>", "Start" }
return == false
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.Nullable.putSymbol(java.lang.String, boolean):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables:::CLASS
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == 0
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables:::OBJECT
this has only one value
this.syntaxNodes has only one value
this.syntaxNodes != null
this.syntaxNodes[] elements != null
this.syntaxNodes[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
this.syntaxNodes[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode] }
this.syntaxNodes.getClass().getName() == java.util.ArrayList.class
this.followSets == null
this.syntax.rules has only one value
this.syntax.rules != null
this.syntax.rules[] contains no nulls and has only one value, of length 2
this.syntax.rules[] elements != null
this.syntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.syntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.syntax.rules.getClass().getName() == java.util.ArrayList.class
this.syntax.ruleHash has only one value
this.syntax.ruleHash != null
this.gotoTable.getClass().getName() == java.util.ArrayList.class
this.parseTable[].getClass().getName() elements == java.util.Hashtable.class
this.parseTable.getClass().getName() == java.util.ArrayList.class
this.symbols has only one value
this.symbols != null
this.symbols[] elements != null
this.symbols[].getClass().getName() elements == java.lang.String.class
this.symbols[].getClass().getName() one of { [], [java.lang.String, java.lang.String, java.lang.String, java.lang.String] }
this.symbols.getClass().getName() == java.util.ArrayList.class
this.terminals has only one value
this.terminals != null
this.terminals[] elements != null
this.terminals[].getClass().getName() elements == java.lang.String.class
this.terminals[].getClass().getName() one of { [], [java.lang.String, java.lang.String, java.lang.String] }
this.terminals.getClass().getName() == java.util.ArrayList.class
this.terminalsWithoutEpsilon has only one value
this.terminalsWithoutEpsilon != null
this.terminalsWithoutEpsilon[] elements != null
this.terminalsWithoutEpsilon[].getClass().getName() elements == java.lang.String.class
this.terminalsWithoutEpsilon[].getClass().getName() one of { [], [java.lang.String, java.lang.String] }
this.terminalsWithoutEpsilon.getClass().getName() == java.util.ArrayList.class
this.nonterminals has only one value
this.nonterminals != null
this.nonterminals[] elements != null
this.nonterminals[].getClass().getName() elements == java.lang.String.class
this.nonterminals[].getClass().getName() one of { [], [java.lang.String, java.lang.String] }
this.nonterminals.getClass().getName() == java.util.ArrayList.class
this.f == null
size(this.syntaxNodes[]) one of { 0, 4 }
size(this.syntaxNodes[])-1 != 0
size(this.syntax.rules[]) == 2
size(this.symbols[]) one of { 0, 4 }
size(this.symbols[])-1 != 0
size(this.terminals[]) one of { 0, 3 }
size(this.terminals[])-1 != 0
size(this.terminalsWithoutEpsilon[]) one of { 0, 2 }
size(this.terminalsWithoutEpsilon[])-1 != 0
size(this.nonterminals[]) one of { 0, 2 }
size(this.nonterminals[])-1 != 0
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.SLRParserTables(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.SLRParserTables(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
arg0.rules == orig(arg0.rules)
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
size(arg0.rules[])-1 == orig(size(arg0.rules[]))
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable has only one value
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.parseTable has only one value
this.parseTable[] contains no nulls and has only one value, of length 4
this.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(this.syntaxNodes[]) == 4
size(this.gotoTable[]) == 4
size(this.parseTable[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.addStartSymbol(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.firstSets == null
this.syntax == null
this.gotoTable == null
this.parseTable == null
this.symbols[] == []
this.symbols[].getClass().getName() == []
this.terminals[] == []
this.terminals[].getClass().getName() == []
this.terminalsWithoutEpsilon[] == []
this.terminalsWithoutEpsilon[].getClass().getName() == []
this.nonterminals[] == []
this.nonterminals[].getClass().getName() == []
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.addStartSymbol(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes[] == orig(this.syntaxNodes[])
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.firstSets == orig(this.firstSets)
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.gotoTable == orig(this.gotoTable)
this.parseTable == orig(this.parseTable)
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
arg0.rules == orig(arg0.rules)
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
size(arg0.rules[])-1 == orig(size(arg0.rules[]))
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.firstSets == null
this.syntax == null
this.gotoTable == null
this.parseTable == null
this.symbols[] == []
this.symbols[].getClass().getName() == []
this.terminals[] == []
this.terminals[].getClass().getName() == []
this.terminalsWithoutEpsilon[] == []
this.terminalsWithoutEpsilon[].getClass().getName() == []
this.nonterminals[] == []
this.nonterminals[].getClass().getName() == []
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
return has only one value
return.rules has only one value
return.rules[] contains no nulls and has only one value, of length 2
return.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.rules.getClass().getName() == java.util.ArrayList.class
return.ruleHash has only one value
size(arg0.rules[]) == 2
size(return.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.generateGoto(java.util.List):::ENTER
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable == null
this.parseTable == null
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 4
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg0.getClass().getName() == java.util.ArrayList.class
size(this.syntaxNodes[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(arg0[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.generateGoto(java.util.List):::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes[] == orig(this.syntaxNodes[])
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.firstSets == orig(this.firstSets)
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.parseTable == orig(this.parseTable)
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
arg0[] == orig(arg0[])
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable has only one value
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.parseTable == null
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg0[] contains no nulls and has only one value, of length 4
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
return has only one value
return[] has only one value, of length 4
return[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
return.getClass().getName() == java.util.ArrayList.class
size(this.syntaxNodes[]) == 4
size(this.gotoTable[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(return[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.generateParseAction(java.util.List):::ENTER
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable has only one value
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.parseTable == null
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 4
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg0.getClass().getName() == java.util.ArrayList.class
size(this.syntaxNodes[]) == 4
size(this.gotoTable[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(arg0[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.generateParseAction(java.util.List):::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes[] == orig(this.syntaxNodes[])
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.firstSets == orig(this.firstSets)
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.gotoTable[] == orig(this.gotoTable[])
this.gotoTable.getClass().getName() == orig(this.gotoTable.getClass().getName())
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
arg0[] == orig(arg0[])
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable has only one value
this.gotoTable[] has only one value, of length 4
this.gotoTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, null, null]
this.parseTable has only one value
this.parseTable[] contains no nulls and has only one value, of length 4
this.parseTable[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg0[] contains no nulls and has only one value, of length 4
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
return has only one value
return[] contains no nulls and has only one value, of length 4
return[].getClass().getName() == [java.util.Hashtable, java.util.Hashtable, java.util.Hashtable, java.util.Hashtable]
return[].getClass().getName() elements == java.util.Hashtable.class
return.getClass().getName() == java.util.ArrayList.class
size(this.syntaxNodes[]) == 4
size(this.gotoTable[]) == 4
size(this.parseTable[]) == 4
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(return[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.getAllSymbols():::ENTER
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.firstSets == null
this.syntax has only one value
this.gotoTable == null
this.parseTable == null
this.symbols[] == []
this.symbols[].getClass().getName() == []
this.terminals[] == []
this.terminals[].getClass().getName() == []
this.terminalsWithoutEpsilon[] == []
this.terminalsWithoutEpsilon[].getClass().getName() == []
this.nonterminals[] == []
this.nonterminals[].getClass().getName() == []
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.getAllSymbols():::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes[] == orig(this.syntaxNodes[])
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.firstSets == orig(this.firstSets)
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.parseTable == orig(this.parseTable)
this.symbols == orig(this.symbols)
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
this.syntaxNodes[] == []
this.syntaxNodes[].getClass().getName() == []
this.firstSets == null
this.syntax has only one value
this.gotoTable == null
this.parseTable == null
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
return has only one value
return[] contains no nulls and has only one value, of length 4
return[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
return[].getClass().getName() elements == java.lang.String.class
return.getClass().getName() == java.util.ArrayList.class
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
size(return[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.insertTableLine(int, java.util.Map, java.util.List, java.util.Map):::ENTER
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg1.getClass().getName() == java.util.Hashtable.class
arg2[].getClass().getName() elements == java.util.Hashtable.class
arg2.getClass().getName() == java.util.ArrayList.class
arg3.getClass().getName() == java.util.Hashtable.class
size(this.syntaxNodes[]) == 4
size(this.gotoTable[]) one of { 0, 1, 4 }
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRParserTables.insertTableLine(int, java.util.Map, java.util.List, java.util.Map):::EXIT
this.syntaxNodes == orig(this.syntaxNodes)
this.syntaxNodes[] == orig(this.syntaxNodes[])
this.syntaxNodes.getClass().getName() == orig(this.syntaxNodes.getClass().getName())
this.firstSets == orig(this.firstSets)
this.followSets == orig(this.followSets)
this.syntax == orig(this.syntax)
this.syntax.rules == orig(this.syntax.rules)
this.syntax.rules[] == orig(this.syntax.rules[])
this.syntax.rules.getClass().getName() == orig(this.syntax.rules.getClass().getName())
this.syntax.ruleHash == orig(this.syntax.ruleHash)
this.gotoTable == orig(this.gotoTable)
this.gotoTable.getClass().getName() == orig(this.gotoTable.getClass().getName())
this.parseTable == orig(this.parseTable)
this.parseTable.getClass().getName() == orig(this.parseTable.getClass().getName())
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.terminals == orig(this.terminals)
this.terminals[] == orig(this.terminals[])
this.terminals.getClass().getName() == orig(this.terminals.getClass().getName())
this.terminalsWithoutEpsilon == orig(this.terminalsWithoutEpsilon)
this.terminalsWithoutEpsilon[] == orig(this.terminalsWithoutEpsilon[])
this.terminalsWithoutEpsilon.getClass().getName() == orig(this.terminalsWithoutEpsilon.getClass().getName())
this.nonterminals == orig(this.nonterminals)
this.nonterminals[] == orig(this.nonterminals[])
this.nonterminals.getClass().getName() == orig(this.nonterminals.getClass().getName())
fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH == orig(fri.patterns.interpreter.parsergenerator.parsertables.AbstractParserTables.CELLWIDTH)
this.f == orig(this.f)
size(this.parseTable[])-1 == orig(size(this.parseTable[]))
size(arg2[])-1 == orig(size(arg2[]))
this.syntaxNodes[] contains no nulls and has only one value, of length 4
this.syntaxNodes[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
this.firstSets has only one value
this.syntax has only one value
this.gotoTable has only one value
this.symbols[] contains no nulls and has only one value, of length 4
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String, java.lang.String]
this.terminals[] contains no nulls and has only one value, of length 3
this.terminals[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.terminalsWithoutEpsilon[] contains no nulls and has only one value, of length 2
this.terminalsWithoutEpsilon[].getClass().getName() == [java.lang.String, java.lang.String]
this.nonterminals[] contains no nulls and has only one value, of length 2
this.nonterminals[].getClass().getName() == [java.lang.String, java.lang.String]
arg2[].getClass().getName() elements == java.util.Hashtable.class
size(this.syntaxNodes[]) == 4
size(this.gotoTable[]) one of { 1, 2, 4 }
size(this.symbols[]) == 4
size(this.terminals[]) == 3
size(this.terminalsWithoutEpsilon[]) == 2
size(this.nonterminals[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem:::OBJECT
this.rule != null
this.rule.symbols != null
this.rule.symbols[] elements != null
this.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.pointerPosition one of { 1, 2, 3 }
this.ruleIndex one of { 0, 1 }
this.followNodeIndex != 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries != null
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(this.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.RuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.RuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.pointerPosition == orig(arg1.pointerPosition)
arg1.ruleIndex == orig(arg1.ruleIndex)
arg1.followNodeIndex == orig(arg1.followNodeIndex)
arg1.hashCache == orig(arg1.hashCache)
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
size(arg1.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.RuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode, int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1 one of { 0, 1 }
arg2.symbols[].getClass().getName() elements == java.lang.String.class
arg2.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.symbols.getClass().getName() == java.util.ArrayList.class
size(arg2.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.RuleStateItem(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode, int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg2.symbols == orig(arg2.symbols)
arg2.symbols[] == orig(arg2.symbols[])
arg2.symbols.getClass().getName() == orig(arg2.symbols.getClass().getName())
this.pointerPosition == 1
this.followNodeIndex == -1
this.hashCache == null
arg2.symbols[].getClass().getName() elements == java.lang.String.class
arg2.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.symbols.getClass().getName() == java.util.ArrayList.class
size(arg2.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getNonterminal():::ENTER
this has only one value
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.pointerPosition == 1
this.ruleIndex == 0
this.followNodeIndex == 2
this.hashCache has only one value
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getNonterminal():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.pointerPosition == 1
this.ruleIndex == 0
this.followNodeIndex == 2
this.hashCache has only one value
return has only one value
return.toString == "<START>"
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingNonTerminal():::ENTER
this.followNodeIndex == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingNonTerminal():::EXIT478
this.pointerPosition one of { 2, 3 }
return == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingNonTerminal():::EXIT482
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 3
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String, java.lang.String]
this.pointerPosition one of { 1, 2 }
this.ruleIndex == 1
return == null
size(this.rule.symbols[]) == 3
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingNonTerminal():::EXIT484
this.rule has only one value
this.rule.symbols has only one value
this.rule.symbols[] contains no nulls and has only one value, of length 2
this.rule.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
this.pointerPosition == 1
this.ruleIndex == 0
this.hashCache has only one value
return has only one value
orig(this) has only one value
size(this.rule.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingNonTerminal():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.followNodeIndex == -1
return.toString == "Start"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingSymbol():::ENTER
this.hashCache != null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingSymbol():::EXIT490
this.pointerPosition one of { 2, 3 }
this.followNodeIndex == -1
return == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingSymbol():::EXIT492
this.pointerPosition one of { 1, 2 }
return != null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.getPendingSymbol():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
(return != null)  ==>  (return.toString one of { "\"Hello\"", "\"World\"", "Start" })
(return != null)  ==>  (this.pointerPosition one of { 1, 2 })
(return == null)  ==>  (this.followNodeIndex == -1)
(return == null)  ==>  (this.pointerPosition one of { 2, 3 })
this.hashCache != null
return.toString one of { "\"Hello\"", "\"World\"", "Start" }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.shift():::ENTER
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem.shift():::EXIT
this.rule == orig(this.rule)
this.rule.symbols == orig(this.rule.symbols)
this.rule.symbols[] == orig(this.rule.symbols[])
this.rule.symbols.getClass().getName() == orig(this.rule.symbols.getClass().getName())
this.pointerPosition == orig(this.pointerPosition)
this.ruleIndex == orig(this.ruleIndex)
this.followNodeIndex == orig(this.followNodeIndex)
this.hashCache == orig(this.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
this.pointerPosition one of { 1, 2 }
this.followNodeIndex == -1
return.rule.symbols[].getClass().getName() elements == java.lang.String.class
return.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return.rule.symbols.getClass().getName() == java.util.ArrayList.class
return.pointerPosition one of { 2, 3 }
return.ruleIndex one of { 0, 1 }
return.followNodeIndex == -1
return.hashCache == null
size(return.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$Tuple:::OBJECT
this.o1.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.o1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.o1.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.o1.pointerPosition one of { 1, 2 }
this.o1.ruleIndex one of { 0, 1 }
this.o1.followNodeIndex == -1
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
this.o2.rule.symbols[].getClass().getName() elements == java.lang.String.class
this.o2.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
this.o2.rule.symbols.getClass().getName() == java.util.ArrayList.class
this.o2.pointerPosition one of { 2, 3 }
this.o2.ruleIndex one of { 0, 1 }
this.o2.followNodeIndex == -1
size(this.o1.rule.symbols[]) one of { 2, 3 }
size(this.o2.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$Tuple.Tuple(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::ENTER
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
arg2.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg2.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg2.pointerPosition one of { 2, 3 }
arg2.ruleIndex one of { 0, 1 }
arg2.followNodeIndex == -1
size(arg1.rule.symbols[]) one of { 2, 3 }
size(arg2.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$Tuple.Tuple(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem):::EXIT
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg1.rule == orig(arg1.rule)
arg1.rule.symbols == orig(arg1.rule.symbols)
arg1.rule.symbols[] == orig(arg1.rule.symbols[])
arg1.rule.symbols.getClass().getName() == orig(arg1.rule.symbols.getClass().getName())
arg1.pointerPosition == orig(arg1.pointerPosition)
arg1.ruleIndex == orig(arg1.ruleIndex)
arg1.followNodeIndex == orig(arg1.followNodeIndex)
arg1.hashCache == orig(arg1.hashCache)
arg2.rule == orig(arg2.rule)
arg2.rule.symbols == orig(arg2.rule.symbols)
arg2.rule.symbols[] == orig(arg2.rule.symbols[])
arg2.rule.symbols.getClass().getName() == orig(arg2.rule.symbols.getClass().getName())
arg2.pointerPosition == orig(arg2.pointerPosition)
arg2.ruleIndex == orig(arg2.ruleIndex)
arg2.followNodeIndex == orig(arg2.followNodeIndex)
arg2.hashCache == orig(arg2.hashCache)
arg1.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg1.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg1.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg1.pointerPosition one of { 1, 2 }
arg1.ruleIndex one of { 0, 1 }
arg1.followNodeIndex == -1
arg2.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg2.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg2.pointerPosition one of { 2, 3 }
arg2.ruleIndex one of { 0, 1 }
arg2.followNodeIndex == -1
size(arg1.rule.symbols[]) one of { 2, 3 }
size(arg2.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode:::OBJECT
this.entries != null
this.kernels one of { 0, 1 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.SLRSyntaxNode():::EXIT
this.kernels == 0
this.hashCache == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.addShiftedItems(java.lang.String, java.util.Hashtable):::ENTER
this.kernels == 0
this.hashCache == null
arg0.toString one of { "\"Hello\"", "\"World\"", "Start" }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.addShiftedItems(java.lang.String, java.util.Hashtable):::EXIT
this.entries == orig(this.entries)
this.hashCache == orig(this.hashCache)
arg0.toString == orig(arg0.toString)
this.kernels == 1
this.hashCache == null
arg0.toString one of { "\"Hello\"", "\"World\"", "Start" }
return[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.Tuple]
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.Tuple.class
return.getClass().getName() == java.util.ArrayList.class
size(return[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.build(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List, java.util.Hashtable):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1 has only one value
arg1[] == []
arg1[].getClass().getName() == []
arg1.getClass().getName() == java.util.ArrayList.class
arg2 has only one value
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.build(fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.List, java.util.Hashtable):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1[] contains no nulls and has only one value, of length 4
arg1[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg1[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
return has only one value
return[] contains no nulls and has only one value, of length 4
return[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
return.getClass().getName() == java.util.ArrayList.class
size(arg0.rules[]) == 2
size(return[]) == 4
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.closure(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.closure(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.fillGotoLine(int):::ENTER
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.fillGotoLine(int):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.fillParseActionLine(int, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets, fri.patterns.interpreter.parsergenerator.parsertables.FollowSets):::ENTER
arg1 has only one value
arg2 == null
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.fillParseActionLine(int, fri.patterns.interpreter.parsergenerator.parsertables.FirstSets, fri.patterns.interpreter.parsergenerator.parsertables.FollowSets):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.generateSyntaxNodes(java.util.List, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.Hashtable):::ENTER
this has only one value
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 2
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
arg2 has only one value
size(arg0[]) == 1
size(arg1.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.generateSyntaxNodes(java.util.List, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.Hashtable):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg1.rules == orig(arg1.rules)
arg1.rules[] == orig(arg1.rules[])
arg1.rules.getClass().getName() == orig(arg1.rules.getClass().getName())
arg1.ruleHash == orig(arg1.ruleHash)
this.entries has only one value
this.kernels == 0
this.hashCache == null
arg0[] contains no nulls and has only one value, of length 4
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 2
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
size(arg1.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.generateSyntaxNodesFromItems(java.util.List, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.Hashtable):::ENTER
arg0 has only one value
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 2
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
arg2 has only one value
size(arg0[]) one of { 1, 3, 4 }
size(arg1.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.generateSyntaxNodesFromItems(java.util.List, fri.patterns.interpreter.parsergenerator.syntax.Syntax, java.util.Hashtable):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg1.rules == orig(arg1.rules)
arg1.rules[] == orig(arg1.rules[])
arg1.rules.getClass().getName() == orig(arg1.rules.getClass().getName())
arg1.ruleHash == orig(arg1.ruleHash)
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode.class
arg0[].getClass().getName() one of { [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode], [fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode, fri.patterns.interpreter.parsergenerator.parsertables.LALRSyntaxNode] }
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 2
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
size(arg1.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.hashCode():::ENTER
this.kernels == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.hashCode():::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.kernels == 1
return one of { 2, 15, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setParseTableLine(int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::ENTER
arg2.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg2.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg2.pointerPosition one of { 1, 2, 3 }
arg2.ruleIndex one of { 0, 1 }
arg2.followNodeIndex one of { -1, 1, 3 }
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg4.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
size(arg2.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setParseTableLine(int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg2.rule == orig(arg2.rule)
arg2.rule.symbols == orig(arg2.rule.symbols)
arg2.rule.symbols[] == orig(arg2.rule.symbols[])
arg2.rule.symbols.getClass().getName() == orig(arg2.rule.symbols.getClass().getName())
arg2.pointerPosition == orig(arg2.pointerPosition)
arg2.ruleIndex == orig(arg2.ruleIndex)
arg2.followNodeIndex == orig(arg2.followNodeIndex)
arg2.hashCache == orig(arg2.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg4.toString == orig(arg4.toString)
arg2.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg2.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg2.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg2.pointerPosition one of { 1, 2, 3 }
arg2.ruleIndex one of { 0, 1 }
arg2.followNodeIndex one of { -1, 1, 3 }
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
arg4.toString one of { "\"EoI\"", "\"Hello\"", "\"World\"" }
size(arg2.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setTableLine(java.lang.String, int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::ENTER
arg0.toString one of { "GOTO", "PARSE-ACTION" }
arg1 >= 0
arg3.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg3.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg3.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg3.pointerPosition one of { 1, 2, 3 }
arg3.ruleIndex one of { 0, 1 }
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
size(arg3.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setTableLine(java.lang.String, int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::EXIT348
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setTableLine(java.lang.String, int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::EXIT348;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setTableLine(java.lang.String, int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::EXIT
this.entries == orig(this.entries)
this.kernels == orig(this.kernels)
this.hashCache == orig(this.hashCache)
arg0.toString == orig(arg0.toString)
arg3.rule == orig(arg3.rule)
arg3.rule.symbols == orig(arg3.rule.symbols)
arg3.rule.symbols[] == orig(arg3.rule.symbols[])
arg3.rule.symbols.getClass().getName() == orig(arg3.rule.symbols.getClass().getName())
arg3.pointerPosition == orig(arg3.pointerPosition)
arg3.ruleIndex == orig(arg3.ruleIndex)
arg3.followNodeIndex == orig(arg3.followNodeIndex)
arg3.hashCache == orig(arg3.hashCache)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels)
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == orig(fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache)
arg5.toString == orig(arg5.toString)
arg0.toString one of { "GOTO", "PARSE-ACTION" }
arg3.rule.symbols[].getClass().getName() elements == java.lang.String.class
arg3.rule.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg3.rule.symbols.getClass().getName() == java.util.ArrayList.class
arg3.pointerPosition one of { 1, 2, 3 }
arg3.ruleIndex one of { 0, 1 }
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.entries has only one value
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.kernels == 0
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.this.hashCache == null
return == true
size(arg3.rule.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode.setTableLine(java.lang.String, int, java.util.Hashtable, fri.patterns.interpreter.parsergenerator.parsertables.SLRSyntaxNode$RuleStateItem, java.lang.Integer, java.lang.String):::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule:::OBJECT
this.symbols != null
this.symbols[] elements != null
this.symbols[].getClass().getName() elements == java.lang.String.class
this.symbols.getClass().getName() == java.util.ArrayList.class
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.Rule(java.lang.String, int):::ENTER
arg0 has only one value
arg0.toString == "<START>"
arg1 == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.Rule(java.lang.String, int):::EXIT
arg0.toString == orig(arg0.toString)
this.symbols has only one value
this.symbols[] contains no nulls and has only one value, of length 1
this.symbols[] elements has only one value
this.symbols[].getClass().getName() == [java.lang.String]
arg0.toString == "<START>"
size(this.symbols[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.Rule(java.util.List):::ENTER
arg0 != null
arg0[] elements != null
arg0[].getClass().getName() elements == java.lang.String.class
arg0.getClass().getName() == java.util.ArrayList.class
size(arg0[]) one of { 0, 2, 3 }
size(arg0[])-1 != 0
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.Rule(java.util.List):::EXIT
this.symbols == orig(arg0)
this.symbols.getClass().getName() == orig(arg0.getClass().getName())
arg0[] == orig(arg0[])
arg0[] elements != null
arg0[].getClass().getName() elements == java.lang.String.class
size(this.symbols[]) one of { 0, 2, 3 }
size(this.symbols[])-1 != 0
size(arg0[])-1 != 0
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.addRightSymbol(java.lang.String):::ENTER
this has only one value
this.symbols has only one value
this.symbols[] contains no nulls and has only one value, of length 1
this.symbols[] elements has only one value
this.symbols[].getClass().getName() == [java.lang.String]
arg0 has only one value
arg0.toString == "Start"
size(this.symbols[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.addRightSymbol(java.lang.String):::EXIT
this.symbols == orig(this.symbols)
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
arg0.toString == orig(arg0.toString)
size(this.symbols[])-1 == orig(size(this.symbols[]))
this.symbols has only one value
this.symbols[] contains no nulls and has only one value, of length 2
this.symbols[].getClass().getName() == [java.lang.String, java.lang.String]
arg0.toString == "Start"
size(this.symbols[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.getNonterminal():::ENTER
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.getNonterminal():::EXIT
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return != null
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.getRightSymbol(int):::ENTER
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
arg0 one of { 0, 1 }
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.getRightSymbol(int):::EXIT
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return != null
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.hashCode():::ENTER
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.hashCode():::EXIT
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.rightSize():::ENTER
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Rule.rightSize():::EXIT
this.symbols == orig(this.symbols)
this.symbols[] == orig(this.symbols[])
this.symbols.getClass().getName() == orig(this.symbols.getClass().getName())
this.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return one of { 1, 2 }
size(this.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax:::OBJECT
this.rules[] elements != null
this.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.rules.getClass().getName() == java.util.ArrayList.class
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.Syntax(int):::ENTER
arg0 == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.Syntax(int):::EXIT
this.rules has only one value
this.rules[] == []
this.rules[].getClass().getName() == []
this.ruleHash has only one value
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.Syntax(java.lang.String[][]):::ENTER
arg0 has only one value
arg0.getClass().getName() == java.lang.String[][].class
arg0[] contains no nulls and has only one value, of length 2
size(arg0[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.Syntax(java.lang.String[][]):::EXIT
arg0[] == orig(arg0[])
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 2
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
arg0[] contains no nulls and has only one value, of length 2
size(this.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.Syntax(java.util.List):::ENTER
arg0[].getClass().getName() elements == java.util.ArrayList.class
arg0[].getClass().getName() one of { [], [java.util.ArrayList, java.util.ArrayList] }
arg0.getClass().getName() == java.util.ArrayList.class
size(arg0[]) one of { 0, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.Syntax(java.util.List):::EXIT
this.rules.getClass().getName() == orig(arg0.getClass().getName())
arg0[] == orig(arg0[])
this.rules[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule] }
arg0[].getClass().getName() elements == java.util.ArrayList.class
arg0[].getClass().getName() one of { [], [java.util.ArrayList, java.util.ArrayList] }
size(this.rules[]) one of { 0, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.addRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
this.rules.getClass().getName() == arg0.symbols.getClass().getName()
this.rules != null
this.ruleHash != null
arg0 != null
arg0.symbols != null
arg0.symbols[] elements != null
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(arg0.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.addRule(fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.rules == orig(this.rules)
this.rules.getClass().getName() == arg0.symbols.getClass().getName()
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.rules.getClass().getName() == orig(arg0.symbols.getClass().getName())
this.ruleHash == orig(this.ruleHash)
arg0.symbols == orig(arg0.symbols)
arg0.symbols[] == orig(arg0.symbols[])
size(this.rules[])-1 == orig(size(this.rules[]))
this.rules != null
this.ruleHash != null
arg0.symbols != null
arg0.symbols[] elements != null
arg0.symbols[].getClass().getName() elements == java.lang.String.class
arg0.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(arg0.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.allocateRules(java.util.List):::ENTER
this.rules == null
this.ruleHash == null
arg0[].getClass().getName() elements == java.util.ArrayList.class
arg0[].getClass().getName() one of { [], [java.util.ArrayList, java.util.ArrayList] }
arg0.getClass().getName() == java.util.ArrayList.class
size(arg0[]) one of { 0, 2 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.allocateRules(java.util.List):::EXIT
this.rules.getClass().getName() == orig(arg0.getClass().getName())
arg0[] == orig(arg0[])
this.rules[] == []
this.rules[].getClass().getName() == []
arg0[].getClass().getName() elements == java.util.ArrayList.class
arg0[].getClass().getName() one of { [], [java.util.ArrayList, java.util.ArrayList] }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.appendRules(java.util.List):::ENTER
this.rules.getClass().getName() == arg0.getClass().getName()
this.rules[] == []
this.rules[].getClass().getName() == []
arg0[].getClass().getName() elements == java.util.ArrayList.class
arg0.getClass().getName() == java.util.ArrayList.class
size(arg0[]) one of { 0, 2, 16 }
this.rules.getClass().getName() in arg0[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.appendRules(java.util.List):::EXIT
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.rules.getClass().getName() == orig(arg0.getClass().getName())
arg0[] == orig(arg0[])
arg0[].getClass().getName() elements == java.util.ArrayList.class
size(this.rules[]) one of { 0, 2, 16 }
orig(this.rules.getClass().getName()) in arg0[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.findStartRules():::ENTER
this has only one value
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 1
this.rules[] elements has only one value
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
size(this.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.findStartRules():::EXIT
this.rules == orig(this.rules)
this.rules[] == orig(this.rules[])
this.rules.getClass().getName() == return.getClass().getName()
this.ruleHash == orig(this.ruleHash)
return.getClass().getName() == orig(this.rules.getClass().getName())
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 1
this.rules[] elements has only one value
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
return has only one value
return[] contains no nulls and has only one value, of length 1
return[] elements has only one value
return[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
return[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.getClass().getName() == java.util.ArrayList.class
size(this.rules[]) == 1
size(return[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.getRule(int):::ENTER
this.rules != null
this.ruleHash != null
arg0 >= 0
size(this.rules[]) >= 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.getRule(int):::EXIT
this.rules == orig(this.rules)
this.rules[] == orig(this.rules[])
this.rules.getClass().getName() == return.symbols.getClass().getName()
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.ruleHash == orig(this.ruleHash)
this.rules != null
this.ruleHash != null
return != null
return.symbols != null
return.symbols[] elements != null
return.symbols[].getClass().getName() elements == java.lang.String.class
return.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(this.rules[]) >= 1
size(return.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.hasRule(java.lang.String):::ENTER
this has only one value
this.rules has only one value
this.rules[] == []
this.rules[].getClass().getName() == []
this.ruleHash has only one value
arg0 has only one value
arg0.toString == "whitespaces"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.hasRule(java.lang.String):::EXIT246
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.hasRule(java.lang.String):::EXIT246;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.hasRule(java.lang.String):::EXIT
this.rules == orig(this.rules)
this.rules[] == orig(this.rules[])
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.ruleHash == orig(this.ruleHash)
arg0.toString == orig(arg0.toString)
this.rules has only one value
this.rules[] == []
this.rules[].getClass().getName() == []
this.ruleHash has only one value
arg0.toString == "whitespaces"
return == false
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.hasRule(java.lang.String):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.insertRule(int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::ENTER
this.rules.getClass().getName() == arg1.symbols.getClass().getName()
this.rules != null
this.ruleHash != null
arg0 >= 0
arg1 != null
arg1.symbols != null
arg1.symbols[] elements != null
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg1.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(arg1.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.insertRule(int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT92
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.insertRule(int, fri.patterns.interpreter.parsergenerator.syntax.Rule):::EXIT
this.rules == orig(this.rules)
this.rules.getClass().getName() == arg1.symbols.getClass().getName()
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.rules.getClass().getName() == orig(arg1.symbols.getClass().getName())
this.ruleHash == orig(this.ruleHash)
arg1.symbols == orig(arg1.symbols)
arg1.symbols[] == orig(arg1.symbols[])
size(this.rules[])-1 == orig(size(this.rules[]))
this.rules != null
this.ruleHash != null
arg1.symbols != null
arg1.symbols[] elements != null
arg1.symbols[].getClass().getName() elements == java.lang.String.class
arg1.symbols[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
size(arg1.symbols[]) one of { 2, 3 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.removeRule(int):::ENTER
this.rules != null
this.ruleHash != null
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.removeRule(int):::EXIT
this.rules == orig(this.rules)
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.ruleHash == orig(this.ruleHash)
size(this.rules[]) == orig(size(this.rules[]))-1
this.rules != null
this.ruleHash != null
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.removeSingular():::ENTER
this has only one value
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 2
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
size(this.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.removeSingular():::EXIT188
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.removeSingular():::EXIT
this.rules == orig(this.rules)
this.rules[] == orig(this.rules[])
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.ruleHash == orig(this.ruleHash)
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 2
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
return == null
size(this.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.resolveSingulars():::ENTER
this has only one value
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 2
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
size(this.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.resolveSingulars():::EXIT
this.rules == orig(this.rules)
this.rules[] == orig(this.rules[])
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.ruleHash == orig(this.ruleHash)
this.rules has only one value
this.rules[] contains no nulls and has only one value, of length 2
this.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.ruleHash has only one value
size(this.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.size():::ENTER
this.rules != null
this.ruleHash != null
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.Syntax.size():::EXIT
this.rules == orig(this.rules)
this.rules[] == orig(this.rules[])
this.rules.getClass().getName() == orig(this.rules.getClass().getName())
this.ruleHash == orig(this.ruleHash)
this.rules != null
this.ruleHash != null
return >= 0
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.SyntaxUtil.appendToRule(java.lang.String[], java.util.List):::ENTER
arg0 != null
arg0.getClass().getName() == java.lang.String[].class
arg0[] elements != null
arg1 != null
arg1[] == []
arg1[].getClass().getName() == []
arg1.getClass().getName() == java.util.ArrayList.class
size(arg0[]) one of { 2, 3 }
arg0.getClass().getName() != arg1.getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.SyntaxUtil.appendToRule(java.lang.String[], java.util.List):::EXIT
arg0[] == orig(arg0[])
return == orig(arg1)
return.getClass().getName() == orig(arg1.getClass().getName())
arg0[] elements != null
arg1[] elements != null
arg1[].getClass().getName() elements == java.lang.String.class
arg1[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return != null
return[] elements != null
return[].getClass().getName() elements == java.lang.String.class
return[].getClass().getName() one of { [java.lang.String, java.lang.String], [java.lang.String, java.lang.String, java.lang.String] }
return.getClass().getName() == java.util.ArrayList.class
size(return[]) one of { 2, 3 }
return.getClass().getName() != orig(arg0.getClass().getName())
size(arg1[])-1 > orig(size(arg1[]))
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.SyntaxUtil.appendToSyntax(java.lang.String[][], java.util.List):::ENTER
arg0.getClass().getName() == java.lang.String[][].class
arg1[] == []
arg1[].getClass().getName() == []
arg1.getClass().getName() == java.util.ArrayList.class
size(arg0[]) one of { 2, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.SyntaxUtil.appendToSyntax(java.lang.String[][], java.util.List):::EXIT
arg0[] == orig(arg0[])
return == orig(arg1)
return.getClass().getName() == orig(arg1.getClass().getName())
arg1[].getClass().getName() elements == java.util.ArrayList.class
arg1[].getClass().getName() one of { [java.util.ArrayList, java.util.ArrayList], [java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList] }
return[].getClass().getName() elements == java.util.ArrayList.class
return[].getClass().getName() one of { [java.util.ArrayList, java.util.ArrayList], [java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList] }
return.getClass().getName() == java.util.ArrayList.class
size(return[]) one of { 2, 16 }
return.getClass().getName() in arg1[].getClass().getName()
return.getClass().getName() in return[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.SyntaxUtil.ruleArrayToList(java.lang.String[][]):::ENTER
arg0.getClass().getName() == java.lang.String[][].class
size(arg0[]) one of { 2, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.SyntaxUtil.ruleArrayToList(java.lang.String[][]):::EXIT
arg0[] == orig(arg0[])
return[].getClass().getName() elements == java.util.ArrayList.class
return[].getClass().getName() one of { [java.util.ArrayList, java.util.ArrayList], [java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList, java.util.ArrayList] }
return.getClass().getName() == java.util.ArrayList.class
size(return[]) one of { 2, 16 }
return.getClass().getName() in return[].getClass().getName()
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray:::OBJECT
this.array != null
this.array[] elements >= 0
this.pos >= 0
size(this.array[]) one of { 2, 16 }
this.array[] elements <= size(this.array[])-1
this.pos <= size(this.array[])-1
size(this.array[])-1 >= this.array[this.pos]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.IntArray(int):::ENTER
arg0 one of { 2, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.IntArray(int):::EXIT
this.pos == this.array[this.pos]
this.pos == this.array[orig(arg0)-1]
orig(arg0) == size(this.array[])
this.array[] elements == 0
this.array[] one of { [0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
this.pos == 0
this.array[] elements == this.pos
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.add(int):::ENTER
this.array[this.pos] == this.array[arg0]
this.array[this.pos] one of { 0, 1, 2 }
this.pos <= arg0
this.pos < size(this.array[])-1
this.pos >= this.array[this.pos]
arg0 <= size(this.array[])-1
arg0 >= this.array[this.pos]
size(this.array[])-1 > this.array[this.pos]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.add(int):::EXIT
this.array == orig(this.array)
orig(arg0) == this.array[this.pos-1]
orig(arg0) == this.array[orig(this.pos)]
size(this.array[]) == orig(size(this.array[]))
this.array[this.pos] == orig(this.array[post(this.pos)])
orig(this.array[post(this.pos)-1]) == orig(this.array[arg0])
this.pos >= 1
this.array[orig(arg0)] one of { 0, 1, 2 }
orig(this.array[arg0]) one of { 0, 1, 2 }
this.array[] >= orig(this.array[]) (elementwise)
orig(this.array[arg0]) in this.array[]
this.pos - orig(this.pos) - 1 == 0
this.pos > this.array[orig(arg0)]
this.pos > orig(this.array[arg0])
orig(this.array[]) elements <= size(this.array[])-1
orig(this.pos) < size(this.array[])-1
orig(this.pos) >= this.array[orig(arg0)]
orig(this.pos) >= orig(this.array[arg0])
orig(arg0) <= size(this.array[])-1
orig(arg0) >= this.array[orig(arg0)]
size(this.array[])-1 > this.array[this.pos]
size(this.array[])-1 > this.array[orig(arg0)]
size(this.array[])-1 > orig(this.array[arg0])
this.array[this.pos] >= orig(this.array[arg0])
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.contains(int):::ENTER
this.pos == arg0
size(this.array[])-1 == this.array[this.pos]
size(this.array[])-1 == this.array[arg0]
this has only one value
this.array has only one value
this.array[] == [1, 0]
this.array[] elements one of { 0, 1 }
this.pos == 0
size(this.array[]) == 2
this.pos in this.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.contains(int):::EXIT327
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.contains(int):::EXIT327;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.contains(int):::EXIT
this.array == orig(this.array)
this.array[] == orig(this.array[])
this.pos == orig(this.pos)
this.pos == orig(arg0)
size(this.array[])-1 == this.array[this.pos]
size(this.array[])-1 == this.array[orig(this.pos)]
size(this.array[])-1 == this.array[orig(arg0)]
size(this.array[])-1 == orig(this.array[post(this.pos)])
size(this.array[])-1 == orig(this.array[post(arg0)])
size(this.array[])-1 == orig(this.array[this.pos])
size(this.array[])-1 == orig(this.array[arg0])
this.array has only one value
this.array[] == [1, 0]
this.array[] elements one of { 0, 1 }
this.pos == 0
return == false
size(this.array[]) == 2
this.pos in this.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.contains(int):::EXIT;condition="not(return == true)"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.isEmpty():::ENTER
size(this.array[])-1 == this.array[this.pos]
this has only one value
this.array has only one value
this.array[] == [1, 0]
this.array[] elements one of { 0, 1 }
this.pos == 0
size(this.array[]) == 2
this.pos in this.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.isEmpty():::EXIT
this.array == orig(this.array)
this.array[] == orig(this.array[])
this.pos == orig(this.pos)
size(this.array[])-1 == this.array[this.pos]
size(this.array[])-1 == this.array[orig(this.pos)]
size(this.array[])-1 == orig(this.array[post(this.pos)])
size(this.array[])-1 == orig(this.array[this.pos])
this.array has only one value
this.array[] == [1, 0]
this.array[] elements one of { 0, 1 }
this.pos == 0
return == true
size(this.array[]) == 2
this.pos in this.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.isEmpty():::EXIT;condition="return == true"
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.removeIndexesFrom(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
this.array[] one of { [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 0, 0, 0], [1, 0] }
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
this.array[this.pos] one of { 0, 1, 4 }
size(this.array[])-1 in this.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray.removeIndexesFrom(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
this.array == orig(this.array)
this.array[] == orig(this.array[])
arg0.rules == orig(arg0.rules)
arg0.rules.getClass().getName() == orig(arg0.rules.getClass().getName())
arg0.ruleHash == orig(arg0.ruleHash)
this.array[] one of { [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 0, 0, 0], [1, 0] }
this.pos == 0
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
size(arg0.rules[]) one of { 0, 1, 3 }
this.array[this.pos] one of { 0, 1 }
this.array[orig(this.pos)] one of { 0, 1, 4 }
this.pos in this.array[]
size(this.array[])-1 in this.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation:::CLASS
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == true
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation:::OBJECT
this.tokenSymbols.getClass().getName() == this.ignoredSymbols.getClass().getName()
this.tokenSymbols.getClass().getName() == this.parserSyntax.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == this.lexerSyntax.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == this.parserSyntax.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == this.lexerSyntax.rules.getClass().getName()
this.parserSyntax.rules.getClass().getName() == this.lexerSyntax.rules.getClass().getName()
this has only one value
this.tokenSymbols[] == []
this.tokenSymbols[].getClass().getName() == []
this.tokenSymbols.getClass().getName() == java.util.ArrayList.class
this.ignoredSymbols[] contains no nulls and has only one value, of length 1
this.ignoredSymbols[] elements has only one value
this.ignoredSymbols[] elements != null
this.ignoredSymbols[].getClass().getName() == [java.lang.String]
this.ignoredSymbols[].getClass().getName() elements == java.lang.String.class
this.ignoredSymbols.getClass().getName() == java.util.ArrayList.class
this.parserSyntax.rules has only one value
this.parserSyntax.rules[] contains no nulls and has only one value, of length 1
this.parserSyntax.rules[] elements has only one value
this.parserSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
this.parserSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.parserSyntax.rules.getClass().getName() == java.util.ArrayList.class
this.parserSyntax.ruleHash has only one value
this.lexerSyntax.rules has only one value
this.lexerSyntax.rules != null
this.lexerSyntax.rules[] elements != null
this.lexerSyntax.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
this.lexerSyntax.rules[].getClass().getName() one of { [], [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule] }
this.lexerSyntax.rules.getClass().getName() == java.util.ArrayList.class
this.lexerSyntax.ruleHash has only one value
this.lexerSyntax.ruleHash != null
size(this.ignoredSymbols[]) == 1
size(this.parserSyntax.rules[]) == 1
size(this.lexerSyntax.rules[]) one of { 0, 16 }
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.SyntaxSeparation(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::ENTER
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
size(arg0.rules[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.SyntaxSeparation(fri.patterns.interpreter.parsergenerator.syntax.Syntax):::EXIT
this.tokenSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == orig(arg0.rules.getClass().getName())
this.parserSyntax == orig(arg0)
this.parserSyntax.rules == arg0.rules
this.parserSyntax.ruleHash == arg0.ruleHash
arg0.rules == orig(arg0.rules)
arg0.ruleHash == orig(arg0.ruleHash)
size(arg0.rules[]) == orig(size(arg0.rules[]))-1
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.ruleHash has only one value
size(this.lexerSyntax.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getIgnoredSymbols():::ENTER
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
size(this.lexerSyntax.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getIgnoredSymbols():::EXIT
this.tokenSymbols == orig(this.tokenSymbols)
this.tokenSymbols[] == orig(this.tokenSymbols[])
this.tokenSymbols.getClass().getName() == return.getClass().getName()
this.ignoredSymbols == return
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == return.getClass().getName()
this.parserSyntax == orig(this.parserSyntax)
this.parserSyntax.rules == orig(this.parserSyntax.rules)
this.parserSyntax.rules[] == orig(this.parserSyntax.rules[])
this.parserSyntax.rules.getClass().getName() == return.getClass().getName()
this.parserSyntax.ruleHash == orig(this.parserSyntax.ruleHash)
this.lexerSyntax == orig(this.lexerSyntax)
this.lexerSyntax.rules == orig(this.lexerSyntax.rules)
this.lexerSyntax.rules[] == orig(this.lexerSyntax.rules[])
this.lexerSyntax.rules.getClass().getName() == return.getClass().getName()
this.lexerSyntax.ruleHash == orig(this.lexerSyntax.ruleHash)
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
return == orig(this.ignoredSymbols)
return.getClass().getName() == orig(this.tokenSymbols.getClass().getName())
return.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
return.getClass().getName() == orig(this.parserSyntax.rules.getClass().getName())
return.getClass().getName() == orig(this.lexerSyntax.rules.getClass().getName())
this.tokenSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return has only one value
return[] contains no nulls and has only one value, of length 1
return[] elements has only one value
return[].getClass().getName() == [java.lang.String]
return[].getClass().getName() elements == java.lang.String.class
return.getClass().getName() == java.util.ArrayList.class
size(this.lexerSyntax.rules[]) == 16
size(return[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getLexerSyntax():::ENTER
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
size(this.lexerSyntax.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getLexerSyntax():::EXIT
this.tokenSymbols == orig(this.tokenSymbols)
this.tokenSymbols[] == orig(this.tokenSymbols[])
this.tokenSymbols.getClass().getName() == return.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == orig(this.tokenSymbols.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.parserSyntax.rules.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.lexerSyntax.rules.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.parserSyntax == orig(this.parserSyntax)
this.parserSyntax.rules == orig(this.parserSyntax.rules)
this.parserSyntax.rules[] == orig(this.parserSyntax.rules[])
this.parserSyntax.ruleHash == orig(this.parserSyntax.ruleHash)
this.lexerSyntax == return
this.lexerSyntax.rules == return.rules
this.lexerSyntax.rules[] == orig(this.lexerSyntax.rules[])
this.lexerSyntax.ruleHash == return.ruleHash
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
return == orig(this.lexerSyntax)
return.rules == orig(this.lexerSyntax.rules)
return.ruleHash == orig(this.lexerSyntax.ruleHash)
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return has only one value
return.rules has only one value
return.rules[] contains no nulls and has only one value, of length 16
return.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.ruleHash has only one value
size(this.lexerSyntax.rules[]) == 16
size(return.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getParserSyntax():::ENTER
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] == []
this.lexerSyntax.rules[].getClass().getName() == []
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getParserSyntax():::EXIT
this.tokenSymbols == orig(this.tokenSymbols)
this.tokenSymbols[] == orig(this.tokenSymbols[])
this.tokenSymbols.getClass().getName() == return.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == orig(this.tokenSymbols.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.parserSyntax.rules.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.lexerSyntax.rules.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.parserSyntax == return
this.parserSyntax.rules == return.rules
this.parserSyntax.rules[] == orig(this.parserSyntax.rules[])
this.parserSyntax.ruleHash == return.ruleHash
this.lexerSyntax == orig(this.lexerSyntax)
this.lexerSyntax.rules == orig(this.lexerSyntax.rules)
this.lexerSyntax.rules[] == orig(this.lexerSyntax.rules[])
this.lexerSyntax.ruleHash == orig(this.lexerSyntax.ruleHash)
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
return == orig(this.parserSyntax)
return.rules == orig(this.parserSyntax.rules)
return.ruleHash == orig(this.parserSyntax.ruleHash)
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] == []
this.lexerSyntax.rules[].getClass().getName() == []
return has only one value
return.rules has only one value
return.rules[] contains no nulls and has only one value, of length 1
return.rules[] elements has only one value
return.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
return.ruleHash has only one value
size(return.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getRulesUnderSymbol(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::ENTER
this.lexerSyntax == arg2
this.lexerSyntax.rules == arg2.rules
this.lexerSyntax.ruleHash == arg2.ruleHash
this.tokenSymbols == null
this.ignoredSymbols == null
this.parserSyntax == null
this.lexerSyntax has only one value
this.lexerSyntax.rules[] == []
this.lexerSyntax.rules[].getClass().getName() == []
arg0 has only one value
arg0.toString == "whitespaces"
arg1 has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 1
arg1.rules[] elements has only one value
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.ruleHash has only one value
arg2.rules[] == []
arg2.rules[].getClass().getName() == []
arg3 has only one value
arg3.array has only one value
arg3.array[] == [1, 0]
arg3.array[] elements one of { 0, 1 }
arg3.pos == 0
size(arg1.rules[]) == 1
size(arg3.array[]) == 2
size(arg3.array[])-1 in arg3.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getRulesUnderSymbol(java.lang.String, fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT
this.tokenSymbols == orig(this.tokenSymbols)
this.ignoredSymbols == orig(this.ignoredSymbols)
this.parserSyntax == orig(this.parserSyntax)
this.lexerSyntax == orig(this.lexerSyntax)
this.lexerSyntax == orig(arg2)
this.lexerSyntax.rules == arg2.rules
this.lexerSyntax.rules[] == orig(this.lexerSyntax.rules[])
this.lexerSyntax.ruleHash == arg2.ruleHash
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
arg0.toString == orig(arg0.toString)
arg1.rules == orig(arg1.rules)
arg1.rules[] == orig(arg1.rules[])
arg1.ruleHash == orig(arg1.ruleHash)
arg2.rules == orig(this.lexerSyntax.rules)
arg2.rules == orig(arg2.rules)
arg2.rules[] == orig(arg2.rules[])
arg2.ruleHash == orig(this.lexerSyntax.ruleHash)
arg2.ruleHash == orig(arg2.ruleHash)
arg3.array == orig(arg3.array)
arg3.array[] == orig(arg3.array[])
arg3.pos == orig(arg3.pos)
this.tokenSymbols == null
this.ignoredSymbols == null
this.parserSyntax == null
this.lexerSyntax has only one value
this.lexerSyntax.rules[] == []
this.lexerSyntax.rules[].getClass().getName() == []
arg0.toString == "whitespaces"
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 1
arg1.rules[] elements has only one value
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.rules.getClass().getName() == java.util.ArrayList.class
arg1.ruleHash has only one value
arg2.rules has only one value
arg2.rules[] == []
arg2.rules[].getClass().getName() == []
arg2.ruleHash has only one value
arg3.array has only one value
arg3.array[] == [1, 0]
arg3.array[] elements one of { 0, 1 }
arg3.pos == 0
size(arg1.rules[]) == 1
size(arg3.array[]) == 2
size(arg3.array[])-1 in arg3.array[]
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getTokenSymbols():::ENTER
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
size(this.lexerSyntax.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.getTokenSymbols():::EXIT
this.tokenSymbols == return
this.tokenSymbols[] == orig(this.tokenSymbols[])
this.tokenSymbols.getClass().getName() == return.getClass().getName()
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.ignoredSymbols.getClass().getName() == return.getClass().getName()
this.parserSyntax == orig(this.parserSyntax)
this.parserSyntax.rules == orig(this.parserSyntax.rules)
this.parserSyntax.rules[] == orig(this.parserSyntax.rules[])
this.parserSyntax.rules.getClass().getName() == return.getClass().getName()
this.parserSyntax.ruleHash == orig(this.parserSyntax.ruleHash)
this.lexerSyntax == orig(this.lexerSyntax)
this.lexerSyntax.rules == orig(this.lexerSyntax.rules)
this.lexerSyntax.rules[] == orig(this.lexerSyntax.rules[])
this.lexerSyntax.rules.getClass().getName() == return.getClass().getName()
this.lexerSyntax.ruleHash == orig(this.lexerSyntax.ruleHash)
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
return == orig(this.tokenSymbols)
return.getClass().getName() == orig(this.tokenSymbols.getClass().getName())
return.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
return.getClass().getName() == orig(this.parserSyntax.rules.getClass().getName())
return.getClass().getName() == orig(this.lexerSyntax.rules.getClass().getName())
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
return has only one value
return[] == []
return[].getClass().getName() == []
return.getClass().getName() == java.util.ArrayList.class
size(this.lexerSyntax.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.provideParserSyntax(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.Syntax, boolean, java.util.Map, java.util.List, java.util.List):::ENTER
this.ignoredSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == arg1.rules.getClass().getName()
this.ignoredSymbols.getClass().getName() == arg4.getClass().getName()
this.ignoredSymbols.getClass().getName() == arg5.getClass().getName()
this.lexerSyntax == arg1
this.lexerSyntax.rules == arg1.rules
this.lexerSyntax.ruleHash == arg1.ruleHash
this.tokenSymbols == null
this.ignoredSymbols has only one value
this.parserSyntax == null
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.ruleHash has only one value
arg1.rules[] contains no nulls and has only one value, of length 16
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg2 == false
arg3 has only one value
arg3.getClass().getName() == java.util.Hashtable.class
arg4 has only one value
arg4[] == []
arg4[].getClass().getName() == []
arg5 has only one value
arg5[] == []
arg5[].getClass().getName() == []
size(this.lexerSyntax.rules[]) == 16
size(arg0.rules[]) == 1
size(arg1.rules[]) == 16
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.provideParserSyntax(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.Syntax, boolean, java.util.Map, java.util.List, java.util.List):::EXIT
this.tokenSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == arg1.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == return.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == orig(this.ignoredSymbols.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(this.lexerSyntax.rules.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(arg0.rules.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(arg1.rules.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(arg4.getClass().getName())
this.tokenSymbols.getClass().getName() == orig(arg5.getClass().getName())
this.ignoredSymbols == orig(this.ignoredSymbols)
this.ignoredSymbols[] == orig(this.ignoredSymbols[])
this.parserSyntax == orig(this.parserSyntax)
this.lexerSyntax == orig(this.lexerSyntax)
this.lexerSyntax == orig(arg1)
this.lexerSyntax.rules == arg1.rules
this.lexerSyntax.rules[] == orig(this.lexerSyntax.rules[])
this.lexerSyntax.ruleHash == arg1.ruleHash
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
arg0.rules == return.rules
arg0.rules == orig(arg0.rules)
arg0.rules[] == orig(arg0.rules[])
arg0.ruleHash == return.ruleHash
arg0.ruleHash == orig(arg0.ruleHash)
arg1.rules == orig(this.lexerSyntax.rules)
arg1.rules == orig(arg1.rules)
arg1.rules[] == orig(arg1.rules[])
arg1.ruleHash == orig(this.lexerSyntax.ruleHash)
arg1.ruleHash == orig(arg1.ruleHash)
arg4[] == orig(arg4[])
arg5[] == orig(arg5[])
return == orig(arg0)
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax == null
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.ruleHash has only one value
arg1.rules has only one value
arg1.rules[] contains no nulls and has only one value, of length 16
arg1.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg1.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg1.ruleHash has only one value
arg4[] == []
arg4[].getClass().getName() == []
arg5[] == []
arg5[].getClass().getName() == []
return has only one value
return.rules[] contains no nulls and has only one value, of length 1
return.rules[] elements has only one value
return.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
return.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
size(this.lexerSyntax.rules[]) == 16
size(arg0.rules[]) == 1
size(arg1.rules[]) == 16
size(return.rules[]) == 1
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.separate(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::ENTER
this.tokenSymbols == null
this.ignoredSymbols == null
this.parserSyntax == null
this.lexerSyntax == null
arg0 has only one value
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 2
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.rules.getClass().getName() == java.util.ArrayList.class
arg0.ruleHash has only one value
arg1 has only one value
arg1.array has only one value
arg1.array[] == [0, 0]
arg1.array[] elements == 0
arg1.pos == 0
size(arg0.rules[]) == 2
size(arg1.array[]) == 2
===========================================================================
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.separate(fri.patterns.interpreter.parsergenerator.syntax.Syntax, fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation$IntArray):::EXIT
this.tokenSymbols.getClass().getName() == arg0.rules.getClass().getName()
this.tokenSymbols.getClass().getName() == orig(arg0.rules.getClass().getName())
this.parserSyntax == orig(arg0)
this.parserSyntax.rules == arg0.rules
this.parserSyntax.ruleHash == arg0.ruleHash
fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG == orig(fri.patterns.interpreter.parsergenerator.syntax.builder.SyntaxSeparation.DEBUG)
arg0.rules == orig(arg0.rules)
arg0.ruleHash == orig(arg0.ruleHash)
arg1.array == orig(arg1.array)
arg1.pos == orig(arg1.pos)
size(arg0.rules[]) == orig(size(arg0.rules[]))-1
size(arg1.array[]) == orig(size(arg1.array[]))
this.tokenSymbols has only one value
this.ignoredSymbols has only one value
this.parserSyntax has only one value
this.lexerSyntax has only one value
this.lexerSyntax.rules[] contains no nulls and has only one value, of length 16
this.lexerSyntax.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule, fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules has only one value
arg0.rules[] contains no nulls and has only one value, of length 1
arg0.rules[] elements has only one value
arg0.rules[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.syntax.Rule]
arg0.rules[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.syntax.Rule.class
arg0.ruleHash has only one value
arg1.array has only one value
arg1.array[] == [1, 0]
arg1.array[] elements one of { 0, 1 }
arg1.pos == 0
size(this.lexerSyntax.rules[]) == 16
size(arg1.array[]) == 2
size(arg1.array[])-1 in arg1.array[]
===========================================================================
fri.util.Equals.equals(java.lang.Object, java.lang.Object):::ENTER
arg0.getClass().getName() == arg1.getClass().getName()
arg0.getClass().getName() == java.lang.Character.class
===========================================================================
fri.util.Equals.equals(java.lang.Object, java.lang.Object):::EXIT
===========================================================================
fri.util.Equals.equals(java.lang.Object, java.lang.Object):::EXIT;condition="return == true"
return == true
===========================================================================
fri.util.Equals.equals(java.lang.Object, java.lang.Object):::EXIT;condition="not(return == true)"
return == false
===========================================================================
fri.util.TimeStopper:::OBJECT
this.time1 == this.time2
this.time1 >= 0
this.timeSum >= 0
this.lastIntervalStop >= 0
this.time1 <= this.lastIntervalStop
this.timeSum <= this.lastIntervalStop
===========================================================================
fri.util.TimeStopper.TimeStopper():::EXIT
this.time1 == this.lastIntervalStop
this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L }
this.timeSum == 0
===========================================================================
fri.util.TimeStopper.TimeStopper(boolean):::ENTER
arg0 == true
===========================================================================
fri.util.TimeStopper.TimeStopper(boolean):::EXIT
this.time1 == this.lastIntervalStop
this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L }
this.timeSum == 0
===========================================================================
fri.util.TimeStopper.getTimeMillis():::ENTER
this.time1 == this.lastIntervalStop
this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L }
this.timeSum == 0
===========================================================================
fri.util.TimeStopper.getTimeMillis():::EXIT
this.time1 == this.lastIntervalStop
this.time1 one of { 1743928033837L, 1743928033902L, 1743928033911L }
this.timeSum one of { 12, 57, 183 }
return.toString one of { "12", "183", "57" }
===========================================================================
fri.util.TimeStopper.isRunning():::ENTER
===========================================================================
fri.util.TimeStopper.isRunning():::EXIT
this.time1 == orig(this.time1)
this.time1 == orig(this.time2)
this.timeSum == orig(this.timeSum)
this.lastIntervalStop == orig(this.lastIntervalStop)
(this.time1 == 0)  <==>  (return == false)
(this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L })  <==>  (return == true)
(this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L })  ==>  (this.lastIntervalStop one of { 1743928033728L, 1743928033780L, 1743928033890L })
(this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L })  ==>  (this.time1 == this.lastIntervalStop)
(this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L })  ==>  (this.timeSum == 0)
===========================================================================
fri.util.TimeStopper.isRunning():::EXIT;condition="return == true"
this.time1 == this.lastIntervalStop
this.time1 == orig(this.lastIntervalStop)
this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L }
this.timeSum == 0
return == true
===========================================================================
fri.util.TimeStopper.isRunning():::EXIT;condition="not(return == true)"
this.time1 == 0
return == false
===========================================================================
fri.util.TimeStopper.resume():::ENTER
this.time1 == 0
===========================================================================
fri.util.TimeStopper.resume():::EXIT
this.time1 == this.lastIntervalStop
this.timeSum == orig(this.timeSum)
===========================================================================
fri.util.TimeStopper.suspend():::ENTER
this.time1 == this.lastIntervalStop
this.time1 one of { 1743928033728L, 1743928033780L, 1743928033890L }
this.timeSum == 0
===========================================================================
fri.util.TimeStopper.suspend():::EXIT
this.time1 == orig(this.timeSum)
this.lastIntervalStop == orig(this.time1)
this.lastIntervalStop == orig(this.time2)
this.lastIntervalStop == orig(this.lastIntervalStop)
this.time1 == 0
this.timeSum one of { 12, 57, 183 }
this.lastIntervalStop one of { 1743928033728L, 1743928033780L, 1743928033890L }
===========================================================================
fri.util.collections.AggregatingHashtable:::OBJECT
===========================================================================
fri.util.collections.AggregatingHashtable.AggregatingHashtable():::EXIT
===========================================================================
fri.util.collections.AggregatingHashtable.createAggregationList():::ENTER
===========================================================================
fri.util.collections.AggregatingHashtable.createAggregationList():::EXIT
return != null
return[] == []
return[].getClass().getName() == []
return.getClass().getName() == java.util.ArrayList.class
===========================================================================
fri.util.collections.AggregatingHashtable.put(java.lang.Object, java.lang.Object):::ENTER
arg0 != null
arg1 != null
===========================================================================
fri.util.collections.AggregatingHashtable.put(java.lang.Object, java.lang.Object):::EXIT45
===========================================================================
fri.util.collections.AggregatingHashtable.put(java.lang.Object, java.lang.Object):::EXIT
return.getClass().getName() == java.util.ArrayList.class
===========================================================================
fri.util.collections.AggregatingHashtable.shouldAdd(java.util.List, java.lang.Object):::ENTER
this has only one value
arg0 has only one value
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
arg0.getClass().getName() == java.util.ArrayList.class
arg1 has only one value
arg1.getClass().getName() == fri.patterns.interpreter.parsergenerator.lexer.Strategy$Item.class
size(arg0[]) == 1
===========================================================================
fri.util.collections.AggregatingHashtable.shouldAdd(java.util.List, java.lang.Object):::EXIT
arg0[] == orig(arg0[])
arg0[] contains no nulls and has only one value, of length 1
arg0[] elements has only one value
arg0[].getClass().getName() == [fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item]
arg0[].getClass().getName() elements == fri.patterns.interpreter.parsergenerator.lexer.Strategy.Item.class
return == true
===========================================================================
fri.util.collections.AggregatingHashtable.shouldAdd(java.util.List, java.lang.Object):::EXIT;condition="return == true"
===========================================================================
fri.util.collections.UniqueAggregatingHashtable:::OBJECT
this has only one value
===========================================================================
fri.util.collections.UniqueAggregatingHashtable.UniqueAggregatingHashtable():::EXIT
===========================================================================
fri.util.props.ConfigDir:::CLASS
fri.util.props.ConfigDir.dir.toString == "/home/nima/.friware/"
===========================================================================
fri.util.props.ConfigDir.dir():::ENTER
===========================================================================
fri.util.props.ConfigDir.dir():::EXIT
fri.util.props.ConfigDir.dir == return
fri.util.props.ConfigDir.dir.toString == orig(fri.util.props.ConfigDir.dir.toString)
fri.util.props.ConfigDir.dir has only one value
return.toString == "/home/nima/.friware/"
Exiting Daikon.
